#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Mar 20 12:32:25 2022 by generateDS.py version 2.40.9.
# Python 3.8.10 (default, Nov 26 2021, 20:14:08)  [GCC 9.3.0]
#
# Command line options:
#   ('-f', '')
#   ('-o', 'out/ipxact.py')
#   ('--user-methods', 'gends_user_methods.py')
#
# Command line arguments:
#   2014/index.xsd
#
# Command line:
#   /home/olof/.local/bin/generateDS -f -o "out/ipxact.py" --user-methods="gends_user_methods.py" 2014/index.xsd
#
# Current working directory (os.getcwd()):
#   ipxact_gen
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
from lxml import etree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
TagNamePrefix = ""
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def __str__(self):
            settings = {
                'str_pretty_print': True,
                'str_indent_level': 0,
                'str_namespaceprefix': '',
                'str_name': self.__class__.__name__,
                'str_namespacedefs': '',
            }
            for n in settings:
                if hasattr(self, n):
                    settings[n] = getattr(self, n)
            if sys.version_info.major == 2:
                from StringIO import StringIO
            else:
                from io import StringIO
            output = StringIO()
            self.export(
                output,
                settings['str_indent_level'],
                pretty_print=settings['str_pretty_print'],
                namespaceprefix_=settings['str_namespaceprefix'],
                name_=settings['str_name'],
                namespacedef_=settings['str_namespacedefs']
            )
            strval = output.getvalue()
            output.close()
            return strval
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data).decode('ascii')
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % int(input_data)
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % float(input_data)).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            target = str(target)
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, reverse_mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class abstractorModeType(str, Enum):
    """abstractorModeType -- Mode for this abstractor
    
    """
    MASTER='master'
    SLAVE='slave'
    DIRECT='direct'
    SYSTEM='system'


class accessType_impl(str, Enum):
    """accessType_impl -- The read/write accessability of an addess block.
    
    """
    READONLY='read-only'
    WRITEONLY='write-only'
    READWRITE='read-write'
    WRITE_ONCE='writeOnce'
    READWRITE_ONCE='read-writeOnce'


class apiType(str, Enum):
    TGI__2009='TGI_2009'
    TGI__2014_BASE='TGI_2014_BASE'
    TGI__2014_EXTENDED='TGI_2014_EXTENDED'
    NONE='none'


class bankAlignmentType(str, Enum):
    """bankAlignmentType -- 'serial' or 'parallel' bank alignment.
    
    """
    SERIAL='serial'
    PARALLEL='parallel'


class cellClassValueType(str, Enum):
    """cellClassValueType -- Indicates legal cell class values.
    
    """
    COMBINATIONAL='combinational'
    SEQUENTIAL='sequential'


class cellFunctionValueType(str, Enum):
    """cellFunctionValueType -- Indicates legal cell function values.
    
    """
    NAND_2='nand2'
    BUF='buf'
    INV='inv'
    MUX_21='mux21'
    DFF='dff'
    LATCH='latch'
    XOR_2='xor2'
    OTHER='other'


class cellStrengthValueType(str, Enum):
    """cellStrengthValueType -- Indicates legal cell strength values.
    
    """
    LOW='low'
    MEDIAN='median'
    HIGH='high'


class componentPortDirectionType(str, Enum):
    """componentPortDirectionType -- The direction of a component port.
    
    """
    IN='in'
    OUT='out'
    INOUT='inout'
    PHANTOM='phantom'


class dataTypeType(str, Enum):
    """dataTypeType -- Enumerates C argument data types.
    
    """
    INT='int'
    UNSIGNEDINT='unsigned int'
    LONG='long'
    UNSIGNEDLONG='unsigned long'
    FLOAT='float'
    DOUBLE='double'
    CHAR='char *'
    VOID='void *'


class delayValueType(str, Enum):
    """delayValueType -- Indicates the type of delay value - minimum or maximum delay.
    
    """
    MIN='min'
    MAX='max'


class delayValueUnitType(str, Enum):
    """delayValueUnitType -- Indicates legal units for delay values.
    
    """
    PS='ps'
    NS='ns'


class direction(str, Enum):
    IN='in'
    OUT='out'
    INOUT='inout'


class driverTypeType(str, Enum):
    """driverTypeType -- Defines the type of driver that is required. The default is any type of driver. The 2 other options are a clock type driver or a singleshot type driver.
    
    """
    CLOCK='clock'
    SINGLE_SHOT='singleShot'
    ANY='any'


class edgeValueType(str, Enum):
    """edgeValueType -- Indicates legal values for edge specification attributes.
    
    """
    RISE='rise'
    FALL='fall'


class endianessType(str, Enum):
    """endianessType -- 'big': means the most significant element of any multi-element  data field is stored at the lowest memory address. 'little' means the least significant element of any multi-element data field is stored at the lowest memory address. If this element is not present the default is 'little' endian.
    
    """
    BIG='big'
    LITTLE='little'


class formatType(str, Enum):
    """formatType -- This is an indication on the format of the value. bit: 1-bit or more (vector) bits unsigned integer, byte: 8-bit signed integer, shortint: 16-bit signed integer, int: 32-bit signed integer, longint: 64-bit signed integer, shortreal: 32-bit signed floating point number, real: 64-bit signed floating point number, string: textual information.
    
    """
    BIT='bit'
    BYTE='byte'
    SHORTINT='shortint'
    INT='int'
    LONGINT='longint'
    SHORTREAL='shortreal'
    REAL='real'
    STRING='string'


class initiativeType34(str, Enum):
    """initiativeType34 -- If this element is present, the type of access is restricted to the specified value.
    
    """
    REQUIRES='requires'
    PROVIDES='provides'
    BOTH='both'


class initiativeType38(str, Enum):
    """initiativeType38 -- If this element is present, the type of access is restricted to the specified value.
    
    """
    REQUIRES='requires'
    PROVIDES='provides'
    BOTH='both'


class initiativeType40(str, Enum):
    """initiativeType40 -- If this element is present, the type of access is restricted to the specified value.
    
    """
    REQUIRES='requires'
    PROVIDES='provides'
    BOTH='both'


class initiativeType42(str, Enum):
    """initiativeType42 -- If this element is present, the type of access is restricted to the specified value.
    
    """
    REQUIRES='requires'
    PROVIDES='provides'
    BOTH='both'


class initiativeType_impl(str, Enum):
    REQUIRES='requires'
    PROVIDES='provides'
    BOTH='both'
    PHANTOM='phantom'


class interfaceModeType(str, Enum):
    MASTER='master'
    SLAVE='slave'
    SYSTEM='system'
    MIRRORED_MASTER='mirroredMaster'
    MIRRORED_SLAVE='mirroredSlave'
    MIRRORED_SYSTEM='mirroredSystem'


class interfaceModeType31(str, Enum):
    MASTER='master'
    SLAVE='slave'
    SYSTEM='system'
    MIRRORED_MASTER='mirroredMaster'
    MIRRORED_SLAVE='mirroredSlave'
    MIRRORED_SYSTEM='mirroredSystem'


class ipxactFileTypesEnum(str, Enum):
    BUS_DEFINITION='busDefinition'
    ABSTRACTION_DEFINITION='abstractionDefinition'
    COMPONENT='component'
    ABSTRACTOR='abstractor'
    DESIGN='design'
    DESIGN_CONFIG='designConfig'
    GENERATOR_CHAIN='generatorChain'
    CATALOG='catalog'


class kindType(str, Enum):
    TLM_PORT='tlm_port'
    TLM_SOCKET='tlm_socket'
    SIMPLE_SOCKET='simple_socket'
    MULTI_SOCKET='multi_socket'
    CUSTOM='custom'


class modelInstantiationType(str, Enum):
    MODULE='module'
    ENTITYARCHITECTURE='entity(architecture)'
    CONFIGURATION='configuration'


class modifiedWriteValueType(str, Enum):
    ONE_TO_CLEAR='oneToClear'
    ONE_TO_SET='oneToSet'
    ONE_TO_TOGGLE='oneToToggle'
    ZERO_TO_CLEAR='zeroToClear'
    ZERO_TO_SET='zeroToSet'
    ZERO_TO_TOGGLE='zeroToToggle'
    CLEAR='clear'
    SET='set'
    MODIFY='modify'


class multipleGroupSelectionOperatorType(str, Enum):
    """multipleGroupSelectionOperatorType -- Specifies the OR or AND selection operator if there is more than one group name.
    
    """
    AND='and'
    OR='or'


class prefixType(str, Enum):
    """prefixType -- Defines the prefix that precedes the unit of a value. The prefix is not applied to the value (e.g. in calculations).
    
    """
    DECA='deca'
    HECTO='hecto'
    KILO='kilo'
    MEGA='mega'
    GIGA='giga'
    TERA='tera'
    PETA='peta'
    EXA='exa'
    ZETTA='zetta'
    YOTTA='yotta'
    DECI='deci'
    CENTI='centi'
    MILLI='milli'
    MICRO='micro'
    NANO='nano'
    PICO='pico'
    FEMTO='femto'
    ATTO='atto'
    ZEPTO='zepto'
    YOCTO='yocto'


class presenceType_impl(str, Enum):
    REQUIRED='required'
    ILLEGAL='illegal'
    OPTIONAL='optional'


class protocolTypeType(str, Enum):
    TLM='tlm'
    CUSTOM='custom'


class readActionType(str, Enum):
    CLEAR='clear'
    SET='set'
    MODIFY='modify'


class resolveType(str, Enum):
    """resolveType -- Determines how a property value can be configured.
    Determines how a parameter is resolved. User means the value must be obtained from the user. Generated means the value will be provided by a generator.
    
    """
    IMMEDIATE='immediate' # Property content cannot be modified through configuration.
    USER='user' # Property content can be modified through configuration. Modifications will be saved with the design.
    GENERATED='generated' # Generators may modify this property. Modifications get saved with the design.


class returnTypeType(str, Enum):
    VOID='void'
    INT='int'


class scopeType(str, Enum):
    """scopeType -- The scope attribute applies to component generators and specifies whether the generator should be run for each instance of the entity (or module) or just once for all instances of the entity.
    
    """
    INSTANCE='instance'
    ENTITY='entity'


class sharedType(str, Enum):
    """sharedType -- The sharedness of the memoryMap content.
    
    """
    YES='yes'
    NO='no'
    UNDEFINED='undefined'


class signType(str, Enum):
    """signType -- This is an indication of the signedness of the value.
    
    """
    SIGNED='signed'
    UNSIGNED='unsigned'


class simpleBitSteeringExpression(str, Enum):
    """simpleBitSteeringExpression -- Indicates whether bit steering should be used to map this interface onto a bus of different data width.
    Values are "on", "off" (defaults to "off").
    
    """
    ON='on'
    OFF='off'


class simpleFileType(str, Enum):
    UNKNOWN='unknown'
    C_SOURCE='cSource'
    CPP_SOURCE='cppSource'
    ASM_SOURCE='asmSource'
    VHDL_SOURCE='vhdlSource'
    VHDL_SOURCE_87='vhdlSource-87'
    VHDL_SOURCE_93='vhdlSource-93'
    VERILOG_SOURCE='verilogSource'
    VERILOG_SOURCE_95='verilogSource-95'
    VERILOG_SOURCE_2001='verilogSource-2001'
    SW_OBJECT='swObject'
    SW_OBJECT_LIBRARY='swObjectLibrary'
    VHDL_BINARY_LIBRARY='vhdlBinaryLibrary'
    VERILOG_BINARY_LIBRARY='verilogBinaryLibrary'
    UNELABORATED_HDL='unelaboratedHdl'
    EXECUTABLE_HDL='executableHdl'
    SYSTEM_VERILOG_SOURCE='systemVerilogSource'
    SYSTEM_VERILOG_SOURCE_3_0='systemVerilogSource-3.0'
    SYSTEM_VERILOG_SOURCE_3_1='systemVerilogSource-3.1'
    SYSTEM_C_SOURCE='systemCSource'
    SYSTEM_C_SOURCE_2_0='systemCSource-2.0'
    SYSTEM_C_SOURCE_2_0_1='systemCSource-2.0.1'
    SYSTEM_C_SOURCE_2_1='systemCSource-2.1'
    SYSTEM_C_SOURCE_2_2='systemCSource-2.2'
    VERA_SOURCE='veraSource'
    E_SOURCE='eSource'
    PERL_SOURCE='perlSource'
    TCL_SOURCE='tclSource'
    OVA_SOURCE='OVASource'
    SVA_SOURCE='SVASource'
    PSL_SOURCE='pslSource'
    SYSTEM_VERILOG_SOURCE_3_1_A='systemVerilogSource-3.1a'
    SDC='SDC'
    VHDL_AMS_SOURCE='vhdlAmsSource'
    VERILOG_AMS_SOURCE='verilogAmsSource'
    SYSTEM_C_AMS_SOURCE='systemCAmsSource'
    LIBERTY_SOURCE='libertySource'
    USER='user'


class simplePortAccessType_impl(str, Enum):
    REF='ref'
    PTR='ptr'


class simpleTiedValueType(str, Enum):
    OPEN='open'
    DEFAULT='default'


class simpleWhiteboxType(str, Enum):
    SIGNAL='signal'
    PIN='pin'
    INTERFACE='interface'


class testConstraintType(str, Enum):
    """testConstraintType -- Constraint for an automated register test routine. 'unconstrained' (default) means may read and write all legal values. 'restore' means may read and write legal values but the value must be restored to the initially read value before accessing another register. 'writeAsRead' has limitations on testability where only the value read before a write may be written to the field. 'readOnly' has limitations on testability where values may only be read from the field.
    
    """
    UNCONSTRAINED='unconstrained'
    RESTORE='restore'
    WRITE_AS_READ='writeAsRead'
    READ_ONLY='readOnly'


class testConstraintType63(str, Enum):
    """testConstraintType63 -- Constraint for an automated register test routine. 'unconstrained' (default) means may read and write all legal values. 'restore' means may read and write legal values but the value must be restored to the initially read value before accessing another register. 'writeAsRead' has limitations on testability where only the value read before a write may be written to the field. 'readOnly' has limitations on testability where values may only be read from the field.
    
    """
    UNCONSTRAINED='unconstrained'
    RESTORE='restore'
    WRITE_AS_READ='writeAsRead'
    READ_ONLY='readOnly'


class transportMethodType(str, Enum):
    FILE='file'


class typeType(str, Enum):
    """typeType -- Defines the type of the payload.
    
    """
    GENERIC='generic'
    SPECIFIC='specific'


class unitType(str, Enum):
    """unitType -- Defines the unit of the value.
    
    """
    SECOND='second'
    AMPERE='ampere'
    KELVIN='kelvin'
    HERTZ='hertz'
    JOULE='joule'
    WATT='watt'
    COULOMB='coulomb'
    VOLT='volt'
    FARAD='farad'
    OHM='ohm'
    SIEMENS='siemens'
    HENRY='henry'
    CELSIUS='Celsius'


class usageType(str, Enum):
    """usageType -- Describes the usage of an address block.
    
    """
    MEMORY='memory' # Denotes an address range that can be used for read-write or read-only data storage.
    REGISTER='register' # Denotes an address block that is used to communicate with hardware.
    RESERVED='reserved' # Denotes an address range that must remain unoccupied.


class usageType55(str, Enum):
    """usageType55 -- Usage for the enumeration. 'read' for a software read access. 'write' for a software write access. 'read-write' for a software read or write access.
    
    """
    READ='read'
    WRITE='write'
    READWRITE='read-write'


class usageTypeType(str, Enum):
    """usageTypeType -- Indicates the type of the module parameter. Legal values are defined in the attribute enumeration list. Default value is 'nontyped'.
    
    """
    NONTYPED='nontyped'
    TYPED='typed'


class busDefinition(GeneratedsSuper):
    """vendor -- Name of the vendor who supplies this file.
    library -- Name of the logical library this element belongs to.
    name -- The name of the object.
    version -- Indicates the version of the named element.
    directConnection -- This element indicates that a master interface may be directly connected to a slave interface (under certain conditions) for busses of this type.
    broadcast -- This element indicates that this bus definition supports 'broadcast' mode. This means that it is legal to make one-to-many interface connections.
    isAddressable -- If true, indicates that this is an addressable bus.
    extends -- Optional name of bus type that this bus definition is compatible with. This bus definition may change the definitions in the existing bus definition
    maxMasters -- Indicates the maximum number of masters this bus supports.  If this element is not present, the number of masters allowed is unbounded.
    maxSlaves -- Indicates the maximum number of slaves this bus supports.  If the element is not present, the number of slaves allowed is unbounded.
    systemGroupNames -- Indicates the list of system group names that are defined for this bus definition.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'name': 'vendor', 'type': 'xs:Name'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'name': 'library', 'type': 'xs:Name'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'name': 'version', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('directConnection', 'xs:boolean', 0, 0, {'name': 'directConnection', 'type': 'xs:boolean'}, None),
        MemberSpec_('broadcast', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'broadcast', 'type': 'xs:boolean'}, None),
        MemberSpec_('isAddressable', 'xs:boolean', 0, 0, {'name': 'isAddressable', 'type': 'xs:boolean'}, None),
        MemberSpec_('extends', 'libraryRefType', 0, 1, {'minOccurs': '0', 'name': 'extends', 'type': 'libraryRefType'}, None),
        MemberSpec_('maxMasters', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'name': 'maxMasters', 'type': 'unsignedIntExpression'}, None),
        MemberSpec_('maxSlaves', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'name': 'maxSlaves', 'type': 'unsignedIntExpression'}, None),
        MemberSpec_('systemGroupNames', 'systemGroupNamesType', 0, 1, {'minOccurs': '0', 'name': 'systemGroupNames', 'type': 'systemGroupNamesType'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'name': 'assertions', 'ref': 'assertions', 'type': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, directConnection=None, broadcast=None, isAddressable=None, extends=None, maxMasters=None, maxSlaves=None, systemGroupNames=None, description=None, parameters=None, assertions=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.vendor = vendor
        self.vendor_nsprefix_ = "ipxact"
        self.library = library
        self.library_nsprefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.version = version
        self.version_nsprefix_ = "ipxact"
        self.directConnection = directConnection
        self.directConnection_nsprefix_ = "ipxact"
        self.broadcast = broadcast
        self.broadcast_nsprefix_ = "ipxact"
        self.isAddressable = isAddressable
        self.isAddressable_nsprefix_ = "ipxact"
        self.extends = extends
        self.extends_nsprefix_ = "ipxact"
        self.maxMasters = maxMasters
        self.maxMasters_nsprefix_ = "ipxact"
        self.maxSlaves = maxSlaves
        self.maxSlaves_nsprefix_ = "ipxact"
        self.systemGroupNames = systemGroupNames
        self.systemGroupNames_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.assertions = assertions
        self.assertions_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, busDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if busDefinition.subclass:
            return busDefinition.subclass(*args_, **kwargs_)
        else:
            return busDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_directConnection(self):
        return self.directConnection
    def set_directConnection(self, directConnection):
        self.directConnection = directConnection
    def get_broadcast(self):
        return self.broadcast
    def set_broadcast(self, broadcast):
        self.broadcast = broadcast
    def get_isAddressable(self):
        return self.isAddressable
    def set_isAddressable(self, isAddressable):
        self.isAddressable = isAddressable
    def get_extends(self):
        return self.extends
    def set_extends(self, extends):
        self.extends = extends
    def get_maxMasters(self):
        return self.maxMasters
    def set_maxMasters(self, maxMasters):
        self.maxMasters = maxMasters
    def get_maxSlaves(self):
        return self.maxSlaves
    def set_maxSlaves(self, maxSlaves):
        self.maxSlaves = maxSlaves
    def get_systemGroupNames(self):
        return self.systemGroupNames
    def set_systemGroupNames(self, systemGroupNames):
        self.systemGroupNames = systemGroupNames
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_assertions(self):
        return self.assertions
    def set_assertions(self, assertions):
        self.assertions = assertions
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.directConnection is not None or
            self.broadcast is not None or
            self.isAddressable is not None or
            self.extends is not None or
            self.maxMasters is not None or
            self.maxSlaves is not None or
            self.systemGroupNames is not None or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='busDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('busDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'busDefinition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='busDefinition')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='busDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='busDefinition'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='busDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            namespaceprefix_ = self.vendor_nsprefix_ + ':' if (UseCapturedNS_ and self.vendor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), namespaceprefix_ , eol_))
        if self.library is not None:
            namespaceprefix_ = self.library_nsprefix_ + ':' if (UseCapturedNS_ and self.library_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slibrary>%s</%slibrary>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespaceprefix_ , eol_))
        if self.directConnection is not None:
            namespaceprefix_ = self.directConnection_nsprefix_ + ':' if (UseCapturedNS_ and self.directConnection_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirectConnection>%s</%sdirectConnection>%s' % (namespaceprefix_ , self.gds_format_boolean(self.directConnection, input_name='directConnection'), namespaceprefix_ , eol_))
        if self.broadcast is not None:
            namespaceprefix_ = self.broadcast_nsprefix_ + ':' if (UseCapturedNS_ and self.broadcast_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbroadcast>%s</%sbroadcast>%s' % (namespaceprefix_ , self.gds_format_boolean(self.broadcast, input_name='broadcast'), namespaceprefix_ , eol_))
        if self.isAddressable is not None:
            namespaceprefix_ = self.isAddressable_nsprefix_ + ':' if (UseCapturedNS_ and self.isAddressable_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisAddressable>%s</%sisAddressable>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isAddressable, input_name='isAddressable'), namespaceprefix_ , eol_))
        if self.extends is not None:
            namespaceprefix_ = self.extends_nsprefix_ + ':' if (UseCapturedNS_ and self.extends_nsprefix_) else ''
            self.extends.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extends', pretty_print=pretty_print)
        if self.maxMasters is not None:
            namespaceprefix_ = self.maxMasters_nsprefix_ + ':' if (UseCapturedNS_ and self.maxMasters_nsprefix_) else ''
            self.maxMasters.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maxMasters', pretty_print=pretty_print)
        if self.maxSlaves is not None:
            namespaceprefix_ = self.maxSlaves_nsprefix_ + ':' if (UseCapturedNS_ and self.maxSlaves_nsprefix_) else ''
            self.maxSlaves.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maxSlaves', pretty_print=pretty_print)
        if self.systemGroupNames is not None:
            namespaceprefix_ = self.systemGroupNames_nsprefix_ + ':' if (UseCapturedNS_ and self.systemGroupNames_nsprefix_) else ''
            self.systemGroupNames.export(outfile, level, namespaceprefix_, namespacedef_='', name_='systemGroupNames', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            namespaceprefix_ = self.assertions_nsprefix_ + ':' if (UseCapturedNS_ and self.assertions_nsprefix_) else ''
            self.assertions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vendor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vendor')
            value_ = self.gds_validate_string(value_, node, 'vendor')
            self.vendor = value_
            self.vendor_nsprefix_ = child_.prefix
        elif nodeName_ == 'library':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'library')
            value_ = self.gds_validate_string(value_, node, 'library')
            self.library = value_
            self.library_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'version')
            value_ = self.gds_validate_string(value_, node, 'version')
            self.version = value_
            self.version_nsprefix_ = child_.prefix
        elif nodeName_ == 'directConnection':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'directConnection')
            ival_ = self.gds_validate_boolean(ival_, node, 'directConnection')
            self.directConnection = ival_
            self.directConnection_nsprefix_ = child_.prefix
        elif nodeName_ == 'broadcast':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'broadcast')
            ival_ = self.gds_validate_boolean(ival_, node, 'broadcast')
            self.broadcast = ival_
            self.broadcast_nsprefix_ = child_.prefix
        elif nodeName_ == 'isAddressable':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isAddressable')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAddressable')
            self.isAddressable = ival_
            self.isAddressable_nsprefix_ = child_.prefix
        elif nodeName_ == 'extends':
            obj_ = LibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extends = obj_
            obj_.original_tagname_ = 'extends'
        elif nodeName_ == 'maxMasters':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maxMasters = obj_
            obj_.original_tagname_ = 'maxMasters'
        elif nodeName_ == 'maxSlaves':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maxSlaves = obj_
            obj_.original_tagname_ = 'maxSlaves'
        elif nodeName_ == 'systemGroupNames':
            obj_ = systemGroupNamesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.systemGroupNames = obj_
            obj_.original_tagname_ = 'systemGroupNames'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class busDefinition


class LibraryRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'use': 'required', 'name': 'vendor'}),
        MemberSpec_('library', 'xs:Name', 0, 0, {'use': 'required', 'name': 'library'}),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'use': 'required', 'name': 'name'}),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'use': 'required', 'name': 'version'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, vendor=None, library=None, name=None, version=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.vendor = _cast(None, vendor)
        self.vendor_nsprefix_ = None
        self.library = _cast(None, library)
        self.library_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LibraryRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LibraryRef.subclass:
            return LibraryRef.subclass(*args_, **kwargs_)
        else:
            return LibraryRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='libraryRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('libraryRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'libraryRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='libraryRefType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='libraryRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='libraryRefType'):
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vendor), input_name='vendor')), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.add('library')
            outfile.write(' library=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.library), input_name='library')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='libraryRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.add('library')
            self.library = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LibraryRef


class ConfigurableLibraryRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'use': 'required', 'name': 'vendor'}),
        MemberSpec_('library', 'xs:Name', 0, 0, {'use': 'required', 'name': 'library'}),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'use': 'required', 'name': 'name'}),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'use': 'required', 'name': 'version'}),
        MemberSpec_('configurableElementValues', 'configurableElementValues', 0, 1, {'minOccurs': '0', 'name': 'configurableElementValues', 'ref': 'configurableElementValues', 'type': 'configurableElementValues'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, vendor=None, library=None, name=None, version=None, configurableElementValues=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.vendor = _cast(None, vendor)
        self.vendor_nsprefix_ = None
        self.library = _cast(None, library)
        self.library_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.version = _cast(None, version)
        self.version_nsprefix_ = None
        self.configurableElementValues = configurableElementValues
        self.configurableElementValues_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConfigurableLibraryRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConfigurableLibraryRef.subclass:
            return ConfigurableLibraryRef.subclass(*args_, **kwargs_)
        else:
            return ConfigurableLibraryRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_configurableElementValues(self):
        return self.configurableElementValues
    def set_configurableElementValues(self, configurableElementValues):
        self.configurableElementValues = configurableElementValues
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def _hasContent(self):
        if (
            self.configurableElementValues is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='configurableLibraryRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('configurableLibraryRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'configurableLibraryRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='configurableLibraryRefType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='configurableLibraryRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='configurableLibraryRefType'):
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vendor), input_name='vendor')), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.add('library')
            outfile.write(' library=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.library), input_name='library')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='configurableLibraryRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.configurableElementValues is not None:
            namespaceprefix_ = self.configurableElementValues_nsprefix_ + ':' if (UseCapturedNS_ and self.configurableElementValues_nsprefix_) else ''
            self.configurableElementValues.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='configurableElementValues', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.add('library')
            self.library = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'configurableElementValues':
            obj_ = configurableElementValues.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.configurableElementValues = obj_
            obj_.original_tagname_ = 'configurableElementValues'
# end class ConfigurableLibraryRef


class complexBaseExpression(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', ['simpleBaseExpression', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complexBaseExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complexBaseExpression.subclass:
            return complexBaseExpression.subclass(*args_, **kwargs_)
        else:
            return complexBaseExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_simpleBaseExpression(self, value):
        result = True
        # Validate type simpleBaseExpression, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on simpleBaseExpression' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='complexBaseExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complexBaseExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'complexBaseExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='complexBaseExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='complexBaseExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='complexBaseExpression'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='complexBaseExpression', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class complexBaseExpression


class choices(GeneratedsSuper):
    """choice -- Non-empty set of legal values for a elements with an attribute ipxact:choiceRef.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('choice', 'choiceType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'choice', 'type': 'choiceType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, choice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if choice is None:
            self.choice = []
        else:
            self.choice = choice
        self.choice_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, choices)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if choices.subclass:
            return choices.subclass(*args_, **kwargs_)
        else:
            return choices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_choice(self):
        return self.choice
    def set_choice(self, choice):
        self.choice = choice
    def add_choice(self, value):
        self.choice.append(value)
    def insert_choice_at(self, index, value):
        self.choice.insert(index, value)
    def replace_choice_at(self, index, value):
        self.choice[index] = value
    def _hasContent(self):
        if (
            self.choice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='choices', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('choices')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'choices':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='choices')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='choices', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='choices'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='choices', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for choice_ in self.choice:
            namespaceprefix_ = self.choice_nsprefix_ + ':' if (UseCapturedNS_ and self.choice_nsprefix_) else ''
            choice_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='choice', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'choice':
            obj_ = choiceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.choice.append(obj_)
            obj_.original_tagname_ = 'choice'
# end class choices


class complexTiedValueType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'minimum'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'maximum'}),
        MemberSpec_('valueOf_', ['simpleTiedValueType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, minimum=None, maximum=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.minimum = _cast(int, minimum)
        self.minimum_nsprefix_ = None
        self.maximum = _cast(int, maximum)
        self.maximum_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complexTiedValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complexTiedValueType.subclass:
            return complexTiedValueType.subclass(*args_, **kwargs_)
        else:
            return complexTiedValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_simpleTiedValueType(self, value):
        result = True
        # Validate type simpleTiedValueType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='complexTiedValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complexTiedValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'complexTiedValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='complexTiedValueType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='complexTiedValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='complexTiedValueType'):
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='complexTiedValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            self.minimum = self.gds_parse_integer(value, node, 'minimum')
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            self.maximum = self.gds_parse_integer(value, node, 'maximum')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class complexTiedValueType


class configurableElementValues(GeneratedsSuper):
    """configurableElementValue -- Describes the content of a configurable element. The required referenceId attribute refers to the ID attribute of the configurable element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('configurableElementValue', 'configurableElementValue', 1, 0, {'maxOccurs': 'unbounded', 'name': 'configurableElementValue', 'ref': 'configurableElementValue', 'type': 'configurableElementValue'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, configurableElementValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if configurableElementValue is None:
            self.configurableElementValue = []
        else:
            self.configurableElementValue = configurableElementValue
        self.configurableElementValue_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, configurableElementValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if configurableElementValues.subclass:
            return configurableElementValues.subclass(*args_, **kwargs_)
        else:
            return configurableElementValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_configurableElementValue(self):
        return self.configurableElementValue
    def set_configurableElementValue(self, configurableElementValue):
        self.configurableElementValue = configurableElementValue
    def add_configurableElementValue(self, value):
        self.configurableElementValue.append(value)
    def insert_configurableElementValue_at(self, index, value):
        self.configurableElementValue.insert(index, value)
    def replace_configurableElementValue_at(self, index, value):
        self.configurableElementValue[index] = value
    def _hasContent(self):
        if (
            self.configurableElementValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='configurableElementValues', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('configurableElementValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'configurableElementValues':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='configurableElementValues')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='configurableElementValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='configurableElementValues'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='configurableElementValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for configurableElementValue_ in self.configurableElementValue:
            namespaceprefix_ = self.configurableElementValue_nsprefix_ + ':' if (UseCapturedNS_ and self.configurableElementValue_nsprefix_) else ''
            configurableElementValue_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='configurableElementValue', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'configurableElementValue':
            obj_ = configurableElementValue.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.configurableElementValue.append(obj_)
            obj_.original_tagname_ = 'configurableElementValue'
# end class configurableElementValues


class configurableElementValue(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('referenceId', 'xs:Name', 0, 0, {'use': 'required', 'name': 'referenceId'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, referenceId=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("configurableElementValue"), self).__init__(valueOf_,  **kwargs_)
        self.referenceId = _cast(None, referenceId)
        self.referenceId_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, configurableElementValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if configurableElementValue.subclass:
            return configurableElementValue.subclass(*args_, **kwargs_)
        else:
            return configurableElementValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_referenceId(self):
        return self.referenceId
    def set_referenceId(self, referenceId):
        self.referenceId = referenceId
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(configurableElementValue, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='configurableElementValue', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('configurableElementValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'configurableElementValue':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='configurableElementValue')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='configurableElementValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='configurableElementValue'):
        super(configurableElementValue, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='configurableElementValue')
        if self.referenceId is not None and 'referenceId' not in already_processed:
            already_processed.add('referenceId')
            outfile.write(' referenceId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.referenceId), input_name='referenceId')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='configurableElementValue', fromsubclass_=False, pretty_print=True):
        super(configurableElementValue, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceId', node)
        if value is not None and 'referenceId' not in already_processed:
            already_processed.add('referenceId')
            self.referenceId = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(configurableElementValue, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class configurableElementValue


class componentInstance(GeneratedsSuper):
    """componentRef -- References a component to be found in an external library.  The four attributes define the VLNV of the referenced element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('instanceName', 'xs:Name', 0, 0, {'name': 'instanceName', 'ref': 'instanceName', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('componentRef', 'configurableLibraryRefType', 0, 0, {'name': 'componentRef', 'type': 'configurableLibraryRefType'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, instanceName=None, displayName=None, description=None, isPresent=None, componentRef=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.instanceName = instanceName
        self.instanceName_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.componentRef = componentRef
        self.componentRef_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentInstance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentInstance.subclass:
            return componentInstance.subclass(*args_, **kwargs_)
        else:
            return componentInstance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_instanceName(self):
        return self.instanceName
    def set_instanceName(self, instanceName):
        self.instanceName = instanceName
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_componentRef(self):
        return self.componentRef
    def set_componentRef(self, componentRef):
        self.componentRef = componentRef
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.instanceName is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.componentRef is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='componentInstance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentInstance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'componentInstance':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='componentInstance')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='componentInstance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='componentInstance'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='componentInstance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.instanceName is not None:
            namespaceprefix_ = self.instanceName_nsprefix_ + ':' if (UseCapturedNS_ and self.instanceName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstanceName>%s</%sinstanceName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.instanceName), input_name='instanceName')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.componentRef is not None:
            namespaceprefix_ = self.componentRef_nsprefix_ + ':' if (UseCapturedNS_ and self.componentRef_nsprefix_) else ''
            self.componentRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='componentRef', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'instanceName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'instanceName')
            value_ = self.gds_validate_string(value_, node, 'instanceName')
            self.instanceName = value_
            self.instanceName_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'componentRef':
            obj_ = ConfigurableLibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.componentRef = obj_
            obj_.original_tagname_ = 'componentRef'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class componentInstance


class componentInstances(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('componentInstance', 'componentInstance', 1, 0, {'maxOccurs': 'unbounded', 'name': 'componentInstance', 'ref': 'componentInstance', 'type': 'componentInstance'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentInstance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if componentInstance is None:
            self.componentInstance = []
        else:
            self.componentInstance = componentInstance
        self.componentInstance_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentInstances)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentInstances.subclass:
            return componentInstances.subclass(*args_, **kwargs_)
        else:
            return componentInstances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_componentInstance(self):
        return self.componentInstance
    def set_componentInstance(self, componentInstance):
        self.componentInstance = componentInstance
    def add_componentInstance(self, value):
        self.componentInstance.append(value)
    def insert_componentInstance_at(self, index, value):
        self.componentInstance.insert(index, value)
    def replace_componentInstance_at(self, index, value):
        self.componentInstance[index] = value
    def _hasContent(self):
        if (
            self.componentInstance
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='componentInstances', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentInstances')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'componentInstances':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='componentInstances')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='componentInstances', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='componentInstances'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='componentInstances', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for componentInstance_ in self.componentInstance:
            namespaceprefix_ = self.componentInstance_nsprefix_ + ':' if (UseCapturedNS_ and self.componentInstance_nsprefix_) else ''
            componentInstance_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='componentInstance', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'componentInstance':
            obj_ = componentInstance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.componentInstance.append(obj_)
            obj_.original_tagname_ = 'componentInstance'
# end class componentInstances


class adHocConnection(GeneratedsSuper):
    """name -- Unique name
    tiedValue -- The logic value of this connection. The value can be an unsigned longint expression or open or default. Only valid for ports of style wire.
    portReferences -- Liist of internal and external port references involved in the adhocConnection
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', ['portName', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('tiedValue', 'complexTiedValueType', 0, 1, {'minOccurs': '0', 'name': 'tiedValue', 'type': 'complexTiedValueType'}, None),
        MemberSpec_('portReferences', 'portReferencesType', 0, 0, {'name': 'portReferences', 'type': 'portReferencesType'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, tiedValue=None, portReferences=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.validate_portName(self.name)
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.tiedValue = tiedValue
        self.tiedValue_nsprefix_ = "ipxact"
        self.portReferences = portReferences
        self.portReferences_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adHocConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adHocConnection.subclass:
            return adHocConnection.subclass(*args_, **kwargs_)
        else:
            return adHocConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_tiedValue(self):
        return self.tiedValue
    def set_tiedValue(self, tiedValue):
        self.tiedValue = tiedValue
    def get_portReferences(self):
        return self.portReferences
    def set_portReferences(self, portReferences):
        self.portReferences = portReferences
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_portName(self, value):
        result = True
        # Validate type portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_portName_patterns_, ))
                result = False
        return result
    validate_portName_patterns_ = [['^([A-Za-z0-9\\.\\-:_]*)$']]
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.tiedValue is not None or
            self.portReferences is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='adHocConnection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adHocConnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adHocConnection':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adHocConnection')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='adHocConnection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='adHocConnection'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='adHocConnection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.tiedValue is not None:
            namespaceprefix_ = self.tiedValue_nsprefix_ + ':' if (UseCapturedNS_ and self.tiedValue_nsprefix_) else ''
            self.tiedValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tiedValue', pretty_print=pretty_print)
        if self.portReferences is not None:
            namespaceprefix_ = self.portReferences_nsprefix_ + ':' if (UseCapturedNS_ and self.portReferences_nsprefix_) else ''
            self.portReferences.export(outfile, level, namespaceprefix_, namespacedef_='', name_='portReferences', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type portName
            self.validate_portName(self.name)
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'tiedValue':
            obj_ = complexTiedValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tiedValue = obj_
            obj_.original_tagname_ = 'tiedValue'
        elif nodeName_ == 'portReferences':
            obj_ = portReferencesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.portReferences = obj_
            obj_.original_tagname_ = 'portReferences'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class adHocConnection


class adHocConnections(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('adHocConnection', 'adHocConnection', 1, 0, {'maxOccurs': 'unbounded', 'name': 'adHocConnection', 'ref': 'adHocConnection', 'type': 'adHocConnection'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, adHocConnection=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if adHocConnection is None:
            self.adHocConnection = []
        else:
            self.adHocConnection = adHocConnection
        self.adHocConnection_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adHocConnections)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adHocConnections.subclass:
            return adHocConnections.subclass(*args_, **kwargs_)
        else:
            return adHocConnections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_adHocConnection(self):
        return self.adHocConnection
    def set_adHocConnection(self, adHocConnection):
        self.adHocConnection = adHocConnection
    def add_adHocConnection(self, value):
        self.adHocConnection.append(value)
    def insert_adHocConnection_at(self, index, value):
        self.adHocConnection.insert(index, value)
    def replace_adHocConnection_at(self, index, value):
        self.adHocConnection[index] = value
    def _hasContent(self):
        if (
            self.adHocConnection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='adHocConnections', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adHocConnections')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'adHocConnections':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adHocConnections')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='adHocConnections', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='adHocConnections'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='adHocConnections', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for adHocConnection_ in self.adHocConnection:
            namespaceprefix_ = self.adHocConnection_nsprefix_ + ':' if (UseCapturedNS_ and self.adHocConnection_nsprefix_) else ''
            adHocConnection_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='adHocConnection', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'adHocConnection':
            obj_ = adHocConnection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.adHocConnection.append(obj_)
            obj_.original_tagname_ = 'adHocConnection'
# end class adHocConnections


class interconnection(GeneratedsSuper):
    """name -- Unique name
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('activeInterface', 'activeInterface', 1, 0, {'maxOccurs': 'unbounded', 'name': 'activeInterface', 'ref': 'activeInterface', 'type': 'activeInterface'}, 3),
        MemberSpec_('hierInterface', 'hierInterface', 1, 0, {'maxOccurs': 'unbounded', 'name': 'hierInterface', 'type': 'hierInterfaceType'}, 3),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, activeInterface=None, hierInterface=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        if activeInterface is None:
            self.activeInterface = []
        else:
            self.activeInterface = activeInterface
        self.activeInterface_nsprefix_ = "ipxact"
        if hierInterface is None:
            self.hierInterface = []
        else:
            self.hierInterface = hierInterface
        self.hierInterface_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interconnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interconnection.subclass:
            return interconnection.subclass(*args_, **kwargs_)
        else:
            return interconnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_activeInterface(self):
        return self.activeInterface
    def set_activeInterface(self, activeInterface):
        self.activeInterface = activeInterface
    def add_activeInterface(self, value):
        self.activeInterface.append(value)
    def insert_activeInterface_at(self, index, value):
        self.activeInterface.insert(index, value)
    def replace_activeInterface_at(self, index, value):
        self.activeInterface[index] = value
    def get_hierInterface(self):
        return self.hierInterface
    def set_hierInterface(self, hierInterface):
        self.hierInterface = hierInterface
    def add_hierInterface(self, value):
        self.hierInterface.append(value)
    def insert_hierInterface_at(self, index, value):
        self.hierInterface.insert(index, value)
    def replace_hierInterface_at(self, index, value):
        self.hierInterface[index] = value
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.activeInterface or
            self.hierInterface or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='interconnection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('interconnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'interconnection':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='interconnection')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='interconnection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='interconnection'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='interconnection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for activeInterface_ in self.activeInterface:
            namespaceprefix_ = self.activeInterface_nsprefix_ + ':' if (UseCapturedNS_ and self.activeInterface_nsprefix_) else ''
            activeInterface_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='activeInterface', pretty_print=pretty_print)
        for hierInterface_ in self.hierInterface:
            namespaceprefix_ = self.hierInterface_nsprefix_ + ':' if (UseCapturedNS_ and self.hierInterface_nsprefix_) else ''
            hierInterface_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='hierInterface', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'activeInterface':
            obj_ = activeInterface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activeInterface.append(obj_)
            obj_.original_tagname_ = 'activeInterface'
        elif nodeName_ == 'hierInterface':
            obj_ = hierInterfaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.hierInterface.append(obj_)
            obj_.original_tagname_ = 'hierInterface'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class interconnection


class monitorInterconnection(GeneratedsSuper):
    """name -- Unique name
    monitoredActiveInterface -- Describes an active interface of the design that all the monitors will be connected to.
    The componentRef and busRef attributes indicate the instance name and bus interface name. The optional path attribute indicates the hierarchical instance name path to the component.
    monitorInterface -- Describes a list of monitor interfaces that are connected to the single active interface.
    The componentRef and busRef attributes indicate the instance name and bus interface name. The optional path attribute indicates the hierarchical instance name path to the component.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('monitoredActiveInterface', 'monitorInterfaceType', 0, 0, {'name': 'monitoredActiveInterface', 'type': 'monitorInterfaceType'}, None),
        MemberSpec_('monitorInterface', 'monitorInterfaceType1', 1, 0, {'maxOccurs': 'unbounded', 'name': 'monitorInterface', 'type': 'monitorInterfaceType1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, isPresent=None, monitoredActiveInterface=None, monitorInterface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.monitoredActiveInterface = monitoredActiveInterface
        self.monitoredActiveInterface_nsprefix_ = "ipxact"
        if monitorInterface is None:
            self.monitorInterface = []
        else:
            self.monitorInterface = monitorInterface
        self.monitorInterface_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monitorInterconnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monitorInterconnection.subclass:
            return monitorInterconnection.subclass(*args_, **kwargs_)
        else:
            return monitorInterconnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_monitoredActiveInterface(self):
        return self.monitoredActiveInterface
    def set_monitoredActiveInterface(self, monitoredActiveInterface):
        self.monitoredActiveInterface = monitoredActiveInterface
    def get_monitorInterface(self):
        return self.monitorInterface
    def set_monitorInterface(self, monitorInterface):
        self.monitorInterface = monitorInterface
    def add_monitorInterface(self, value):
        self.monitorInterface.append(value)
    def insert_monitorInterface_at(self, index, value):
        self.monitorInterface.insert(index, value)
    def replace_monitorInterface_at(self, index, value):
        self.monitorInterface[index] = value
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.monitoredActiveInterface is not None or
            self.monitorInterface
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='monitorInterconnection', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monitorInterconnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'monitorInterconnection':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='monitorInterconnection')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='monitorInterconnection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='monitorInterconnection'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='monitorInterconnection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.monitoredActiveInterface is not None:
            namespaceprefix_ = self.monitoredActiveInterface_nsprefix_ + ':' if (UseCapturedNS_ and self.monitoredActiveInterface_nsprefix_) else ''
            self.monitoredActiveInterface.export(outfile, level, namespaceprefix_, namespacedef_='', name_='monitoredActiveInterface', pretty_print=pretty_print)
        for monitorInterface_ in self.monitorInterface:
            namespaceprefix_ = self.monitorInterface_nsprefix_ + ':' if (UseCapturedNS_ and self.monitorInterface_nsprefix_) else ''
            monitorInterface_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='monitorInterface', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'monitoredActiveInterface':
            class_obj_ = self.get_class_obj_(child_, monitorInterfaceType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.monitoredActiveInterface = obj_
            obj_.original_tagname_ = 'monitoredActiveInterface'
        elif nodeName_ == 'monitorInterface':
            obj_ = monitorInterfaceType1.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.monitorInterface.append(obj_)
            obj_.original_tagname_ = 'monitorInterface'
# end class monitorInterconnection


class interconnections(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('interconnection', 'interconnection', 1, 1, {'name': 'interconnection', 'ref': 'interconnection', 'type': 'interconnection'}, 4),
        MemberSpec_('monitorInterconnection', 'monitorInterconnection', 1, 1, {'name': 'monitorInterconnection', 'ref': 'monitorInterconnection', 'type': 'monitorInterconnection'}, 4),
    ]
    subclass = None
    superclass = None
    def __init__(self, interconnection=None, monitorInterconnection=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if interconnection is None:
            self.interconnection = []
        else:
            self.interconnection = interconnection
        self.interconnection_nsprefix_ = "ipxact"
        if monitorInterconnection is None:
            self.monitorInterconnection = []
        else:
            self.monitorInterconnection = monitorInterconnection
        self.monitorInterconnection_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interconnections)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interconnections.subclass:
            return interconnections.subclass(*args_, **kwargs_)
        else:
            return interconnections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_interconnection(self):
        return self.interconnection
    def set_interconnection(self, interconnection):
        self.interconnection = interconnection
    def add_interconnection(self, value):
        self.interconnection.append(value)
    def insert_interconnection_at(self, index, value):
        self.interconnection.insert(index, value)
    def replace_interconnection_at(self, index, value):
        self.interconnection[index] = value
    def get_monitorInterconnection(self):
        return self.monitorInterconnection
    def set_monitorInterconnection(self, monitorInterconnection):
        self.monitorInterconnection = monitorInterconnection
    def add_monitorInterconnection(self, value):
        self.monitorInterconnection.append(value)
    def insert_monitorInterconnection_at(self, index, value):
        self.monitorInterconnection.insert(index, value)
    def replace_monitorInterconnection_at(self, index, value):
        self.monitorInterconnection[index] = value
    def _hasContent(self):
        if (
            self.interconnection or
            self.monitorInterconnection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='interconnections', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('interconnections')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'interconnections':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='interconnections')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='interconnections', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='interconnections'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='interconnections', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for interconnection_ in self.interconnection:
            namespaceprefix_ = self.interconnection_nsprefix_ + ':' if (UseCapturedNS_ and self.interconnection_nsprefix_) else ''
            interconnection_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='interconnection', pretty_print=pretty_print)
        for monitorInterconnection_ in self.monitorInterconnection:
            namespaceprefix_ = self.monitorInterconnection_nsprefix_ + ':' if (UseCapturedNS_ and self.monitorInterconnection_nsprefix_) else ''
            monitorInterconnection_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='monitorInterconnection', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'interconnection':
            obj_ = interconnection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interconnection.append(obj_)
            obj_.original_tagname_ = 'interconnection'
        elif nodeName_ == 'monitorInterconnection':
            obj_ = monitorInterconnection.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.monitorInterconnection.append(obj_)
            obj_.original_tagname_ = 'monitorInterconnection'
# end class interconnections


class interfaceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('componentRef', 'xs:Name', 0, 0, {'use': 'required', 'name': 'componentRef'}),
        MemberSpec_('busRef', 'xs:Name', 0, 0, {'use': 'required', 'name': 'busRef'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentRef=None, busRef=None, id=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.componentRef = _cast(None, componentRef)
        self.componentRef_nsprefix_ = None
        self.busRef = _cast(None, busRef)
        self.busRef_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interfaceType.subclass:
            return interfaceType.subclass(*args_, **kwargs_)
        else:
            return interfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_componentRef(self):
        return self.componentRef
    def set_componentRef(self, componentRef):
        self.componentRef = componentRef
    def get_busRef(self):
        return self.busRef
    def set_busRef(self, busRef):
        self.busRef = busRef
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='interfaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('interfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'interfaceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='interfaceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='interfaceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='interfaceType'):
        if self.componentRef is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            outfile.write(' componentRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.componentRef), input_name='componentRef')), ))
        if self.busRef is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            outfile.write(' busRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.busRef), input_name='busRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='interfaceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('componentRef', node)
        if value is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            self.componentRef = value
        value = find_attr_value_('busRef', node)
        if value is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            self.busRef = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class interfaceType


class hierInterfaceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('busRef', 'xs:Name', 0, 0, {'use': 'required', 'name': 'busRef'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, busRef=None, id=None, isPresent=None, description=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.busRef = _cast(None, busRef)
        self.busRef_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hierInterfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hierInterfaceType.subclass:
            return hierInterfaceType.subclass(*args_, **kwargs_)
        else:
            return hierInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_busRef(self):
        return self.busRef
    def set_busRef(self, busRef):
        self.busRef = busRef
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.isPresent is not None or
            self.description is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='hierInterfaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hierInterfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'hierInterfaceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hierInterfaceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='hierInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='hierInterfaceType'):
        if self.busRef is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            outfile.write(' busRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.busRef), input_name='busRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='hierInterfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('busRef', node)
        if value is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            self.busRef = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class hierInterfaceType


class monitorInterfaceType(interfaceType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('path', 'xs:string', 0, 1, {'use': 'optional', 'name': 'path'}),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = interfaceType
    def __init__(self, componentRef=None, busRef=None, id=None, path=None, description=None, vendorExtensions=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("monitorInterfaceType"), self).__init__(componentRef, busRef, id, extensiontype_,  **kwargs_)
        self.path = _cast(None, path)
        self.path_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monitorInterfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monitorInterfaceType.subclass:
            return monitorInterfaceType.subclass(*args_, **kwargs_)
        else:
            return monitorInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_path(self):
        return self.path
    def set_path(self, path):
        self.path = path
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.description is not None or
            self.vendorExtensions is not None or
            super(monitorInterfaceType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='monitorInterfaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monitorInterfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'monitorInterfaceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='monitorInterfaceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='monitorInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='monitorInterfaceType'):
        super(monitorInterfaceType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='monitorInterfaceType')
        if self.path is not None and 'path' not in already_processed:
            already_processed.add('path')
            outfile.write(' path=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.path), input_name='path')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='monitorInterfaceType', fromsubclass_=False, pretty_print=True):
        super(monitorInterfaceType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('path', node)
        if value is not None and 'path' not in already_processed:
            already_processed.add('path')
            self.path = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(monitorInterfaceType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
        super(monitorInterfaceType, self)._buildChildren(child_, node, nodeName_, True)
# end class monitorInterfaceType


class externalPortReference(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('portRef', 'ipxact:portName', 0, 0, {'use': 'required', 'name': 'portRef'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('PartSelect', 'partSelect', 0, 1, {'minOccurs': '0', 'name': 'partSelect', 'ref': 'partSelect', 'type': 'partSelect'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, portRef=None, id=None, isPresent=None, PartSelect=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.portRef = _cast(None, portRef)
        self.portRef_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.PartSelect = PartSelect
        self.PartSelect_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, externalPortReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if externalPortReference.subclass:
            return externalPortReference.subclass(*args_, **kwargs_)
        else:
            return externalPortReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_partSelect(self):
        return self.PartSelect
    def set_partSelect(self, PartSelect):
        self.PartSelect = PartSelect
    def get_portRef(self):
        return self.portRef
    def set_portRef(self, portRef):
        self.portRef = portRef
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_portName(self, value):
        # Validate type ipxact:portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_portName_patterns_, ))
    validate_portName_patterns_ = [['^([A-Za-z0-9\\.\\-:_]*)$']]
    def _hasContent(self):
        if (
            self.isPresent is not None or
            self.PartSelect is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='externalPortReference', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('externalPortReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'externalPortReference':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='externalPortReference')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='externalPortReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='externalPortReference'):
        if self.portRef is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            outfile.write(' portRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.portRef), input_name='portRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='externalPortReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.PartSelect is not None:
            namespaceprefix_ = self.PartSelect_nsprefix_ + ':' if (UseCapturedNS_ and self.PartSelect_nsprefix_) else ''
            self.PartSelect.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='partSelect', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('portRef', node)
        if value is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            self.portRef = value
            self.validate_portName(self.portRef)    # validate type portName
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'partSelect':
            obj_ = PartSelect.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PartSelect = obj_
            obj_.original_tagname_ = 'partSelect'
# end class externalPortReference


class activeInterface(interfaceType):
    """excludePorts -- The list of physical ports to be excluded from an interface based connection. Analogous to the removing the port map element for the named ports.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('excludePorts', 'excludePortsType', 0, 1, {'minOccurs': '0', 'name': 'excludePorts', 'type': 'excludePortsType'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = interfaceType
    def __init__(self, componentRef=None, busRef=None, id=None, isPresent=None, description=None, excludePorts=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("activeInterface"), self).__init__(componentRef, busRef, id,  **kwargs_)
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.excludePorts = excludePorts
        self.excludePorts_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, activeInterface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if activeInterface.subclass:
            return activeInterface.subclass(*args_, **kwargs_)
        else:
            return activeInterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_excludePorts(self):
        return self.excludePorts
    def set_excludePorts(self, excludePorts):
        self.excludePorts = excludePorts
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def _hasContent(self):
        if (
            self.isPresent is not None or
            self.description is not None or
            self.excludePorts is not None or
            self.vendorExtensions is not None or
            super(activeInterface, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='activeInterface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('activeInterface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'activeInterface':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='activeInterface')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='activeInterface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='activeInterface'):
        super(activeInterface, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='activeInterface')
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='activeInterface', fromsubclass_=False, pretty_print=True):
        super(activeInterface, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.excludePorts is not None:
            namespaceprefix_ = self.excludePorts_nsprefix_ + ':' if (UseCapturedNS_ and self.excludePorts_nsprefix_) else ''
            self.excludePorts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='excludePorts', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(activeInterface, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'excludePorts':
            obj_ = excludePortsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.excludePorts = obj_
            obj_.original_tagname_ = 'excludePorts'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
        super(activeInterface, self)._buildChildren(child_, node, nodeName_, True)
# end class activeInterface


class assertion(GeneratedsSuper):
    """name -- Unique name
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('assert_', 'unsignedBitExpression', 0, 0, {'name': 'assert', 'type': 'unsignedBitExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, assert_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.assert_ = assert_
        self.assert__nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, assertion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if assertion.subclass:
            return assertion.subclass(*args_, **kwargs_)
        else:
            return assertion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_assert(self):
        return self.assert_
    def set_assert(self, assert_):
        self.assert_ = assert_
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.assert_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='assertion', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('assertion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'assertion':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='assertion')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='assertion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='assertion'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='assertion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.assert_ is not None:
            namespaceprefix_ = self.assert__nsprefix_ + ':' if (UseCapturedNS_ and self.assert__nsprefix_) else ''
            self.assert_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='assert', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'assert':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assert_ = obj_
            obj_.original_tagname_ = 'assert'
# end class assertion


class assertions(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('assertion', 'assertion', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'assertion', 'ref': 'assertion', 'type': 'assertion'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, assertion=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if assertion is None:
            self.assertion = []
        else:
            self.assertion = assertion
        self.assertion_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, assertions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if assertions.subclass:
            return assertions.subclass(*args_, **kwargs_)
        else:
            return assertions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_assertion(self):
        return self.assertion
    def set_assertion(self, assertion):
        self.assertion = assertion
    def add_assertion(self, value):
        self.assertion.append(value)
    def insert_assertion_at(self, index, value):
        self.assertion.insert(index, value)
    def replace_assertion_at(self, index, value):
        self.assertion[index] = value
    def _hasContent(self):
        if (
            self.assertion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='assertions', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('assertions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'assertions':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='assertions')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='assertions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='assertions'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='assertions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for assertion_ in self.assertion:
            namespaceprefix_ = self.assertion_nsprefix_ + ':' if (UseCapturedNS_ and self.assertion_nsprefix_) else ''
            assertion_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='assertion', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'assertion':
            obj_ = assertion.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assertion.append(obj_)
            obj_.original_tagname_ = 'assertion'
# end class assertions


class parameters(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('parameter', 'parameterType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'parameter', 'ref': 'parameter', 'type': 'parameter'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, parameter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
        self.parameter_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parameters.subclass:
            return parameters.subclass(*args_, **kwargs_)
        else:
            return parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_parameter(self):
        return self.parameter
    def set_parameter(self, parameter):
        self.parameter = parameter
    def add_parameter(self, value):
        self.parameter.append(value)
    def insert_parameter_at(self, index, value):
        self.parameter.insert(index, value)
    def replace_parameter_at(self, index, value):
        self.parameter[index] = value
    def _hasContent(self):
        if (
            self.parameter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='parameters', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'parameters':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parameters')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='parameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='parameters'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='parameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for parameter_ in self.parameter:
            namespaceprefix_ = self.parameter_nsprefix_ + ':' if (UseCapturedNS_ and self.parameter_nsprefix_) else ''
            parameter_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'parameter':
            class_obj_ = self.get_class_obj_(child_, parameterType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameter.append(obj_)
            obj_.original_tagname_ = 'parameter'
# end class parameters


class vendorExtensions(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('__ANY__', '__ANY__', 1, 0, {'maxOccurs': 'unbounded', 'namespace': '##any', 'processContents': 'lax'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vendorExtensions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vendorExtensions.subclass:
            return vendorExtensions.subclass(*args_, **kwargs_)
        else:
            return vendorExtensions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def _hasContent(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='vendorExtensions', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vendorExtensions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'vendorExtensions':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vendorExtensions')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='vendorExtensions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='vendorExtensions'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='vendorExtensions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(obj_)
                outfile.write('\n')
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        content_ = self.gds_build_any(child_, 'vendorExtensions')
        self.anytypeobjs_.append(content_)
# end class vendorExtensions


class leafAccessHandle(GeneratedsSuper):
    """viewRef -- A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.
    indices -- For a multi dimensional IP-XACT object, indices can be specified to select the element the accessHandle applies to. This is an index into a multi-dimensional array and follows C-semantics for indexing.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('force', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'force'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'viewRef', 'type': 'viewRefType'}, None),
        MemberSpec_('indices', 'indicesType2', 0, 1, {'minOccurs': '0', 'name': 'indices', 'type': 'indicesType2'}, None),
        MemberSpec_('slices', 'slicesType', 0, 0, {'name': 'slices', 'type': 'slicesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, force=True, id=None, viewRef=None, indices=None, slices=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.force = _cast(bool, force)
        self.force_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.viewRef_nsprefix_ = "ipxact"
        self.indices = indices
        self.indices_nsprefix_ = "ipxact"
        self.slices = slices
        self.slices_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, leafAccessHandle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if leafAccessHandle.subclass:
            return leafAccessHandle.subclass(*args_, **kwargs_)
        else:
            return leafAccessHandle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_viewRef(self):
        return self.viewRef
    def set_viewRef(self, viewRef):
        self.viewRef = viewRef
    def add_viewRef(self, value):
        self.viewRef.append(value)
    def insert_viewRef_at(self, index, value):
        self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value):
        self.viewRef[index] = value
    def get_indices(self):
        return self.indices
    def set_indices(self, indices):
        self.indices = indices
    def get_slices(self):
        return self.slices
    def set_slices(self, slices):
        self.slices = slices
    def get_force(self):
        return self.force
    def set_force(self, force):
        self.force = force
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.viewRef or
            self.indices is not None or
            self.slices is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='leafAccessHandle', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('leafAccessHandle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'leafAccessHandle':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='leafAccessHandle')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='leafAccessHandle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='leafAccessHandle'):
        if not self.force and 'force' not in already_processed:
            already_processed.add('force')
            outfile.write(' force="%s"' % self.gds_format_boolean(self.force, input_name='force'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='leafAccessHandle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for viewRef_ in self.viewRef:
            namespaceprefix_ = self.viewRef_nsprefix_ + ':' if (UseCapturedNS_ and self.viewRef_nsprefix_) else ''
            viewRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='viewRef', pretty_print=pretty_print)
        if self.indices is not None:
            namespaceprefix_ = self.indices_nsprefix_ + ':' if (UseCapturedNS_ and self.indices_nsprefix_) else ''
            self.indices.export(outfile, level, namespaceprefix_, namespacedef_='', name_='indices', pretty_print=pretty_print)
        if self.slices is not None:
            namespaceprefix_ = self.slices_nsprefix_ + ':' if (UseCapturedNS_ and self.slices_nsprefix_) else ''
            self.slices.export(outfile, level, namespaceprefix_, namespacedef_='', name_='slices', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('force', node)
        if value is not None and 'force' not in already_processed:
            already_processed.add('force')
            if value in ('true', '1'):
                self.force = True
            elif value in ('false', '0'):
                self.force = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'viewRef':
            obj_ = viewRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
        elif nodeName_ == 'indices':
            obj_ = indicesType2.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.indices = obj_
            obj_.original_tagname_ = 'indices'
        elif nodeName_ == 'slices':
            obj_ = slicesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.slices = obj_
            obj_.original_tagname_ = 'slices'
# end class leafAccessHandle


class nonIndexedLeafAccessHandle(GeneratedsSuper):
    """viewRef -- A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('force', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'force'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'viewRef', 'type': 'viewRefType3'}, None),
        MemberSpec_('slices', 'slicesType', 0, 0, {'name': 'slices', 'type': 'slicesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, force=True, id=None, viewRef=None, slices=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.force = _cast(bool, force)
        self.force_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.viewRef_nsprefix_ = "ipxact"
        self.slices = slices
        self.slices_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nonIndexedLeafAccessHandle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nonIndexedLeafAccessHandle.subclass:
            return nonIndexedLeafAccessHandle.subclass(*args_, **kwargs_)
        else:
            return nonIndexedLeafAccessHandle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_viewRef(self):
        return self.viewRef
    def set_viewRef(self, viewRef):
        self.viewRef = viewRef
    def add_viewRef(self, value):
        self.viewRef.append(value)
    def insert_viewRef_at(self, index, value):
        self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value):
        self.viewRef[index] = value
    def get_slices(self):
        return self.slices
    def set_slices(self, slices):
        self.slices = slices
    def get_force(self):
        return self.force
    def set_force(self, force):
        self.force = force
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.viewRef or
            self.slices is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='nonIndexedLeafAccessHandle', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nonIndexedLeafAccessHandle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'nonIndexedLeafAccessHandle':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nonIndexedLeafAccessHandle')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='nonIndexedLeafAccessHandle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='nonIndexedLeafAccessHandle'):
        if not self.force and 'force' not in already_processed:
            already_processed.add('force')
            outfile.write(' force="%s"' % self.gds_format_boolean(self.force, input_name='force'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='nonIndexedLeafAccessHandle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for viewRef_ in self.viewRef:
            namespaceprefix_ = self.viewRef_nsprefix_ + ':' if (UseCapturedNS_ and self.viewRef_nsprefix_) else ''
            viewRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='viewRef', pretty_print=pretty_print)
        if self.slices is not None:
            namespaceprefix_ = self.slices_nsprefix_ + ':' if (UseCapturedNS_ and self.slices_nsprefix_) else ''
            self.slices.export(outfile, level, namespaceprefix_, namespacedef_='', name_='slices', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('force', node)
        if value is not None and 'force' not in already_processed:
            already_processed.add('force')
            if value in ('true', '1'):
                self.force = True
            elif value in ('false', '0'):
                self.force = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'viewRef':
            obj_ = viewRefType3.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
        elif nodeName_ == 'slices':
            obj_ = slicesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.slices = obj_
            obj_.original_tagname_ = 'slices'
# end class nonIndexedLeafAccessHandle


class indexedAccessHandle(GeneratedsSuper):
    """viewRef -- A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.
    indices -- For a multi dimensional IP-XACT object, indices can be specified to select the element the accessHandle applies to. This is an index into a multi-dimensional array and follows C-semantics for indexing.
    pathSegments -- An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the parent slice into the referenced view.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'viewRef', 'type': 'viewRefType4'}, None),
        MemberSpec_('indices', 'indicesType5', 0, 1, {'minOccurs': '0', 'name': 'indices', 'type': 'indicesType5'}, None),
        MemberSpec_('pathSegments', 'pathSegmentsType', 0, 0, {'name': 'pathSegments', 'type': 'pathSegmentsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, viewRef=None, indices=None, pathSegments=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.viewRef_nsprefix_ = "ipxact"
        self.indices = indices
        self.indices_nsprefix_ = "ipxact"
        self.pathSegments = pathSegments
        self.pathSegments_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indexedAccessHandle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indexedAccessHandle.subclass:
            return indexedAccessHandle.subclass(*args_, **kwargs_)
        else:
            return indexedAccessHandle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_viewRef(self):
        return self.viewRef
    def set_viewRef(self, viewRef):
        self.viewRef = viewRef
    def add_viewRef(self, value):
        self.viewRef.append(value)
    def insert_viewRef_at(self, index, value):
        self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value):
        self.viewRef[index] = value
    def get_indices(self):
        return self.indices
    def set_indices(self, indices):
        self.indices = indices
    def get_pathSegments(self):
        return self.pathSegments
    def set_pathSegments(self, pathSegments):
        self.pathSegments = pathSegments
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.viewRef or
            self.indices is not None or
            self.pathSegments is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indexedAccessHandle', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indexedAccessHandle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'indexedAccessHandle':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='indexedAccessHandle')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='indexedAccessHandle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='indexedAccessHandle'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indexedAccessHandle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for viewRef_ in self.viewRef:
            namespaceprefix_ = self.viewRef_nsprefix_ + ':' if (UseCapturedNS_ and self.viewRef_nsprefix_) else ''
            viewRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='viewRef', pretty_print=pretty_print)
        if self.indices is not None:
            namespaceprefix_ = self.indices_nsprefix_ + ':' if (UseCapturedNS_ and self.indices_nsprefix_) else ''
            self.indices.export(outfile, level, namespaceprefix_, namespacedef_='', name_='indices', pretty_print=pretty_print)
        if self.pathSegments is not None:
            namespaceprefix_ = self.pathSegments_nsprefix_ + ':' if (UseCapturedNS_ and self.pathSegments_nsprefix_) else ''
            self.pathSegments.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pathSegments', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'viewRef':
            obj_ = viewRefType4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
        elif nodeName_ == 'indices':
            obj_ = indicesType5.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.indices = obj_
            obj_.original_tagname_ = 'indices'
        elif nodeName_ == 'pathSegments':
            obj_ = pathSegmentsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pathSegments = obj_
            obj_.original_tagname_ = 'pathSegments'
# end class indexedAccessHandle


class simpleAccessHandle(GeneratedsSuper):
    """viewRef -- A list of views this accessHandle is applicable to. Note this element is optional, if it is not present the accessHandle applies to all views.
    pathSegments -- An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the parent slice into the referenced view.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'viewRef', 'type': 'viewRefType6'}, None),
        MemberSpec_('pathSegments', 'pathSegmentsType7', 0, 0, {'name': 'pathSegments', 'type': 'pathSegmentsType7'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, viewRef=None, pathSegments=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.viewRef_nsprefix_ = "ipxact"
        self.pathSegments = pathSegments
        self.pathSegments_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, simpleAccessHandle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if simpleAccessHandle.subclass:
            return simpleAccessHandle.subclass(*args_, **kwargs_)
        else:
            return simpleAccessHandle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_viewRef(self):
        return self.viewRef
    def set_viewRef(self, viewRef):
        self.viewRef = viewRef
    def add_viewRef(self, value):
        self.viewRef.append(value)
    def insert_viewRef_at(self, index, value):
        self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value):
        self.viewRef[index] = value
    def get_pathSegments(self):
        return self.pathSegments
    def set_pathSegments(self, pathSegments):
        self.pathSegments = pathSegments
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.viewRef or
            self.pathSegments is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='simpleAccessHandle', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('simpleAccessHandle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'simpleAccessHandle':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='simpleAccessHandle')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='simpleAccessHandle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='simpleAccessHandle'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='simpleAccessHandle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for viewRef_ in self.viewRef:
            namespaceprefix_ = self.viewRef_nsprefix_ + ':' if (UseCapturedNS_ and self.viewRef_nsprefix_) else ''
            viewRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='viewRef', pretty_print=pretty_print)
        if self.pathSegments is not None:
            namespaceprefix_ = self.pathSegments_nsprefix_ + ':' if (UseCapturedNS_ and self.pathSegments_nsprefix_) else ''
            self.pathSegments.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pathSegments', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'viewRef':
            obj_ = viewRefType6.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
        elif nodeName_ == 'pathSegments':
            obj_ = pathSegmentsType7.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pathSegments = obj_
            obj_.original_tagname_ = 'pathSegments'
# end class simpleAccessHandle


class slicesType(GeneratedsSuper):
    """slice -- The HDL path for a slice of the IP-XACT object.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('slice', 'sliceType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'slice', 'type': 'sliceType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, slice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if slice is None:
            self.slice = []
        else:
            self.slice = slice
        self.slice_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, slicesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if slicesType.subclass:
            return slicesType.subclass(*args_, **kwargs_)
        else:
            return slicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_slice(self):
        return self.slice
    def set_slice(self, slice):
        self.slice = slice
    def add_slice(self, value):
        self.slice.append(value)
    def insert_slice_at(self, index, value):
        self.slice.insert(index, value)
    def replace_slice_at(self, index, value):
        self.slice[index] = value
    def _hasContent(self):
        if (
            self.slice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='slicesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('slicesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'slicesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='slicesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='slicesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='slicesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='slicesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for slice_ in self.slice:
            namespaceprefix_ = self.slice_nsprefix_ + ':' if (UseCapturedNS_ and self.slice_nsprefix_) else ''
            slice_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='slice', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'slice':
            obj_ = sliceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.slice.append(obj_)
            obj_.original_tagname_ = 'slice'
# end class slicesType


class sliceType(GeneratedsSuper):
    """pathSegments -- An ordered list of pathSegment elements. When concatenated with a desired separator the elements in this form a HDL path for the
    parent slice into the referenced view.
    range -- A range to be applied to the concatenation of the above path segments
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('pathSegments', 'pathSegmentsType8', 0, 0, {'name': 'pathSegments', 'type': 'pathSegmentsType8'}, None),
        MemberSpec_('Range', 'range', 0, 1, {'minOccurs': '0', 'name': 'range', 'ref': 'range', 'type': 'range'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, pathSegments=None, Range=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.pathSegments = pathSegments
        self.pathSegments_nsprefix_ = "ipxact"
        self.Range = Range
        self.Range_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sliceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sliceType.subclass:
            return sliceType.subclass(*args_, **kwargs_)
        else:
            return sliceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pathSegments(self):
        return self.pathSegments
    def set_pathSegments(self, pathSegments):
        self.pathSegments = pathSegments
    def get_range(self):
        return self.Range
    def set_range(self, Range):
        self.Range = Range
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.pathSegments is not None or
            self.Range is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='sliceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sliceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'sliceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sliceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='sliceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='sliceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='sliceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pathSegments is not None:
            namespaceprefix_ = self.pathSegments_nsprefix_ + ':' if (UseCapturedNS_ and self.pathSegments_nsprefix_) else ''
            self.pathSegments.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pathSegments', pretty_print=pretty_print)
        if self.Range is not None:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            self.Range.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='range', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pathSegments':
            obj_ = pathSegmentsType8.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pathSegments = obj_
            obj_.original_tagname_ = 'pathSegments'
        elif nodeName_ == 'range':
            obj_ = Range.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
# end class sliceType


class pathSegmentType(GeneratedsSuper):
    """pathSegmentName -- One section of a HDL path
    indices -- Specifies a multi-dimensional index into pathSegementName
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('pathSegmentName', 'xs:string', 0, 0, {'name': 'pathSegmentName', 'type': 'xs:string'}, None),
        MemberSpec_('indices', 'indicesType', 0, 1, {'minOccurs': '0', 'name': 'indices', 'type': 'indicesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, pathSegmentName=None, indices=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.pathSegmentName = pathSegmentName
        self.pathSegmentName_nsprefix_ = "ipxact"
        self.indices = indices
        self.indices_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathSegmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathSegmentType.subclass:
            return pathSegmentType.subclass(*args_, **kwargs_)
        else:
            return pathSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pathSegmentName(self):
        return self.pathSegmentName
    def set_pathSegmentName(self, pathSegmentName):
        self.pathSegmentName = pathSegmentName
    def get_indices(self):
        return self.indices
    def set_indices(self, indices):
        self.indices = indices
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.pathSegmentName is not None or
            self.indices is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='pathSegmentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pathSegmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'pathSegmentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pathSegmentType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='pathSegmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='pathSegmentType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='pathSegmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pathSegmentName is not None:
            namespaceprefix_ = self.pathSegmentName_nsprefix_ + ':' if (UseCapturedNS_ and self.pathSegmentName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spathSegmentName>%s</%spathSegmentName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pathSegmentName), input_name='pathSegmentName')), namespaceprefix_ , eol_))
        if self.indices is not None:
            namespaceprefix_ = self.indices_nsprefix_ + ':' if (UseCapturedNS_ and self.indices_nsprefix_) else ''
            self.indices.export(outfile, level, namespaceprefix_, namespacedef_='', name_='indices', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pathSegmentName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'pathSegmentName')
            value_ = self.gds_validate_string(value_, node, 'pathSegmentName')
            self.pathSegmentName = value_
            self.pathSegmentName_nsprefix_ = child_.prefix
        elif nodeName_ == 'indices':
            obj_ = indicesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.indices = obj_
            obj_.original_tagname_ = 'indices'
# end class pathSegmentType


class parameterBaseType(GeneratedsSuper):
    """name -- Unique name
    value -- The value of the parameter.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('parameterId', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'parameterId'}),
        MemberSpec_('prompt', 'xs:string', 0, 1, {'use': 'optional', 'name': 'prompt'}),
        MemberSpec_('choiceRef', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'choiceRef'}),
        MemberSpec_('order', 'xs:float', 0, 1, {'use': 'optional', 'name': 'order'}),
        MemberSpec_('configGroups', 'xs:NMTOKENS', 0, 1, {'use': 'optional', 'name': 'configGroups'}),
        MemberSpec_('minimum', 'xs:string', 0, 1, {'use': 'optional', 'name': 'minimum'}),
        MemberSpec_('maximum', 'xs:string', 0, 1, {'use': 'optional', 'name': 'maximum'}),
        MemberSpec_('type_', 'ipxact:formatType', 0, 1, {'use': 'optional', 'name': 'type_'}),
        MemberSpec_('sign', 'ipxact:signType', 0, 1, {'use': 'optional', 'name': 'sign'}),
        MemberSpec_('prefix', 'prefixType', 0, 1, {'use': 'optional', 'name': 'prefix'}),
        MemberSpec_('unit', 'unitType', 0, 1, {'use': 'optional', 'name': 'unit'}),
        MemberSpec_('name', 'xs:string', 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('Vectors', 'vectors', 0, 1, {'minOccurs': '0', 'name': 'vectors', 'ref': 'vectors', 'type': 'vectors'}, None),
        MemberSpec_('arrays', 'configurableArrays', 0, 1, {'minOccurs': '0', 'name': 'arrays', 'type': 'configurableArrays'}, None),
        MemberSpec_('value', 'stringExpression', 0, 0, {'name': 'value', 'type': 'complexBaseExpression'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, parameterId=None, prompt=None, choiceRef=None, order=None, configGroups=None, minimum=None, maximum=None, type_='string', sign=None, prefix=None, unit=None, name=None, displayName=None, description=None, Vectors=None, arrays=None, value=None, vendorExtensions=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.parameterId = _cast(None, parameterId)
        self.parameterId_nsprefix_ = None
        self.prompt = _cast(None, prompt)
        self.prompt_nsprefix_ = None
        self.choiceRef = _cast(None, choiceRef)
        self.choiceRef_nsprefix_ = None
        self.order = _cast(float, order)
        self.order_nsprefix_ = None
        self.configGroups = _cast(None, configGroups)
        self.configGroups_nsprefix_ = None
        self.minimum = _cast(None, minimum)
        self.minimum_nsprefix_ = None
        self.maximum = _cast(None, maximum)
        self.maximum_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.sign = _cast(None, sign)
        self.sign_nsprefix_ = None
        self.prefix = _cast(None, prefix)
        self.prefix_nsprefix_ = None
        self.unit = _cast(None, unit)
        self.unit_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.Vectors = Vectors
        self.Vectors_nsprefix_ = "ipxact"
        self.arrays = arrays
        self.arrays_nsprefix_ = "ipxact"
        self.value = value
        self.value_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parameterBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parameterBaseType.subclass:
            return parameterBaseType.subclass(*args_, **kwargs_)
        else:
            return parameterBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_vectors(self):
        return self.Vectors
    def set_vectors(self, Vectors):
        self.Vectors = Vectors
    def get_arrays(self):
        return self.arrays
    def set_arrays(self, arrays):
        self.arrays = arrays
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_parameterId(self):
        return self.parameterId
    def set_parameterId(self, parameterId):
        self.parameterId = parameterId
    def get_prompt(self):
        return self.prompt
    def set_prompt(self, prompt):
        self.prompt = prompt
    def get_choiceRef(self):
        return self.choiceRef
    def set_choiceRef(self, choiceRef):
        self.choiceRef = choiceRef
    def get_order(self):
        return self.order
    def set_order(self, order):
        self.order = order
    def get_configGroups(self):
        return self.configGroups
    def set_configGroups(self, configGroups):
        self.configGroups = configGroups
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_sign(self):
        return self.sign
    def set_sign(self, sign):
        self.sign = sign
    def get_prefix(self):
        return self.prefix
    def set_prefix(self, prefix):
        self.prefix = prefix
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_formatType(self, value):
        # Validate type ipxact:formatType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['bit', 'byte', 'shortint', 'int', 'longint', 'shortreal', 'real', 'string']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on formatType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_signType(self, value):
        # Validate type ipxact:signType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['signed', 'unsigned']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on signType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_prefixType(self, value):
        # Validate type prefixType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['deca', 'hecto', 'kilo', 'mega', 'giga', 'tera', 'peta', 'exa', 'zetta', 'yotta', 'deci', 'centi', 'milli', 'micro', 'nano', 'pico', 'femto', 'atto', 'zepto', 'yocto']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on prefixType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_unitType(self, value):
        # Validate type unitType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['second', 'ampere', 'kelvin', 'hertz', 'joule', 'watt', 'coulomb', 'volt', 'farad', 'ohm', 'siemens', 'henry', 'Celsius']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on unitType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.Vectors is not None or
            self.arrays is not None or
            self.value is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='parameterBaseType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parameterBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'parameterBaseType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parameterBaseType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='parameterBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='parameterBaseType'):
        if self.parameterId is not None and 'parameterId' not in already_processed:
            already_processed.add('parameterId')
            outfile.write(' parameterId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parameterId), input_name='parameterId')), ))
        if self.prompt is not None and 'prompt' not in already_processed:
            already_processed.add('prompt')
            outfile.write(' prompt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prompt), input_name='prompt')), ))
        if self.choiceRef is not None and 'choiceRef' not in already_processed:
            already_processed.add('choiceRef')
            outfile.write(' choiceRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.choiceRef), input_name='choiceRef')), ))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_float(self.order, input_name='order'))
        if self.configGroups is not None and 'configGroups' not in already_processed:
            already_processed.add('configGroups')
            outfile.write(' configGroups=%s' % (quote_attrib(self.configGroups), ))
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.minimum), input_name='minimum')), ))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.maximum), input_name='maximum')), ))
        if self.type_ != "string" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.sign is not None and 'sign' not in already_processed:
            already_processed.add('sign')
            outfile.write(' sign=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sign), input_name='sign')), ))
        if self.prefix is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            outfile.write(' prefix=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prefix), input_name='prefix')), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='parameterBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.Vectors is not None:
            namespaceprefix_ = self.Vectors_nsprefix_ + ':' if (UseCapturedNS_ and self.Vectors_nsprefix_) else ''
            self.Vectors.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vectors', pretty_print=pretty_print)
        if self.arrays is not None:
            namespaceprefix_ = self.arrays_nsprefix_ + ':' if (UseCapturedNS_ and self.arrays_nsprefix_) else ''
            self.arrays.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arrays', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterId', node)
        if value is not None and 'parameterId' not in already_processed:
            already_processed.add('parameterId')
            self.parameterId = value
        value = find_attr_value_('prompt', node)
        if value is not None and 'prompt' not in already_processed:
            already_processed.add('prompt')
            self.prompt = value
        value = find_attr_value_('choiceRef', node)
        if value is not None and 'choiceRef' not in already_processed:
            already_processed.add('choiceRef')
            self.choiceRef = value
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            value = self.gds_parse_float(value, node, 'order')
            self.order = value
        value = find_attr_value_('configGroups', node)
        if value is not None and 'configGroups' not in already_processed:
            already_processed.add('configGroups')
            self.configGroups = value
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            self.minimum = value
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            self.maximum = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
            self.validate_formatType(self.type_)    # validate type formatType
        value = find_attr_value_('sign', node)
        if value is not None and 'sign' not in already_processed:
            already_processed.add('sign')
            self.sign = value
            self.sign = ' '.join(self.sign.split())
            self.validate_signType(self.sign)    # validate type signType
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            self.prefix = value
            self.validate_prefixType(self.prefix)    # validate type prefixType
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_unitType(self.unit)    # validate type unitType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'vectors':
            obj_ = Vectors.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Vectors = obj_
            obj_.original_tagname_ = 'vectors'
        elif nodeName_ == 'arrays':
            obj_ = configurableArrays.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arrays = obj_
            obj_.original_tagname_ = 'arrays'
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, complexBaseExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class parameterBaseType


class parameterType(parameterBaseType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('resolve', 'resolveType', 0, 1, {'use': 'optional', 'name': 'resolve'}),
    ]
    subclass = None
    superclass = parameterBaseType
    def __init__(self, parameterId=None, prompt=None, choiceRef=None, order=None, configGroups=None, minimum=None, maximum=None, type_='string', sign=None, prefix=None, unit=None, name=None, displayName=None, description=None, Vectors=None, arrays=None, value=None, vendorExtensions=None, resolve='immediate', extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("parameterType"), self).__init__(parameterId, prompt, choiceRef, order, configGroups, minimum, maximum, type_, sign, prefix, unit, name, displayName, description, Vectors, arrays, value, vendorExtensions, extensiontype_,  **kwargs_)
        self.resolve = _cast(None, resolve)
        self.resolve_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parameterType.subclass:
            return parameterType.subclass(*args_, **kwargs_)
        else:
            return parameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_resolve(self):
        return self.resolve
    def set_resolve(self, resolve):
        self.resolve = resolve
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_resolveType(self, value):
        # Validate type resolveType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['immediate', 'user', 'generated']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on resolveType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            super(parameterType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='parameterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'parameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parameterType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='parameterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='parameterType'):
        super(parameterType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='parameterType')
        if self.resolve != "immediate" and 'resolve' not in already_processed:
            already_processed.add('resolve')
            outfile.write(' resolve=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.resolve), input_name='resolve')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='parameterType', fromsubclass_=False, pretty_print=True):
        super(parameterType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resolve', node)
        if value is not None and 'resolve' not in already_processed:
            already_processed.add('resolve')
            self.resolve = value
            self.resolve = ' '.join(self.resolve.split())
            self.validate_resolveType(self.resolve)    # validate type resolveType
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(parameterType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(parameterType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class parameterType


class nameValuePairType(GeneratedsSuper):
    """name -- Unique name
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:string', 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('value', 'stringExpression', 0, 0, {'name': 'value', 'ref': 'value', 'type': 'value'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, value=None, vendorExtensions=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.value = value
        self.value_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nameValuePairType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nameValuePairType.subclass:
            return nameValuePairType.subclass(*args_, **kwargs_)
        else:
            return nameValuePairType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.value is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='nameValuePairType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nameValuePairType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'nameValuePairType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nameValuePairType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='nameValuePairType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='nameValuePairType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='nameValuePairType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='value', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class nameValuePairType


class Vector(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('left', 'unsignedIntExpression', 0, 0, {'name': 'left', 'ref': 'left', 'type': 'left'}, None),
        MemberSpec_('right', 'unsignedIntExpression', 0, 0, {'name': 'right', 'ref': 'right', 'type': 'right'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, left=None, right=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.left = left
        self.left_nsprefix_ = "ipxact"
        self.right = right
        self.right_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Vector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Vector.subclass:
            return Vector.subclass(*args_, **kwargs_)
        else:
            return Vector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_left(self):
        return self.left
    def set_left(self, left):
        self.left = left
    def get_right(self):
        return self.right
    def set_right(self, right):
        self.right = right
    def _hasContent(self):
        if (
            self.left is not None or
            self.right is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='vector', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'vector':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vector')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='vector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='vector'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='vector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left is not None:
            namespaceprefix_ = self.left_nsprefix_ + ':' if (UseCapturedNS_ and self.left_nsprefix_) else ''
            self.left.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='left', pretty_print=pretty_print)
        if self.right is not None:
            namespaceprefix_ = self.right_nsprefix_ + ':' if (UseCapturedNS_ and self.right_nsprefix_) else ''
            self.right.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='right', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'left':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.left = obj_
            obj_.original_tagname_ = 'left'
        elif nodeName_ == 'right':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.right = obj_
            obj_.original_tagname_ = 'right'
# end class Vector


class Vectors(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Vector', 'vector', 1, 0, {'maxOccurs': 'unbounded', 'name': 'vector', 'ref': 'vector', 'type': 'vector'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Vector=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if Vector is None:
            self.Vector = []
        else:
            self.Vector = Vector
        self.Vector_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Vectors)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Vectors.subclass:
            return Vectors.subclass(*args_, **kwargs_)
        else:
            return Vectors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vector(self):
        return self.Vector
    def set_vector(self, Vector):
        self.Vector = Vector
    def add_vector(self, value):
        self.Vector.append(value)
    def insert_vector_at(self, index, value):
        self.Vector.insert(index, value)
    def replace_vector_at(self, index, value):
        self.Vector[index] = value
    def _hasContent(self):
        if (
            self.Vector
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='vectors', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vectors')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'vectors':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vectors')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='vectors', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='vectors'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='vectors', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vector_ in self.Vector:
            namespaceprefix_ = self.Vector_nsprefix_ + ':' if (UseCapturedNS_ and self.Vector_nsprefix_) else ''
            vector_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vector', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vector':
            obj_ = Vector.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Vector.append(obj_)
            obj_.original_tagname_ = 'vector'
# end class Vectors


class Range(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('left', 'unsignedIntExpression', 0, 0, {'name': 'left', 'ref': 'left', 'type': 'left'}, None),
        MemberSpec_('right', 'unsignedIntExpression', 0, 0, {'name': 'right', 'ref': 'right', 'type': 'right'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, left=None, right=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.left = left
        self.left_nsprefix_ = "ipxact"
        self.right = right
        self.right_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Range)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Range.subclass:
            return Range.subclass(*args_, **kwargs_)
        else:
            return Range(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_left(self):
        return self.left
    def set_left(self, left):
        self.left = left
    def get_right(self):
        return self.right
    def set_right(self, right):
        self.right = right
    def _hasContent(self):
        if (
            self.left is not None or
            self.right is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='range', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('range')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'range':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='range')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='range', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='range'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='range', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left is not None:
            namespaceprefix_ = self.left_nsprefix_ + ':' if (UseCapturedNS_ and self.left_nsprefix_) else ''
            self.left.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='left', pretty_print=pretty_print)
        if self.right is not None:
            namespaceprefix_ = self.right_nsprefix_ + ':' if (UseCapturedNS_ and self.right_nsprefix_) else ''
            self.right.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='right', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'left':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.left = obj_
            obj_.original_tagname_ = 'left'
        elif nodeName_ == 'right':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.right = obj_
            obj_.original_tagname_ = 'right'
# end class Range


class PartSelect(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('indices', 'indicesType', 0, 0, {'name': 'indices', 'type': 'indicesType'}, 5),
        MemberSpec_('Range', 'range', 0, 1, {'minOccurs': '0', 'name': 'range', 'ref': 'range', 'type': 'range'}, 5),
    ]
    subclass = None
    superclass = None
    def __init__(self, indices=None, Range=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.indices = indices
        self.indices_nsprefix_ = "ipxact"
        self.Range = Range
        self.Range_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartSelect)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartSelect.subclass:
            return PartSelect.subclass(*args_, **kwargs_)
        else:
            return PartSelect(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_indices(self):
        return self.indices
    def set_indices(self, indices):
        self.indices = indices
    def get_range(self):
        return self.Range
    def set_range(self, Range):
        self.Range = Range
    def _hasContent(self):
        if (
            self.indices is not None or
            self.Range is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='partSelect', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('partSelect')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'partSelect':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='partSelect')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='partSelect', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='partSelect'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='partSelect', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indices is not None:
            namespaceprefix_ = self.indices_nsprefix_ + ':' if (UseCapturedNS_ and self.indices_nsprefix_) else ''
            self.indices.export(outfile, level, namespaceprefix_, namespacedef_='', name_='indices', pretty_print=pretty_print)
        if self.Range is not None:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            self.Range.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='range', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'indices':
            obj_ = indicesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.indices = obj_
            obj_.original_tagname_ = 'indices'
        elif nodeName_ == 'range':
            obj_ = Range.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
# end class PartSelect


class configurableArrays(GeneratedsSuper):
    """array -- Specific left and right array bounds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('array', 'arrayType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'array', 'type': 'arrayType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, array=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if array is None:
            self.array = []
        else:
            self.array = array
        self.array_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, configurableArrays)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if configurableArrays.subclass:
            return configurableArrays.subclass(*args_, **kwargs_)
        else:
            return configurableArrays(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_array(self):
        return self.array
    def set_array(self, array):
        self.array = array
    def add_array(self, value):
        self.array.append(value)
    def insert_array_at(self, index, value):
        self.array.insert(index, value)
    def replace_array_at(self, index, value):
        self.array[index] = value
    def _hasContent(self):
        if (
            self.array
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='configurableArrays', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('configurableArrays')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'configurableArrays':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='configurableArrays')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='configurableArrays', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='configurableArrays'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='configurableArrays', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for array_ in self.array:
            namespaceprefix_ = self.array_nsprefix_ + ':' if (UseCapturedNS_ and self.array_nsprefix_) else ''
            array_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='array', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'array':
            obj_ = arrayType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.array.append(obj_)
            obj_.original_tagname_ = 'array'
# end class configurableArrays


class indicesType(GeneratedsSuper):
    """index -- An index into an object in the referenced view.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('index', 'unsignedIntExpression', 1, 0, {'maxOccurs': 'unbounded', 'name': 'index', 'type': 'unsignedIntExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, index=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if index is None:
            self.index = []
        else:
            self.index = index
        self.index_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indicesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indicesType.subclass:
            return indicesType.subclass(*args_, **kwargs_)
        else:
            return indicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def add_index(self, value):
        self.index.append(value)
    def insert_index_at(self, index, value):
        self.index.insert(index, value)
    def replace_index_at(self, index, value):
        self.index[index] = value
    def _hasContent(self):
        if (
            self.index
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indicesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indicesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'indicesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='indicesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='indicesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='indicesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indicesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for index_ in self.index:
            namespaceprefix_ = self.index_nsprefix_ + ':' if (UseCapturedNS_ and self.index_nsprefix_) else ''
            index_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='index', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'index':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.index.append(obj_)
            obj_.original_tagname_ = 'index'
# end class indicesType


class Port(GeneratedsSuper):
    """name -- Unique name
    wire -- Defines a port whose type resolves to simple bits.
    transactional -- Defines a port that implements or uses a service that can be implemented with functions or methods.
    access -- Port access characteristics.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', ['portName', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('wire', 'portWireType', 0, 0, {'name': 'wire', 'type': 'portWireType'}, 6),
        MemberSpec_('transactional', 'portTransactionalType', 0, 0, {'name': 'transactional', 'type': 'portTransactionalType'}, 6),
        MemberSpec_('arrays', 'configurableArrays', 0, 1, {'minOccurs': '0', 'name': 'arrays', 'ref': 'arrays', 'type': 'arrays'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'type': 'portAccessType'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, wire=None, transactional=None, arrays=None, access=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.validate_portName(self.name)
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.wire = wire
        self.wire_nsprefix_ = "ipxact"
        self.transactional = transactional
        self.transactional_nsprefix_ = "ipxact"
        self.arrays = arrays
        self.arrays_nsprefix_ = "ipxact"
        self.access = access
        self.access_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Port)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Port.subclass:
            return Port.subclass(*args_, **kwargs_)
        else:
            return Port(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_wire(self):
        return self.wire
    def set_wire(self, wire):
        self.wire = wire
    def get_transactional(self):
        return self.transactional
    def set_transactional(self, transactional):
        self.transactional = transactional
    def get_arrays(self):
        return self.arrays
    def set_arrays(self, arrays):
        self.arrays = arrays
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_portName(self, value):
        result = True
        # Validate type portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_portName_patterns_, ))
                result = False
        return result
    validate_portName_patterns_ = [['^([A-Za-z0-9\\.\\-:_]*)$']]
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.wire is not None or
            self.transactional is not None or
            self.arrays is not None or
            self.access is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'portType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='portType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='portType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='portType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.wire is not None:
            namespaceprefix_ = self.wire_nsprefix_ + ':' if (UseCapturedNS_ and self.wire_nsprefix_) else ''
            self.wire.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wire', pretty_print=pretty_print)
        if self.transactional is not None:
            namespaceprefix_ = self.transactional_nsprefix_ + ':' if (UseCapturedNS_ and self.transactional_nsprefix_) else ''
            self.transactional.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transactional', pretty_print=pretty_print)
        if self.arrays is not None:
            namespaceprefix_ = self.arrays_nsprefix_ + ':' if (UseCapturedNS_ and self.arrays_nsprefix_) else ''
            self.arrays.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='arrays', pretty_print=pretty_print)
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_, namespacedef_='', name_='access', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type portName
            self.validate_portName(self.name)
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'wire':
            obj_ = PortWire.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wire = obj_
            obj_.original_tagname_ = 'wire'
        elif nodeName_ == 'transactional':
            obj_ = portTransactionalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transactional = obj_
            obj_.original_tagname_ = 'transactional'
        elif nodeName_ == 'arrays':
            obj_ = configurableArrays.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.arrays = obj_
            obj_.original_tagname_ = 'arrays'
        elif nodeName_ == 'access':
            obj_ = portAccessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class Port


class abstractorPortType(GeneratedsSuper):
    """name -- Unique name
    wire -- Defines a port whose type resolves to simple bits.
    transactional -- Defines a port that implements or uses a service that can be implemented with functions or methods.
    access -- Port access characteristics.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', ['portName', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('wire', 'abstractorPortWireType', 0, 0, {'name': 'wire', 'type': 'abstractorPortWireType'}, 7),
        MemberSpec_('transactional', 'portTransactionalType', 0, 0, {'name': 'transactional', 'type': 'portTransactionalType'}, 7),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'type': 'portAccessType'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, wire=None, transactional=None, access=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.validate_portName(self.name)
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.wire = wire
        self.wire_nsprefix_ = "ipxact"
        self.transactional = transactional
        self.transactional_nsprefix_ = "ipxact"
        self.access = access
        self.access_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorPortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorPortType.subclass:
            return abstractorPortType.subclass(*args_, **kwargs_)
        else:
            return abstractorPortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_wire(self):
        return self.wire
    def set_wire(self, wire):
        self.wire = wire
    def get_transactional(self):
        return self.transactional
    def set_transactional(self, transactional):
        self.transactional = transactional
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_portName(self, value):
        result = True
        # Validate type portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_portName_patterns_, ))
                result = False
        return result
    validate_portName_patterns_ = [['^([A-Za-z0-9\\.\\-:_]*)$']]
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.wire is not None or
            self.transactional is not None or
            self.access is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorPortType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorPortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractorPortType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractorPortType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractorPortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='abstractorPortType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorPortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.wire is not None:
            namespaceprefix_ = self.wire_nsprefix_ + ':' if (UseCapturedNS_ and self.wire_nsprefix_) else ''
            self.wire.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wire', pretty_print=pretty_print)
        if self.transactional is not None:
            namespaceprefix_ = self.transactional_nsprefix_ + ':' if (UseCapturedNS_ and self.transactional_nsprefix_) else ''
            self.transactional.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transactional', pretty_print=pretty_print)
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_, namespacedef_='', name_='access', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type portName
            self.validate_portName(self.name)
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'wire':
            obj_ = abstractorPortWireType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wire = obj_
            obj_.original_tagname_ = 'wire'
        elif nodeName_ == 'transactional':
            obj_ = portTransactionalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transactional = obj_
            obj_.original_tagname_ = 'transactional'
        elif nodeName_ == 'access':
            obj_ = portAccessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class abstractorPortType


class protocol(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('protocolType', 'protocolTypeType9', 0, 0, {'name': 'protocolType', 'type': 'protocolTypeType9'}, None),
        MemberSpec_('payload', 'payload', 0, 1, {'minOccurs': '0', 'name': 'payload', 'ref': 'payload', 'type': 'payload'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, protocolType=None, payload=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.protocolType = protocolType
        self.protocolType_nsprefix_ = "ipxact"
        self.payload = payload
        self.payload_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocol.subclass:
            return protocol.subclass(*args_, **kwargs_)
        else:
            return protocol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_protocolType(self):
        return self.protocolType
    def set_protocolType(self, protocolType):
        self.protocolType = protocolType
    def get_payload(self):
        return self.payload
    def set_payload(self, payload):
        self.payload = payload
    def _hasContent(self):
        if (
            self.protocolType is not None or
            self.payload is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='protocol', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('protocol')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'protocol':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='protocol')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='protocol', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='protocol'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='protocol', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.protocolType is not None:
            namespaceprefix_ = self.protocolType_nsprefix_ + ':' if (UseCapturedNS_ and self.protocolType_nsprefix_) else ''
            self.protocolType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='protocolType', pretty_print=pretty_print)
        if self.payload is not None:
            namespaceprefix_ = self.payload_nsprefix_ + ':' if (UseCapturedNS_ and self.payload_nsprefix_) else ''
            self.payload.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='payload', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'protocolType':
            obj_ = protocolTypeType9.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocolType = obj_
            obj_.original_tagname_ = 'protocolType'
        elif nodeName_ == 'payload':
            obj_ = payload.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.payload = obj_
            obj_.original_tagname_ = 'payload'
# end class protocol


class kind(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('custom', 'xs:string', 0, 1, {'use': 'optional', 'name': 'custom'}),
        MemberSpec_('valueOf_', ['kindType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, custom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.custom = _cast(None, custom)
        self.custom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, kind)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if kind.subclass:
            return kind.subclass(*args_, **kwargs_)
        else:
            return kind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_custom(self):
        return self.custom
    def set_custom(self, custom):
        self.custom = custom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_kindType(self, value):
        result = True
        # Validate type kindType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['tlm_port', 'tlm_socket', 'simple_socket', 'multi_socket', 'custom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on kindType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='kind', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('kind')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'kind':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='kind')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='kind', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='kind'):
        if self.custom is not None and 'custom' not in already_processed:
            already_processed.add('custom')
            outfile.write(' custom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.custom), input_name='custom')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='kind', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('custom', node)
        if value is not None and 'custom' not in already_processed:
            already_processed.add('custom')
            self.custom = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class kind


class payload(GeneratedsSuper):
    """name -- Defines the name of the payload. For example: TLM2 or TLM1
    type -- Defines the type of the payload.
    extension -- Defines the name of the payload extension. If attribute is not specified, it is by default optional.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('type_', ['typeType', 'xs:string'], 0, 0, {'name': 'type', 'type': 'xs:string'}, None),
        MemberSpec_('extension', 'extensionType', 0, 1, {'minOccurs': '0', 'name': 'extension', 'type': 'extensionType'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, type_=None, extension=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.type_ = type_
        self.validate_typeType(self.type_)
        self.type__nsprefix_ = "ipxact"
        self.extension = extension
        self.extension_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, payload)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if payload.subclass:
            return payload.subclass(*args_, **kwargs_)
        else:
            return payload(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_extension(self):
        return self.extension
    def set_extension(self, extension):
        self.extension = extension
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def validate_typeType(self, value):
        result = True
        # Validate type typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['generic', 'specific']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on typeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.name is not None or
            self.type_ is not None or
            self.extension is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='payload', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('payload')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'payload':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='payload')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='payload', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='payload'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='payload', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.extension is not None:
            namespaceprefix_ = self.extension_nsprefix_ + ':' if (UseCapturedNS_ and self.extension_nsprefix_) else ''
            self.extension.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extension', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type typeType
            self.validate_typeType(self.type_)
        elif nodeName_ == 'extension':
            obj_ = extensionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extension = obj_
            obj_.original_tagname_ = 'extension'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class payload


class typeParameters(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('typeParameter', 'moduleParameterType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'typeParameter', 'ref': 'typeParameter', 'type': 'typeParameter'}, None),
        MemberSpec_('serviceTypeDef', 'serviceTypeDef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'serviceTypeDef', 'ref': 'serviceTypeDef', 'type': 'serviceTypeDef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, typeParameter=None, serviceTypeDef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if typeParameter is None:
            self.typeParameter = []
        else:
            self.typeParameter = typeParameter
        self.typeParameter_nsprefix_ = "ipxact"
        if serviceTypeDef is None:
            self.serviceTypeDef = []
        else:
            self.serviceTypeDef = serviceTypeDef
        self.serviceTypeDef_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeParameters.subclass:
            return typeParameters.subclass(*args_, **kwargs_)
        else:
            return typeParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_typeParameter(self):
        return self.typeParameter
    def set_typeParameter(self, typeParameter):
        self.typeParameter = typeParameter
    def add_typeParameter(self, value):
        self.typeParameter.append(value)
    def insert_typeParameter_at(self, index, value):
        self.typeParameter.insert(index, value)
    def replace_typeParameter_at(self, index, value):
        self.typeParameter[index] = value
    def get_serviceTypeDef(self):
        return self.serviceTypeDef
    def set_serviceTypeDef(self, serviceTypeDef):
        self.serviceTypeDef = serviceTypeDef
    def add_serviceTypeDef(self, value):
        self.serviceTypeDef.append(value)
    def insert_serviceTypeDef_at(self, index, value):
        self.serviceTypeDef.insert(index, value)
    def replace_serviceTypeDef_at(self, index, value):
        self.serviceTypeDef[index] = value
    def _hasContent(self):
        if (
            self.typeParameter or
            self.serviceTypeDef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeParameters', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'typeParameters':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeParameters')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeParameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='typeParameters'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for typeParameter_ in self.typeParameter:
            namespaceprefix_ = self.typeParameter_nsprefix_ + ':' if (UseCapturedNS_ and self.typeParameter_nsprefix_) else ''
            typeParameter_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='typeParameter', pretty_print=pretty_print)
        for serviceTypeDef_ in self.serviceTypeDef:
            namespaceprefix_ = self.serviceTypeDef_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceTypeDef_nsprefix_) else ''
            serviceTypeDef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='serviceTypeDef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'typeParameter':
            obj_ = moduleParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeParameter.append(obj_)
            obj_.original_tagname_ = 'typeParameter'
        elif nodeName_ == 'serviceTypeDef':
            obj_ = serviceTypeDef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceTypeDef.append(obj_)
            obj_.original_tagname_ = 'serviceTypeDef'
# end class typeParameters


class transTypeDef(GeneratedsSuper):
    """typeName -- The name of the port type. Can be any predefined type such sc_port or sc_export in SystemC or any user-defined type such as tlm_port.
    typeDefinition -- Where the definition of the type is contained. For SystemC and SystemVerilog it is the include file containing the type definition.
    viewRef -- A reference to a view name in the file for which this type applies.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('typeName', 'typeNameType', 0, 1, {'minOccurs': '0', 'name': 'typeName', 'type': 'typeNameType'}, None),
        MemberSpec_('typeDefinition', 'typeDefinitionType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'typeDefinition', 'type': 'typeDefinitionType'}, None),
        MemberSpec_('typeParameters', 'typeParameters', 0, 1, {'minOccurs': '0', 'name': 'typeParameters', 'ref': 'typeParameters', 'type': 'typeParameters'}, None),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'viewRef', 'type': 'viewRefType10'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, typeName=None, typeDefinition=None, typeParameters=None, viewRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.typeName = typeName
        self.typeName_nsprefix_ = "ipxact"
        if typeDefinition is None:
            self.typeDefinition = []
        else:
            self.typeDefinition = typeDefinition
        self.typeDefinition_nsprefix_ = "ipxact"
        self.typeParameters = typeParameters
        self.typeParameters_nsprefix_ = "ipxact"
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.viewRef_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transTypeDef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transTypeDef.subclass:
            return transTypeDef.subclass(*args_, **kwargs_)
        else:
            return transTypeDef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_typeName(self):
        return self.typeName
    def set_typeName(self, typeName):
        self.typeName = typeName
    def get_typeDefinition(self):
        return self.typeDefinition
    def set_typeDefinition(self, typeDefinition):
        self.typeDefinition = typeDefinition
    def add_typeDefinition(self, value):
        self.typeDefinition.append(value)
    def insert_typeDefinition_at(self, index, value):
        self.typeDefinition.insert(index, value)
    def replace_typeDefinition_at(self, index, value):
        self.typeDefinition[index] = value
    def get_typeParameters(self):
        return self.typeParameters
    def set_typeParameters(self, typeParameters):
        self.typeParameters = typeParameters
    def get_viewRef(self):
        return self.viewRef
    def set_viewRef(self, viewRef):
        self.viewRef = viewRef
    def add_viewRef(self, value):
        self.viewRef.append(value)
    def insert_viewRef_at(self, index, value):
        self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value):
        self.viewRef[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.typeName is not None or
            self.typeDefinition or
            self.typeParameters is not None or
            self.viewRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transTypeDef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transTypeDef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'transTypeDef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transTypeDef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='transTypeDef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='transTypeDef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transTypeDef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.typeName is not None:
            namespaceprefix_ = self.typeName_nsprefix_ + ':' if (UseCapturedNS_ and self.typeName_nsprefix_) else ''
            self.typeName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeName', pretty_print=pretty_print)
        for typeDefinition_ in self.typeDefinition:
            namespaceprefix_ = self.typeDefinition_nsprefix_ + ':' if (UseCapturedNS_ and self.typeDefinition_nsprefix_) else ''
            typeDefinition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeDefinition', pretty_print=pretty_print)
        if self.typeParameters is not None:
            namespaceprefix_ = self.typeParameters_nsprefix_ + ':' if (UseCapturedNS_ and self.typeParameters_nsprefix_) else ''
            self.typeParameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='typeParameters', pretty_print=pretty_print)
        for viewRef_ in self.viewRef:
            namespaceprefix_ = self.viewRef_nsprefix_ + ':' if (UseCapturedNS_ and self.viewRef_nsprefix_) else ''
            viewRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='viewRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'typeName':
            obj_ = typeNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeName = obj_
            obj_.original_tagname_ = 'typeName'
        elif nodeName_ == 'typeDefinition':
            obj_ = typeDefinitionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeDefinition.append(obj_)
            obj_.original_tagname_ = 'typeDefinition'
        elif nodeName_ == 'typeParameters':
            obj_ = typeParameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeParameters = obj_
            obj_.original_tagname_ = 'typeParameters'
        elif nodeName_ == 'viewRef':
            obj_ = viewRefType10.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
# end class transTypeDef


class serviceTypeDef(GeneratedsSuper):
    """typeName -- The name of the service type. Can be any predefined type such as booean or integer or any user-defined type such as addr_type or data_type.
    typeDefinition -- Where the definition of the type is contained if the type if not part of the language. For SystemC and SystemVerilog it is the include file containing the type definition.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('typeName', 'typeNameType11', 0, 0, {'name': 'typeName', 'type': 'typeNameType11'}, None),
        MemberSpec_('typeDefinition', 'typeDefinitionType12', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'typeDefinition', 'type': 'typeDefinitionType12'}, None),
        MemberSpec_('typeParameters', 'typeParameters', 0, 1, {'minOccurs': '0', 'name': 'typeParameters', 'ref': 'typeParameters', 'type': 'typeParameters'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, typeName=None, typeDefinition=None, typeParameters=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.typeName = typeName
        self.typeName_nsprefix_ = "ipxact"
        if typeDefinition is None:
            self.typeDefinition = []
        else:
            self.typeDefinition = typeDefinition
        self.typeDefinition_nsprefix_ = "ipxact"
        self.typeParameters = typeParameters
        self.typeParameters_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serviceTypeDef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serviceTypeDef.subclass:
            return serviceTypeDef.subclass(*args_, **kwargs_)
        else:
            return serviceTypeDef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_typeName(self):
        return self.typeName
    def set_typeName(self, typeName):
        self.typeName = typeName
    def get_typeDefinition(self):
        return self.typeDefinition
    def set_typeDefinition(self, typeDefinition):
        self.typeDefinition = typeDefinition
    def add_typeDefinition(self, value):
        self.typeDefinition.append(value)
    def insert_typeDefinition_at(self, index, value):
        self.typeDefinition.insert(index, value)
    def replace_typeDefinition_at(self, index, value):
        self.typeDefinition[index] = value
    def get_typeParameters(self):
        return self.typeParameters
    def set_typeParameters(self, typeParameters):
        self.typeParameters = typeParameters
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.typeName is not None or
            self.typeDefinition or
            self.typeParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='serviceTypeDef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serviceTypeDef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'serviceTypeDef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='serviceTypeDef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='serviceTypeDef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='serviceTypeDef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='serviceTypeDef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.typeName is not None:
            namespaceprefix_ = self.typeName_nsprefix_ + ':' if (UseCapturedNS_ and self.typeName_nsprefix_) else ''
            self.typeName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeName', pretty_print=pretty_print)
        for typeDefinition_ in self.typeDefinition:
            namespaceprefix_ = self.typeDefinition_nsprefix_ + ':' if (UseCapturedNS_ and self.typeDefinition_nsprefix_) else ''
            typeDefinition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeDefinition', pretty_print=pretty_print)
        if self.typeParameters is not None:
            namespaceprefix_ = self.typeParameters_nsprefix_ + ':' if (UseCapturedNS_ and self.typeParameters_nsprefix_) else ''
            self.typeParameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='typeParameters', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'typeName':
            obj_ = typeNameType11.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeName = obj_
            obj_.original_tagname_ = 'typeName'
        elif nodeName_ == 'typeDefinition':
            obj_ = typeDefinitionType12.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeDefinition.append(obj_)
            obj_.original_tagname_ = 'typeDefinition'
        elif nodeName_ == 'typeParameters':
            obj_ = typeParameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeParameters = obj_
            obj_.original_tagname_ = 'typeParameters'
# end class serviceTypeDef


class wireTypeDef(GeneratedsSuper):
    """typeName -- The name of the logic type. Examples could be std_logic, std_ulogic, std_logic_vector, sc_logic, ...
    typeDefinition -- Where the definition of the type is contained. For std_logic, this is contained in IEEE.std_logic_1164.all. For sc_logic, this is contained in systemc.h. For VHDL this is the library and package as defined by the "used" statement. For SystemC and SystemVerilog it is the include file required. For verilog this is not needed.
    viewRef -- A reference to a view name in the file for which this type applies.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('typeName', 'typeNameType13', 0, 1, {'minOccurs': '0', 'name': 'typeName', 'type': 'typeNameType13'}, None),
        MemberSpec_('typeDefinition', 'typeDefinitionType14', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'typeDefinition', 'type': 'typeDefinitionType14'}, None),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'viewRef', 'type': 'viewRefType15'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, typeName=None, typeDefinition=None, viewRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.typeName = typeName
        self.typeName_nsprefix_ = "ipxact"
        if typeDefinition is None:
            self.typeDefinition = []
        else:
            self.typeDefinition = typeDefinition
        self.typeDefinition_nsprefix_ = "ipxact"
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.viewRef_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, wireTypeDef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if wireTypeDef.subclass:
            return wireTypeDef.subclass(*args_, **kwargs_)
        else:
            return wireTypeDef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_typeName(self):
        return self.typeName
    def set_typeName(self, typeName):
        self.typeName = typeName
    def get_typeDefinition(self):
        return self.typeDefinition
    def set_typeDefinition(self, typeDefinition):
        self.typeDefinition = typeDefinition
    def add_typeDefinition(self, value):
        self.typeDefinition.append(value)
    def insert_typeDefinition_at(self, index, value):
        self.typeDefinition.insert(index, value)
    def replace_typeDefinition_at(self, index, value):
        self.typeDefinition[index] = value
    def get_viewRef(self):
        return self.viewRef
    def set_viewRef(self, viewRef):
        self.viewRef = viewRef
    def add_viewRef(self, value):
        self.viewRef.append(value)
    def insert_viewRef_at(self, index, value):
        self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value):
        self.viewRef[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.typeName is not None or
            self.typeDefinition or
            self.viewRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='wireTypeDef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('wireTypeDef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'wireTypeDef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='wireTypeDef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='wireTypeDef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='wireTypeDef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='wireTypeDef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.typeName is not None:
            namespaceprefix_ = self.typeName_nsprefix_ + ':' if (UseCapturedNS_ and self.typeName_nsprefix_) else ''
            self.typeName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeName', pretty_print=pretty_print)
        for typeDefinition_ in self.typeDefinition:
            namespaceprefix_ = self.typeDefinition_nsprefix_ + ':' if (UseCapturedNS_ and self.typeDefinition_nsprefix_) else ''
            typeDefinition_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='typeDefinition', pretty_print=pretty_print)
        for viewRef_ in self.viewRef:
            namespaceprefix_ = self.viewRef_nsprefix_ + ':' if (UseCapturedNS_ and self.viewRef_nsprefix_) else ''
            viewRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='viewRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'typeName':
            obj_ = typeNameType13.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeName = obj_
            obj_.original_tagname_ = 'typeName'
        elif nodeName_ == 'typeDefinition':
            obj_ = typeDefinitionType14.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.typeDefinition.append(obj_)
            obj_.original_tagname_ = 'typeDefinition'
        elif nodeName_ == 'viewRef':
            obj_ = viewRefType15.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
# end class wireTypeDef


class serviceTypeDefs(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('serviceTypeDef', 'serviceTypeDef', 1, 0, {'maxOccurs': 'unbounded', 'name': 'serviceTypeDef', 'ref': 'serviceTypeDef', 'type': 'serviceTypeDef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, serviceTypeDef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if serviceTypeDef is None:
            self.serviceTypeDef = []
        else:
            self.serviceTypeDef = serviceTypeDef
        self.serviceTypeDef_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serviceTypeDefs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serviceTypeDefs.subclass:
            return serviceTypeDefs.subclass(*args_, **kwargs_)
        else:
            return serviceTypeDefs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_serviceTypeDef(self):
        return self.serviceTypeDef
    def set_serviceTypeDef(self, serviceTypeDef):
        self.serviceTypeDef = serviceTypeDef
    def add_serviceTypeDef(self, value):
        self.serviceTypeDef.append(value)
    def insert_serviceTypeDef_at(self, index, value):
        self.serviceTypeDef.insert(index, value)
    def replace_serviceTypeDef_at(self, index, value):
        self.serviceTypeDef[index] = value
    def _hasContent(self):
        if (
            self.serviceTypeDef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='serviceTypeDefs', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serviceTypeDefs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'serviceTypeDefs':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='serviceTypeDefs')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='serviceTypeDefs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='serviceTypeDefs'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='serviceTypeDefs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for serviceTypeDef_ in self.serviceTypeDef:
            namespaceprefix_ = self.serviceTypeDef_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceTypeDef_nsprefix_) else ''
            serviceTypeDef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='serviceTypeDef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'serviceTypeDef':
            obj_ = serviceTypeDef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceTypeDef.append(obj_)
            obj_.original_tagname_ = 'serviceTypeDef'
# end class serviceTypeDefs


class wireTypeDefs(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('wireTypeDef', 'wireTypeDef', 1, 0, {'maxOccurs': 'unbounded', 'name': 'wireTypeDef', 'ref': 'wireTypeDef', 'type': 'wireTypeDef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, wireTypeDef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if wireTypeDef is None:
            self.wireTypeDef = []
        else:
            self.wireTypeDef = wireTypeDef
        self.wireTypeDef_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, wireTypeDefs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if wireTypeDefs.subclass:
            return wireTypeDefs.subclass(*args_, **kwargs_)
        else:
            return wireTypeDefs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_wireTypeDef(self):
        return self.wireTypeDef
    def set_wireTypeDef(self, wireTypeDef):
        self.wireTypeDef = wireTypeDef
    def add_wireTypeDef(self, value):
        self.wireTypeDef.append(value)
    def insert_wireTypeDef_at(self, index, value):
        self.wireTypeDef.insert(index, value)
    def replace_wireTypeDef_at(self, index, value):
        self.wireTypeDef[index] = value
    def _hasContent(self):
        if (
            self.wireTypeDef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='wireTypeDefs', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('wireTypeDefs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'wireTypeDefs':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='wireTypeDefs')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='wireTypeDefs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='wireTypeDefs'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='wireTypeDefs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for wireTypeDef_ in self.wireTypeDef:
            namespaceprefix_ = self.wireTypeDef_nsprefix_ + ':' if (UseCapturedNS_ and self.wireTypeDef_nsprefix_) else ''
            wireTypeDef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='wireTypeDef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'wireTypeDef':
            obj_ = wireTypeDef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wireTypeDef.append(obj_)
            obj_.original_tagname_ = 'wireTypeDef'
# end class wireTypeDefs


class transTypeDefs(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('transTypeDef', 'transTypeDef', 1, 0, {'maxOccurs': 'unbounded', 'name': 'transTypeDef', 'ref': 'transTypeDef', 'type': 'transTypeDef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, transTypeDef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if transTypeDef is None:
            self.transTypeDef = []
        else:
            self.transTypeDef = transTypeDef
        self.transTypeDef_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transTypeDefs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transTypeDefs.subclass:
            return transTypeDefs.subclass(*args_, **kwargs_)
        else:
            return transTypeDefs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_transTypeDef(self):
        return self.transTypeDef
    def set_transTypeDef(self, transTypeDef):
        self.transTypeDef = transTypeDef
    def add_transTypeDef(self, value):
        self.transTypeDef.append(value)
    def insert_transTypeDef_at(self, index, value):
        self.transTypeDef.insert(index, value)
    def replace_transTypeDef_at(self, index, value):
        self.transTypeDef[index] = value
    def _hasContent(self):
        if (
            self.transTypeDef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transTypeDefs', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transTypeDefs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'transTypeDefs':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transTypeDefs')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='transTypeDefs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='transTypeDefs'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transTypeDefs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for transTypeDef_ in self.transTypeDef:
            namespaceprefix_ = self.transTypeDef_nsprefix_ + ':' if (UseCapturedNS_ and self.transTypeDef_nsprefix_) else ''
            transTypeDef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='transTypeDef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'transTypeDef':
            obj_ = transTypeDef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transTypeDef.append(obj_)
            obj_.original_tagname_ = 'transTypeDef'
# end class transTypeDefs


class PortWire(GeneratedsSuper):
    """direction -- The direction of a wire style port. The basic directions for a port are 'in' for input ports, 'out' for output port and 'inout' for bidirectional and tristate ports.
    A value of 'phantom' is also allowed and define a port that exist on the IP-XACT component but not on the HDL model.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('allLogicalDirectionsAllowed', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'allLogicalDirectionsAllowed'}),
        MemberSpec_('direction', ['componentPortDirectionType', 'xs:token'], 0, 0, {'name': 'direction', 'type': 'xs:token'}, None),
        MemberSpec_('Vectors', 'vectors', 0, 1, {'minOccurs': '0', 'name': 'vectors', 'ref': 'vectors', 'type': 'vectors'}, None),
        MemberSpec_('wireTypeDefs', 'wireTypeDefs', 0, 1, {'minOccurs': '0', 'name': 'wireTypeDefs', 'ref': 'wireTypeDefs', 'type': 'wireTypeDefs'}, None),
        MemberSpec_('drivers', 'drivers', 0, 1, {'minOccurs': '0', 'name': 'drivers', 'ref': 'drivers', 'type': 'drivers'}, None),
        MemberSpec_('constraintSets', 'constraintSets', 0, 1, {'minOccurs': '0', 'name': 'constraintSets', 'ref': 'constraintSets', 'type': 'constraintSets'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, allLogicalDirectionsAllowed=False, direction=None, Vectors=None, wireTypeDefs=None, drivers=None, constraintSets=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.allLogicalDirectionsAllowed = _cast(bool, allLogicalDirectionsAllowed)
        self.allLogicalDirectionsAllowed_nsprefix_ = None
        self.direction = direction
        self.validate_componentPortDirectionType(self.direction)
        self.direction_nsprefix_ = "ipxact"
        self.Vectors = Vectors
        self.Vectors_nsprefix_ = "ipxact"
        self.wireTypeDefs = wireTypeDefs
        self.wireTypeDefs_nsprefix_ = "ipxact"
        self.drivers = drivers
        self.drivers_nsprefix_ = "ipxact"
        self.constraintSets = constraintSets
        self.constraintSets_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortWire)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortWire.subclass:
            return PortWire.subclass(*args_, **kwargs_)
        else:
            return PortWire(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_vectors(self):
        return self.Vectors
    def set_vectors(self, Vectors):
        self.Vectors = Vectors
    def get_wireTypeDefs(self):
        return self.wireTypeDefs
    def set_wireTypeDefs(self, wireTypeDefs):
        self.wireTypeDefs = wireTypeDefs
    def get_drivers(self):
        return self.drivers
    def set_drivers(self, drivers):
        self.drivers = drivers
    def get_constraintSets(self):
        return self.constraintSets
    def set_constraintSets(self, constraintSets):
        self.constraintSets = constraintSets
    def get_allLogicalDirectionsAllowed(self):
        return self.allLogicalDirectionsAllowed
    def set_allLogicalDirectionsAllowed(self, allLogicalDirectionsAllowed):
        self.allLogicalDirectionsAllowed = allLogicalDirectionsAllowed
    def validate_componentPortDirectionType(self, value):
        result = True
        # Validate type componentPortDirectionType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['in', 'out', 'inout', 'phantom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on componentPortDirectionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.direction is not None or
            self.Vectors is not None or
            self.wireTypeDefs is not None or
            self.drivers is not None or
            self.constraintSets is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portWireType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portWireType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'portWireType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='portWireType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='portWireType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='portWireType'):
        if self.allLogicalDirectionsAllowed and 'allLogicalDirectionsAllowed' not in already_processed:
            already_processed.add('allLogicalDirectionsAllowed')
            outfile.write(' allLogicalDirectionsAllowed="%s"' % self.gds_format_boolean(self.allLogicalDirectionsAllowed, input_name='allLogicalDirectionsAllowed'))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portWireType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.direction is not None:
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), namespaceprefix_ , eol_))
        if self.Vectors is not None:
            namespaceprefix_ = self.Vectors_nsprefix_ + ':' if (UseCapturedNS_ and self.Vectors_nsprefix_) else ''
            self.Vectors.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vectors', pretty_print=pretty_print)
        if self.wireTypeDefs is not None:
            namespaceprefix_ = self.wireTypeDefs_nsprefix_ + ':' if (UseCapturedNS_ and self.wireTypeDefs_nsprefix_) else ''
            self.wireTypeDefs.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='wireTypeDefs', pretty_print=pretty_print)
        if self.drivers is not None:
            namespaceprefix_ = self.drivers_nsprefix_ + ':' if (UseCapturedNS_ and self.drivers_nsprefix_) else ''
            self.drivers.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='drivers', pretty_print=pretty_print)
        if self.constraintSets is not None:
            namespaceprefix_ = self.constraintSets_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintSets_nsprefix_) else ''
            self.constraintSets.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='constraintSets', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('allLogicalDirectionsAllowed', node)
        if value is not None and 'allLogicalDirectionsAllowed' not in already_processed:
            already_processed.add('allLogicalDirectionsAllowed')
            if value in ('true', '1'):
                self.allLogicalDirectionsAllowed = True
            elif value in ('false', '0'):
                self.allLogicalDirectionsAllowed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'direction':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'direction')
            value_ = self.gds_validate_string(value_, node, 'direction')
            self.direction = value_
            self.direction_nsprefix_ = child_.prefix
            # validate type componentPortDirectionType
            self.validate_componentPortDirectionType(self.direction)
        elif nodeName_ == 'vectors':
            obj_ = Vectors.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Vectors = obj_
            obj_.original_tagname_ = 'vectors'
        elif nodeName_ == 'wireTypeDefs':
            obj_ = wireTypeDefs.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wireTypeDefs = obj_
            obj_.original_tagname_ = 'wireTypeDefs'
        elif nodeName_ == 'drivers':
            obj_ = drivers.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drivers = obj_
            obj_.original_tagname_ = 'drivers'
        elif nodeName_ == 'constraintSets':
            obj_ = constraintSets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constraintSets = obj_
            obj_.original_tagname_ = 'constraintSets'
# end class PortWire


class portTransactionalType(GeneratedsSuper):
    """initiative -- Defines how the port accesses this service.
    kind -- Define the kind of transactional port
    busWidth -- Defines the bus width in bits.This can be the result of an expression.
    protocol -- Defines the protocol type. Defaults to tlm_base_protocol_type for TLM sockets
    transTypeDefs -- Definition of the port type expressed in the default language for this port (i.e. SystemC or SystemV).
    connection -- Bounds number of legal connections.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('allLogicalInitiativesAllowed', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'allLogicalInitiativesAllowed'}),
        MemberSpec_('initiative', 'initiativeType', 0, 0, {'name': 'initiative', 'ref': 'initiative', 'type': 'initiative'}, None),
        MemberSpec_('kind', 'kind', 0, 1, {'minOccurs': '0', 'name': 'kind', 'ref': 'kind', 'type': 'kind'}, None),
        MemberSpec_('busWidth', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'name': 'busWidth', 'ref': 'busWidth', 'type': 'busWidth'}, None),
        MemberSpec_('protocol', 'protocol', 0, 1, {'minOccurs': '0', 'name': 'protocol', 'ref': 'protocol', 'type': 'protocol'}, None),
        MemberSpec_('transTypeDefs', 'transTypeDefs', 0, 1, {'minOccurs': '0', 'name': 'transTypeDefs', 'ref': 'transTypeDefs', 'type': 'transTypeDefs'}, None),
        MemberSpec_('connection', 'connectionType', 0, 1, {'minOccurs': '0', 'name': 'connection', 'type': 'connectionType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, allLogicalInitiativesAllowed=False, initiative=None, kind=None, busWidth=None, protocol=None, transTypeDefs=None, connection=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.allLogicalInitiativesAllowed = _cast(bool, allLogicalInitiativesAllowed)
        self.allLogicalInitiativesAllowed_nsprefix_ = None
        self.initiative = initiative
        self.initiative_nsprefix_ = "ipxact"
        self.kind = kind
        self.kind_nsprefix_ = "ipxact"
        self.busWidth = busWidth
        self.busWidth_nsprefix_ = "ipxact"
        self.protocol = protocol
        self.protocol_nsprefix_ = "ipxact"
        self.transTypeDefs = transTypeDefs
        self.transTypeDefs_nsprefix_ = "ipxact"
        self.connection = connection
        self.connection_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portTransactionalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portTransactionalType.subclass:
            return portTransactionalType.subclass(*args_, **kwargs_)
        else:
            return portTransactionalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_initiative(self):
        return self.initiative
    def set_initiative(self, initiative):
        self.initiative = initiative
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def get_busWidth(self):
        return self.busWidth
    def set_busWidth(self, busWidth):
        self.busWidth = busWidth
    def get_protocol(self):
        return self.protocol
    def set_protocol(self, protocol):
        self.protocol = protocol
    def get_transTypeDefs(self):
        return self.transTypeDefs
    def set_transTypeDefs(self, transTypeDefs):
        self.transTypeDefs = transTypeDefs
    def get_connection(self):
        return self.connection
    def set_connection(self, connection):
        self.connection = connection
    def get_allLogicalInitiativesAllowed(self):
        return self.allLogicalInitiativesAllowed
    def set_allLogicalInitiativesAllowed(self, allLogicalInitiativesAllowed):
        self.allLogicalInitiativesAllowed = allLogicalInitiativesAllowed
    def _hasContent(self):
        if (
            self.initiative is not None or
            self.kind is not None or
            self.busWidth is not None or
            self.protocol is not None or
            self.transTypeDefs is not None or
            self.connection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portTransactionalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portTransactionalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'portTransactionalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='portTransactionalType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='portTransactionalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='portTransactionalType'):
        if self.allLogicalInitiativesAllowed and 'allLogicalInitiativesAllowed' not in already_processed:
            already_processed.add('allLogicalInitiativesAllowed')
            outfile.write(' allLogicalInitiativesAllowed="%s"' % self.gds_format_boolean(self.allLogicalInitiativesAllowed, input_name='allLogicalInitiativesAllowed'))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portTransactionalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initiative is not None:
            namespaceprefix_ = self.initiative_nsprefix_ + ':' if (UseCapturedNS_ and self.initiative_nsprefix_) else ''
            self.initiative.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='initiative', pretty_print=pretty_print)
        if self.kind is not None:
            namespaceprefix_ = self.kind_nsprefix_ + ':' if (UseCapturedNS_ and self.kind_nsprefix_) else ''
            self.kind.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='kind', pretty_print=pretty_print)
        if self.busWidth is not None:
            namespaceprefix_ = self.busWidth_nsprefix_ + ':' if (UseCapturedNS_ and self.busWidth_nsprefix_) else ''
            self.busWidth.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='busWidth', pretty_print=pretty_print)
        if self.protocol is not None:
            namespaceprefix_ = self.protocol_nsprefix_ + ':' if (UseCapturedNS_ and self.protocol_nsprefix_) else ''
            self.protocol.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='protocol', pretty_print=pretty_print)
        if self.transTypeDefs is not None:
            namespaceprefix_ = self.transTypeDefs_nsprefix_ + ':' if (UseCapturedNS_ and self.transTypeDefs_nsprefix_) else ''
            self.transTypeDefs.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='transTypeDefs', pretty_print=pretty_print)
        if self.connection is not None:
            namespaceprefix_ = self.connection_nsprefix_ + ':' if (UseCapturedNS_ and self.connection_nsprefix_) else ''
            self.connection.export(outfile, level, namespaceprefix_, namespacedef_='', name_='connection', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('allLogicalInitiativesAllowed', node)
        if value is not None and 'allLogicalInitiativesAllowed' not in already_processed:
            already_processed.add('allLogicalInitiativesAllowed')
            if value in ('true', '1'):
                self.allLogicalInitiativesAllowed = True
            elif value in ('false', '0'):
                self.allLogicalInitiativesAllowed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'initiative':
            obj_ = initiativeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.initiative = obj_
            obj_.original_tagname_ = 'initiative'
        elif nodeName_ == 'kind':
            obj_ = kind.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'busWidth':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.busWidth = obj_
            obj_.original_tagname_ = 'busWidth'
        elif nodeName_ == 'protocol':
            obj_ = protocol.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocol = obj_
            obj_.original_tagname_ = 'protocol'
        elif nodeName_ == 'transTypeDefs':
            obj_ = transTypeDefs.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transTypeDefs = obj_
            obj_.original_tagname_ = 'transTypeDefs'
        elif nodeName_ == 'connection':
            obj_ = connectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.connection = obj_
            obj_.original_tagname_ = 'connection'
# end class portTransactionalType


class abstractorPortWireType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('direction', ['componentPortDirectionType', 'xs:token'], 0, 0, {'name': 'direction', 'type': 'xs:token'}, None),
        MemberSpec_('Vectors', 'vectors', 0, 1, {'minOccurs': '0', 'name': 'vectors', 'ref': 'vectors', 'type': 'vectors'}, None),
        MemberSpec_('wireTypeDefs', 'wireTypeDefs', 0, 1, {'minOccurs': '0', 'name': 'wireTypeDefs', 'ref': 'wireTypeDefs', 'type': 'wireTypeDefs'}, None),
        MemberSpec_('drivers', 'drivers', 0, 1, {'minOccurs': '0', 'name': 'drivers', 'ref': 'drivers', 'type': 'drivers'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, direction=None, Vectors=None, wireTypeDefs=None, drivers=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.direction = direction
        self.validate_componentPortDirectionType(self.direction)
        self.direction_nsprefix_ = "ipxact"
        self.Vectors = Vectors
        self.Vectors_nsprefix_ = "ipxact"
        self.wireTypeDefs = wireTypeDefs
        self.wireTypeDefs_nsprefix_ = "ipxact"
        self.drivers = drivers
        self.drivers_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorPortWireType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorPortWireType.subclass:
            return abstractorPortWireType.subclass(*args_, **kwargs_)
        else:
            return abstractorPortWireType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_vectors(self):
        return self.Vectors
    def set_vectors(self, Vectors):
        self.Vectors = Vectors
    def get_wireTypeDefs(self):
        return self.wireTypeDefs
    def set_wireTypeDefs(self, wireTypeDefs):
        self.wireTypeDefs = wireTypeDefs
    def get_drivers(self):
        return self.drivers
    def set_drivers(self, drivers):
        self.drivers = drivers
    def validate_componentPortDirectionType(self, value):
        result = True
        # Validate type componentPortDirectionType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['in', 'out', 'inout', 'phantom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on componentPortDirectionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.direction is not None or
            self.Vectors is not None or
            self.wireTypeDefs is not None or
            self.drivers is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorPortWireType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorPortWireType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractorPortWireType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractorPortWireType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractorPortWireType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='abstractorPortWireType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorPortWireType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.direction is not None:
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), namespaceprefix_ , eol_))
        if self.Vectors is not None:
            namespaceprefix_ = self.Vectors_nsprefix_ + ':' if (UseCapturedNS_ and self.Vectors_nsprefix_) else ''
            self.Vectors.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vectors', pretty_print=pretty_print)
        if self.wireTypeDefs is not None:
            namespaceprefix_ = self.wireTypeDefs_nsprefix_ + ':' if (UseCapturedNS_ and self.wireTypeDefs_nsprefix_) else ''
            self.wireTypeDefs.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='wireTypeDefs', pretty_print=pretty_print)
        if self.drivers is not None:
            namespaceprefix_ = self.drivers_nsprefix_ + ':' if (UseCapturedNS_ and self.drivers_nsprefix_) else ''
            self.drivers.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='drivers', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'direction':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'direction')
            value_ = self.gds_validate_string(value_, node, 'direction')
            self.direction = value_
            self.direction_nsprefix_ = child_.prefix
            # validate type componentPortDirectionType
            self.validate_componentPortDirectionType(self.direction)
        elif nodeName_ == 'vectors':
            obj_ = Vectors.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Vectors = obj_
            obj_.original_tagname_ = 'vectors'
        elif nodeName_ == 'wireTypeDefs':
            obj_ = wireTypeDefs.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wireTypeDefs = obj_
            obj_.original_tagname_ = 'wireTypeDefs'
        elif nodeName_ == 'drivers':
            obj_ = drivers.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.drivers = obj_
            obj_.original_tagname_ = 'drivers'
# end class abstractorPortWireType


class portAccessType(GeneratedsSuper):
    """portAccessType -- Indicates how a netlister accesses a port. 'ref' means accessed by reference (default) and 'ptr' means accessed through a pointer.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('portAccessType', 'portAccessType', 0, 1, {'minOccurs': '0', 'name': 'portAccessType', 'ref': 'portAccessType', 'type': 'portAccessType'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, portAccessType_member=None, accessHandles=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.portAccessType = portAccessType_member
        self.portAccessType_nsprefix_ = "ipxact"
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portAccessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portAccessType.subclass:
            return portAccessType.subclass(*args_, **kwargs_)
        else:
            return portAccessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_portAccessType(self):
        return self.portAccessType
    def set_portAccessType(self, portAccessType):
        self.portAccessType = portAccessType
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def _hasContent(self):
        if (
            self.portAccessType is not None or
            self.accessHandles is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portAccessType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portAccessType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'portAccessType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='portAccessType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='portAccessType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='portAccessType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portAccessType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.portAccessType is not None:
            namespaceprefix_ = self.portAccessType_nsprefix_ + ':' if (UseCapturedNS_ and self.portAccessType_nsprefix_) else ''
            self.portAccessType.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='portAccessType', pretty_print=pretty_print)
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'portAccessType':
            obj_ = portAccessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.portAccessType = obj_
            obj_.original_tagname_ = 'portAccessType'
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
# end class portAccessType


class otherClocks(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('otherClockDriver', 'otherClockDriver', 1, 0, {'maxOccurs': 'unbounded', 'name': 'otherClockDriver', 'ref': 'otherClockDriver', 'type': 'otherClockDriver'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, otherClockDriver=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if otherClockDriver is None:
            self.otherClockDriver = []
        else:
            self.otherClockDriver = otherClockDriver
        self.otherClockDriver_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, otherClocks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if otherClocks.subclass:
            return otherClocks.subclass(*args_, **kwargs_)
        else:
            return otherClocks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_otherClockDriver(self):
        return self.otherClockDriver
    def set_otherClockDriver(self, otherClockDriver):
        self.otherClockDriver = otherClockDriver
    def add_otherClockDriver(self, value):
        self.otherClockDriver.append(value)
    def insert_otherClockDriver_at(self, index, value):
        self.otherClockDriver.insert(index, value)
    def replace_otherClockDriver_at(self, index, value):
        self.otherClockDriver[index] = value
    def _hasContent(self):
        if (
            self.otherClockDriver
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='otherClocks', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('otherClocks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'otherClocks':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='otherClocks')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='otherClocks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='otherClocks'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='otherClocks', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for otherClockDriver_ in self.otherClockDriver:
            namespaceprefix_ = self.otherClockDriver_nsprefix_ + ':' if (UseCapturedNS_ and self.otherClockDriver_nsprefix_) else ''
            otherClockDriver_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='otherClockDriver', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'otherClockDriver':
            obj_ = otherClockDriver.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.otherClockDriver.append(obj_)
            obj_.original_tagname_ = 'otherClockDriver'
# end class otherClocks


class cellSpecification(GeneratedsSuper):
    """cellFunction -- Defines a technology library cell in library independent fashion, based on specification of a cell function and strength.
    cellClass -- Defines a technology library cell in library independent fashion, based on specification of a cell class and strength.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('cellStrength', 'ipxact:cellStrengthValueType', 0, 1, {'use': 'optional', 'name': 'cellStrength'}),
        MemberSpec_('cellFunction', 'cellFunctionType', 0, 0, {'name': 'cellFunction', 'type': 'cellFunctionType'}, 8),
        MemberSpec_('cellClass', ['cellClassValueType', 'xs:token'], 0, 0, {'name': 'cellClass', 'type': 'xs:token'}, 8),
    ]
    subclass = None
    superclass = None
    def __init__(self, cellStrength=None, cellFunction=None, cellClass=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.cellStrength = _cast(None, cellStrength)
        self.cellStrength_nsprefix_ = None
        self.cellFunction = cellFunction
        self.cellFunction_nsprefix_ = "ipxact"
        self.cellClass = cellClass
        self.validate_cellClassValueType(self.cellClass)
        self.cellClass_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cellSpecification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cellSpecification.subclass:
            return cellSpecification.subclass(*args_, **kwargs_)
        else:
            return cellSpecification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cellFunction(self):
        return self.cellFunction
    def set_cellFunction(self, cellFunction):
        self.cellFunction = cellFunction
    def get_cellClass(self):
        return self.cellClass
    def set_cellClass(self, cellClass):
        self.cellClass = cellClass
    def get_cellStrength(self):
        return self.cellStrength
    def set_cellStrength(self, cellStrength):
        self.cellStrength = cellStrength
    def validate_cellClassValueType(self, value):
        result = True
        # Validate type cellClassValueType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['combinational', 'sequential']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on cellClassValueType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_cellStrengthValueType(self, value):
        # Validate type ipxact:cellStrengthValueType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['low', 'median', 'high']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on cellStrengthValueType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.cellFunction is not None or
            self.cellClass is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='cellSpecification', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cellSpecification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cellSpecification':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cellSpecification')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cellSpecification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='cellSpecification'):
        if self.cellStrength is not None and 'cellStrength' not in already_processed:
            already_processed.add('cellStrength')
            outfile.write(' cellStrength=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.cellStrength), input_name='cellStrength')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='cellSpecification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cellFunction is not None:
            namespaceprefix_ = self.cellFunction_nsprefix_ + ':' if (UseCapturedNS_ and self.cellFunction_nsprefix_) else ''
            self.cellFunction.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cellFunction', pretty_print=pretty_print)
        if self.cellClass is not None:
            namespaceprefix_ = self.cellClass_nsprefix_ + ':' if (UseCapturedNS_ and self.cellClass_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scellClass>%s</%scellClass>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cellClass), input_name='cellClass')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cellStrength', node)
        if value is not None and 'cellStrength' not in already_processed:
            already_processed.add('cellStrength')
            self.cellStrength = value
            self.cellStrength = ' '.join(self.cellStrength.split())
            self.validate_cellStrengthValueType(self.cellStrength)    # validate type cellStrengthValueType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cellFunction':
            obj_ = cellFunctionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cellFunction = obj_
            obj_.original_tagname_ = 'cellFunction'
        elif nodeName_ == 'cellClass':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'cellClass')
            value_ = self.gds_validate_string(value_, node, 'cellClass')
            self.cellClass = value_
            self.cellClass_nsprefix_ = child_.prefix
            # validate type cellClassValueType
            self.validate_cellClassValueType(self.cellClass)
# end class cellSpecification


class timingConstraint(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('clockEdge', 'ipxact:edgeValueType', 0, 1, {'use': 'optional', 'name': 'clockEdge'}),
        MemberSpec_('delayType', 'ipxact:delayValueType', 0, 1, {'use': 'optional', 'name': 'delayType'}),
        MemberSpec_('clockName', 'ipxact:portName', 0, 0, {'use': 'required', 'name': 'clockName'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', ['delayPercentageType', 'xs:float'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, clockEdge=None, delayType=None, clockName=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.clockEdge = _cast(None, clockEdge)
        self.clockEdge_nsprefix_ = None
        self.delayType = _cast(None, delayType)
        self.delayType_nsprefix_ = None
        self.clockName = _cast(None, clockName)
        self.clockName_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, timingConstraint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if timingConstraint.subclass:
            return timingConstraint.subclass(*args_, **kwargs_)
        else:
            return timingConstraint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_clockEdge(self):
        return self.clockEdge
    def set_clockEdge(self, clockEdge):
        self.clockEdge = clockEdge
    def get_delayType(self):
        return self.delayType
    def set_delayType(self, delayType):
        self.delayType = delayType
    def get_clockName(self):
        return self.clockName
    def set_clockName(self, clockName):
        self.clockName = clockName
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_delayPercentageType(self, value):
        result = True
        # Validate type delayPercentageType, a restriction on xs:float.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, float):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (float)' % {"value": value, "lineno": lineno, })
                return False
            if value < 0.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on delayPercentageType' % {"value": value, "lineno": lineno} )
                result = False
            if value > 100.0:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on delayPercentageType' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_edgeValueType(self, value):
        # Validate type ipxact:edgeValueType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['rise', 'fall']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on edgeValueType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_delayValueType(self, value):
        # Validate type ipxact:delayValueType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['min', 'max']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on delayValueType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_portName(self, value):
        # Validate type ipxact:portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_portName_patterns_, ))
    validate_portName_patterns_ = [['^([A-Za-z0-9\\.\\-:_]*)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='timingConstraint', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('timingConstraint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'timingConstraint':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='timingConstraint')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='timingConstraint', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='timingConstraint'):
        if self.clockEdge is not None and 'clockEdge' not in already_processed:
            already_processed.add('clockEdge')
            outfile.write(' clockEdge=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clockEdge), input_name='clockEdge')), ))
        if self.delayType is not None and 'delayType' not in already_processed:
            already_processed.add('delayType')
            outfile.write(' delayType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.delayType), input_name='delayType')), ))
        if self.clockName is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            outfile.write(' clockName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clockName), input_name='clockName')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='timingConstraint', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clockEdge', node)
        if value is not None and 'clockEdge' not in already_processed:
            already_processed.add('clockEdge')
            self.clockEdge = value
            self.clockEdge = ' '.join(self.clockEdge.split())
            self.validate_edgeValueType(self.clockEdge)    # validate type edgeValueType
        value = find_attr_value_('delayType', node)
        if value is not None and 'delayType' not in already_processed:
            already_processed.add('delayType')
            self.delayType = value
            self.delayType = ' '.join(self.delayType.split())
            self.validate_delayValueType(self.delayType)    # validate type delayValueType
        value = find_attr_value_('clockName', node)
        if value is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            self.clockName = value
            self.validate_portName(self.clockName)    # validate type portName
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class timingConstraint


class driveConstraint(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('cellSpecification', 'cellSpecification', 0, 0, {'name': 'cellSpecification', 'ref': 'cellSpecification', 'type': 'cellSpecification'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cellSpecification=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.cellSpecification = cellSpecification
        self.cellSpecification_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, driveConstraint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if driveConstraint.subclass:
            return driveConstraint.subclass(*args_, **kwargs_)
        else:
            return driveConstraint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cellSpecification(self):
        return self.cellSpecification
    def set_cellSpecification(self, cellSpecification):
        self.cellSpecification = cellSpecification
    def _hasContent(self):
        if (
            self.cellSpecification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='driveConstraint', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('driveConstraint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'driveConstraint':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='driveConstraint')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='driveConstraint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='driveConstraint'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='driveConstraint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cellSpecification is not None:
            namespaceprefix_ = self.cellSpecification_nsprefix_ + ':' if (UseCapturedNS_ and self.cellSpecification_nsprefix_) else ''
            self.cellSpecification.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='cellSpecification', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cellSpecification':
            obj_ = cellSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cellSpecification = obj_
            obj_.original_tagname_ = 'cellSpecification'
# end class driveConstraint


class loadConstraint(GeneratedsSuper):
    """count -- Indicates how many loads of the specified cell are connected. If not present, 3 is assumed.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('cellSpecification', 'cellSpecification', 0, 0, {'name': 'cellSpecification', 'ref': 'cellSpecification', 'type': 'cellSpecification'}, None),
        MemberSpec_('count', 'unsignedPositiveIntExpression', 0, 1, {'default': '3', 'minOccurs': '0', 'name': 'count', 'type': 'unsignedPositiveIntExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cellSpecification=None, count=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.cellSpecification = cellSpecification
        self.cellSpecification_nsprefix_ = "ipxact"
        if count is None:
            self.count = globals()['unsignedPositiveIntExpression']('3')
        else:
            self.count = count
        self.count_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, loadConstraint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if loadConstraint.subclass:
            return loadConstraint.subclass(*args_, **kwargs_)
        else:
            return loadConstraint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cellSpecification(self):
        return self.cellSpecification
    def set_cellSpecification(self, cellSpecification):
        self.cellSpecification = cellSpecification
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def _hasContent(self):
        if (
            self.cellSpecification is not None or
            self.count is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='loadConstraint', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('loadConstraint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'loadConstraint':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='loadConstraint')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='loadConstraint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='loadConstraint'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='loadConstraint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cellSpecification is not None:
            namespaceprefix_ = self.cellSpecification_nsprefix_ + ':' if (UseCapturedNS_ and self.cellSpecification_nsprefix_) else ''
            self.cellSpecification.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='cellSpecification', pretty_print=pretty_print)
        if self.count is not None:
            namespaceprefix_ = self.count_nsprefix_ + ':' if (UseCapturedNS_ and self.count_nsprefix_) else ''
            self.count.export(outfile, level, namespaceprefix_, namespacedef_='', name_='count', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cellSpecification':
            obj_ = cellSpecification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cellSpecification = obj_
            obj_.original_tagname_ = 'cellSpecification'
        elif nodeName_ == 'count':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.count = obj_
            obj_.original_tagname_ = 'count'
# end class loadConstraint


class constraintSet(GeneratedsSuper):
    """name -- Unique name
    vector -- The optional element vector specify the bits of a vector for which the constraints apply. The vaules of left and right must be within the range of the port. If the vector is not specified then the constraints apply to all the bits of the port.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('constraintSetId', 'xs:NMTOKEN', 0, 1, {'use': 'optional', 'name': 'constraintSetId'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('Vector', 'vectorType', 0, 1, {'minOccurs': '0', 'name': 'vector', 'type': 'vectorType'}, None),
        MemberSpec_('driveConstraint', 'driveConstraint', 0, 1, {'minOccurs': '0', 'name': 'driveConstraint', 'ref': 'driveConstraint', 'type': 'driveConstraint'}, None),
        MemberSpec_('loadConstraint', 'loadConstraint', 0, 1, {'minOccurs': '0', 'name': 'loadConstraint', 'ref': 'loadConstraint', 'type': 'loadConstraint'}, None),
        MemberSpec_('timingConstraint', 'timingConstraint', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'timingConstraint', 'ref': 'timingConstraint', 'type': 'timingConstraint'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, constraintSetId='default', id=None, name=None, displayName=None, description=None, Vector=None, driveConstraint=None, loadConstraint=None, timingConstraint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.constraintSetId = _cast(None, constraintSetId)
        self.constraintSetId_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.Vector = Vector
        self.Vector_nsprefix_ = "ipxact"
        self.driveConstraint = driveConstraint
        self.driveConstraint_nsprefix_ = "ipxact"
        self.loadConstraint = loadConstraint
        self.loadConstraint_nsprefix_ = "ipxact"
        if timingConstraint is None:
            self.timingConstraint = []
        else:
            self.timingConstraint = timingConstraint
        self.timingConstraint_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, constraintSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if constraintSet.subclass:
            return constraintSet.subclass(*args_, **kwargs_)
        else:
            return constraintSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_vector(self):
        return self.Vector
    def set_vector(self, Vector):
        self.Vector = Vector
    def get_driveConstraint(self):
        return self.driveConstraint
    def set_driveConstraint(self, driveConstraint):
        self.driveConstraint = driveConstraint
    def get_loadConstraint(self):
        return self.loadConstraint
    def set_loadConstraint(self, loadConstraint):
        self.loadConstraint = loadConstraint
    def get_timingConstraint(self):
        return self.timingConstraint
    def set_timingConstraint(self, timingConstraint):
        self.timingConstraint = timingConstraint
    def add_timingConstraint(self, value):
        self.timingConstraint.append(value)
    def insert_timingConstraint_at(self, index, value):
        self.timingConstraint.insert(index, value)
    def replace_timingConstraint_at(self, index, value):
        self.timingConstraint[index] = value
    def get_constraintSetId(self):
        return self.constraintSetId
    def set_constraintSetId(self, constraintSetId):
        self.constraintSetId = constraintSetId
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.Vector is not None or
            self.driveConstraint is not None or
            self.loadConstraint is not None or
            self.timingConstraint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='constraintSet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('constraintSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'constraintSet':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='constraintSet')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='constraintSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='constraintSet'):
        if self.constraintSetId != "default" and 'constraintSetId' not in already_processed:
            already_processed.add('constraintSetId')
            outfile.write(' constraintSetId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.constraintSetId), input_name='constraintSetId')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='constraintSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.Vector is not None:
            namespaceprefix_ = self.Vector_nsprefix_ + ':' if (UseCapturedNS_ and self.Vector_nsprefix_) else ''
            self.Vector.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vector', pretty_print=pretty_print)
        if self.driveConstraint is not None:
            namespaceprefix_ = self.driveConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.driveConstraint_nsprefix_) else ''
            self.driveConstraint.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='driveConstraint', pretty_print=pretty_print)
        if self.loadConstraint is not None:
            namespaceprefix_ = self.loadConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.loadConstraint_nsprefix_) else ''
            self.loadConstraint.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='loadConstraint', pretty_print=pretty_print)
        for timingConstraint_ in self.timingConstraint:
            namespaceprefix_ = self.timingConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.timingConstraint_nsprefix_) else ''
            timingConstraint_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='timingConstraint', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('constraintSetId', node)
        if value is not None and 'constraintSetId' not in already_processed:
            already_processed.add('constraintSetId')
            self.constraintSetId = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'vector':
            obj_ = vectorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Vector = obj_
            obj_.original_tagname_ = 'vector'
        elif nodeName_ == 'driveConstraint':
            obj_ = driveConstraint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.driveConstraint = obj_
            obj_.original_tagname_ = 'driveConstraint'
        elif nodeName_ == 'loadConstraint':
            obj_ = loadConstraint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.loadConstraint = obj_
            obj_.original_tagname_ = 'loadConstraint'
        elif nodeName_ == 'timingConstraint':
            obj_ = timingConstraint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timingConstraint.append(obj_)
            obj_.original_tagname_ = 'timingConstraint'
# end class constraintSet


class constraintSets(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('constraintSet', 'constraintSet', 1, 0, {'maxOccurs': 'unbounded', 'name': 'constraintSet', 'ref': 'constraintSet', 'type': 'constraintSet'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, constraintSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if constraintSet is None:
            self.constraintSet = []
        else:
            self.constraintSet = constraintSet
        self.constraintSet_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, constraintSets)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if constraintSets.subclass:
            return constraintSets.subclass(*args_, **kwargs_)
        else:
            return constraintSets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constraintSet(self):
        return self.constraintSet
    def set_constraintSet(self, constraintSet):
        self.constraintSet = constraintSet
    def add_constraintSet(self, value):
        self.constraintSet.append(value)
    def insert_constraintSet_at(self, index, value):
        self.constraintSet.insert(index, value)
    def replace_constraintSet_at(self, index, value):
        self.constraintSet[index] = value
    def _hasContent(self):
        if (
            self.constraintSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='constraintSets', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('constraintSets')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'constraintSets':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='constraintSets')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='constraintSets', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='constraintSets'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='constraintSets', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for constraintSet_ in self.constraintSet:
            namespaceprefix_ = self.constraintSet_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintSet_nsprefix_) else ''
            constraintSet_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='constraintSet', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'constraintSet':
            obj_ = constraintSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constraintSet.append(obj_)
            obj_.original_tagname_ = 'constraintSet'
# end class constraintSets


class constraintSetRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('localName', 'xs:NMTOKEN', 0, 0, {'name': 'localName', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, localName=None, isPresent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.localName = localName
        self.localName_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, constraintSetRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if constraintSetRef.subclass:
            return constraintSetRef.subclass(*args_, **kwargs_)
        else:
            return constraintSetRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_localName(self):
        return self.localName
    def set_localName(self, localName):
        self.localName = localName
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.localName is not None or
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='constraintSetRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('constraintSetRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'constraintSetRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='constraintSetRef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='constraintSetRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='constraintSetRef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='constraintSetRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.localName is not None:
            namespaceprefix_ = self.localName_nsprefix_ + ':' if (UseCapturedNS_ and self.localName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocalName>%s</%slocalName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.localName), input_name='localName')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'localName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'localName')
            value_ = self.gds_validate_string(value_, node, 'localName')
            self.localName = value_
            self.localName_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class constraintSetRef


class abstractionDefPortConstraintsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('timingConstraint', 'timingConstraint', 1, 0, {'maxOccurs': 'unbounded', 'name': 'timingConstraint', 'ref': 'timingConstraint', 'type': 'timingConstraint'}, 9),
        MemberSpec_('driveConstraint', 'driveConstraint', 0, 0, {'name': 'driveConstraint', 'ref': 'driveConstraint', 'type': 'driveConstraint'}, 9),
        MemberSpec_('loadConstraint', 'loadConstraint', 0, 1, {'minOccurs': '0', 'name': 'loadConstraint', 'ref': 'loadConstraint', 'type': 'loadConstraint'}, 9),
        MemberSpec_('loadConstraint', 'loadConstraint', 0, 0, {'name': 'loadConstraint', 'ref': 'loadConstraint', 'type': 'loadConstraint'}, 9),
    ]
    subclass = None
    superclass = None
    def __init__(self, timingConstraint=None, driveConstraint=None, loadConstraint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if timingConstraint is None:
            self.timingConstraint = []
        else:
            self.timingConstraint = timingConstraint
        self.timingConstraint_nsprefix_ = "ipxact"
        self.driveConstraint = driveConstraint
        self.driveConstraint_nsprefix_ = "ipxact"
        self.loadConstraint = loadConstraint
        self.loadConstraint_nsprefix_ = "ipxact"
        self.loadConstraint = loadConstraint
        self.loadConstraint_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractionDefPortConstraintsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractionDefPortConstraintsType.subclass:
            return abstractionDefPortConstraintsType.subclass(*args_, **kwargs_)
        else:
            return abstractionDefPortConstraintsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_timingConstraint(self):
        return self.timingConstraint
    def set_timingConstraint(self, timingConstraint):
        self.timingConstraint = timingConstraint
    def add_timingConstraint(self, value):
        self.timingConstraint.append(value)
    def insert_timingConstraint_at(self, index, value):
        self.timingConstraint.insert(index, value)
    def replace_timingConstraint_at(self, index, value):
        self.timingConstraint[index] = value
    def get_driveConstraint(self):
        return self.driveConstraint
    def set_driveConstraint(self, driveConstraint):
        self.driveConstraint = driveConstraint
    def get_loadConstraint(self):
        return self.loadConstraint
    def set_loadConstraint(self, loadConstraint):
        self.loadConstraint = loadConstraint
    def get_loadConstraint(self):
        return self.loadConstraint
    def set_loadConstraint(self, loadConstraint):
        self.loadConstraint = loadConstraint
    def _hasContent(self):
        if (
            self.timingConstraint or
            self.driveConstraint is not None or
            self.loadConstraint is not None or
            self.loadConstraint is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractionDefPortConstraintsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractionDefPortConstraintsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractionDefPortConstraintsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractionDefPortConstraintsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractionDefPortConstraintsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='abstractionDefPortConstraintsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractionDefPortConstraintsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for timingConstraint_ in self.timingConstraint:
            namespaceprefix_ = self.timingConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.timingConstraint_nsprefix_) else ''
            timingConstraint_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='timingConstraint', pretty_print=pretty_print)
        if self.driveConstraint is not None:
            namespaceprefix_ = self.driveConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.driveConstraint_nsprefix_) else ''
            self.driveConstraint.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='driveConstraint', pretty_print=pretty_print)
        if self.loadConstraint is not None:
            namespaceprefix_ = self.loadConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.loadConstraint_nsprefix_) else ''
            self.loadConstraint.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='loadConstraint', pretty_print=pretty_print)
        if self.loadConstraint is not None:
            namespaceprefix_ = self.loadConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.loadConstraint_nsprefix_) else ''
            self.loadConstraint.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='loadConstraint', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'timingConstraint':
            obj_ = timingConstraint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timingConstraint.append(obj_)
            obj_.original_tagname_ = 'timingConstraint'
        elif nodeName_ == 'driveConstraint':
            obj_ = driveConstraint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.driveConstraint = obj_
            obj_.original_tagname_ = 'driveConstraint'
        elif nodeName_ == 'loadConstraint':
            obj_ = loadConstraint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.loadConstraint = obj_
            obj_.original_tagname_ = 'loadConstraint'
        elif nodeName_ == 'loadConstraint':
            obj_ = loadConstraint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.loadConstraint = obj_
            obj_.original_tagname_ = 'loadConstraint'
# end class abstractionDefPortConstraintsType


class singleShotDriver(GeneratedsSuper):
    """singleShotOffset -- Time in nanoseconds until start of one-shot.
    singleShotValue -- Value of port after first  edge of one-shot.
    singleShotDuration -- Duration in nanoseconds of the one shot.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('singleShotOffset', 'realExpression', 0, 0, {'name': 'singleShotOffset', 'type': 'realExpression'}, None),
        MemberSpec_('singleShotValue', 'unsignedBitVectorExpression', 0, 0, {'name': 'singleShotValue', 'type': 'unsignedBitVectorExpression'}, None),
        MemberSpec_('singleShotDuration', 'realExpression', 0, 0, {'name': 'singleShotDuration', 'type': 'realExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, singleShotOffset=None, singleShotValue=None, singleShotDuration=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.singleShotOffset = singleShotOffset
        self.singleShotOffset_nsprefix_ = "ipxact"
        self.singleShotValue = singleShotValue
        self.singleShotValue_nsprefix_ = "ipxact"
        self.singleShotDuration = singleShotDuration
        self.singleShotDuration_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, singleShotDriver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if singleShotDriver.subclass:
            return singleShotDriver.subclass(*args_, **kwargs_)
        else:
            return singleShotDriver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_singleShotOffset(self):
        return self.singleShotOffset
    def set_singleShotOffset(self, singleShotOffset):
        self.singleShotOffset = singleShotOffset
    def get_singleShotValue(self):
        return self.singleShotValue
    def set_singleShotValue(self, singleShotValue):
        self.singleShotValue = singleShotValue
    def get_singleShotDuration(self):
        return self.singleShotDuration
    def set_singleShotDuration(self, singleShotDuration):
        self.singleShotDuration = singleShotDuration
    def _hasContent(self):
        if (
            self.singleShotOffset is not None or
            self.singleShotValue is not None or
            self.singleShotDuration is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='singleShotDriver', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('singleShotDriver')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'singleShotDriver':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='singleShotDriver')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='singleShotDriver', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='singleShotDriver'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='singleShotDriver', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.singleShotOffset is not None:
            namespaceprefix_ = self.singleShotOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.singleShotOffset_nsprefix_) else ''
            self.singleShotOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='singleShotOffset', pretty_print=pretty_print)
        if self.singleShotValue is not None:
            namespaceprefix_ = self.singleShotValue_nsprefix_ + ':' if (UseCapturedNS_ and self.singleShotValue_nsprefix_) else ''
            self.singleShotValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='singleShotValue', pretty_print=pretty_print)
        if self.singleShotDuration is not None:
            namespaceprefix_ = self.singleShotDuration_nsprefix_ + ':' if (UseCapturedNS_ and self.singleShotDuration_nsprefix_) else ''
            self.singleShotDuration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='singleShotDuration', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'singleShotOffset':
            class_obj_ = self.get_class_obj_(child_, realExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.singleShotOffset = obj_
            obj_.original_tagname_ = 'singleShotOffset'
        elif nodeName_ == 'singleShotValue':
            obj_ = unsignedBitVectorExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.singleShotValue = obj_
            obj_.original_tagname_ = 'singleShotValue'
        elif nodeName_ == 'singleShotDuration':
            class_obj_ = self.get_class_obj_(child_, realExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.singleShotDuration = obj_
            obj_.original_tagname_ = 'singleShotDuration'
# end class singleShotDriver


class requiresDriver(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('driverType', 'driverTypeType', 0, 1, {'use': 'optional', 'name': 'driverType'}),
        MemberSpec_('valueOf_', 'xs:boolean', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, driverType='any', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.driverType = _cast(None, driverType)
        self.driverType_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, requiresDriver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if requiresDriver.subclass:
            return requiresDriver.subclass(*args_, **kwargs_)
        else:
            return requiresDriver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_driverType(self):
        return self.driverType
    def set_driverType(self, driverType):
        self.driverType = driverType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_driverTypeType(self, value):
        # Validate type driverTypeType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['clock', 'singleShot', 'any']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on driverTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='requiresDriver', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('requiresDriver')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'requiresDriver':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='requiresDriver')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='requiresDriver', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='requiresDriver'):
        if self.driverType != "any" and 'driverType' not in already_processed:
            already_processed.add('driverType')
            outfile.write(' driverType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.driverType), input_name='driverType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='requiresDriver', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('driverType', node)
        if value is not None and 'driverType' not in already_processed:
            already_processed.add('driverType')
            self.driverType = value
            self.driverType = ' '.join(self.driverType.split())
            self.validate_driverTypeType(self.driverType)    # validate type driverTypeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class requiresDriver


class driverType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('Range', 'range', 0, 1, {'minOccurs': '0', 'name': 'range', 'ref': 'range', 'type': 'range'}, None),
        MemberSpec_('defaultValue', 'unsignedBitVectorExpression', 0, 1, {'minOccurs': '0', 'name': 'defaultValue', 'ref': 'defaultValue', 'type': 'defaultValue'}, 10),
        MemberSpec_('clockDriver', 'clockDriver', 0, 1, {'minOccurs': '0', 'name': 'clockDriver', 'ref': 'clockDriver', 'type': 'clockDriver'}, 10),
        MemberSpec_('singleShotDriver', 'singleShotDriver', 0, 1, {'minOccurs': '0', 'name': 'singleShotDriver', 'ref': 'singleShotDriver', 'type': 'singleShotDriver'}, 10),
    ]
    subclass = None
    superclass = None
    def __init__(self, Range=None, defaultValue=None, clockDriver=None, singleShotDriver=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.Range = Range
        self.Range_nsprefix_ = "ipxact"
        self.defaultValue = defaultValue
        self.defaultValue_nsprefix_ = "ipxact"
        self.clockDriver = clockDriver
        self.clockDriver_nsprefix_ = "ipxact"
        self.singleShotDriver = singleShotDriver
        self.singleShotDriver_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, driverType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if driverType.subclass:
            return driverType.subclass(*args_, **kwargs_)
        else:
            return driverType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_range(self):
        return self.Range
    def set_range(self, Range):
        self.Range = Range
    def get_defaultValue(self):
        return self.defaultValue
    def set_defaultValue(self, defaultValue):
        self.defaultValue = defaultValue
    def get_clockDriver(self):
        return self.clockDriver
    def set_clockDriver(self, clockDriver):
        self.clockDriver = clockDriver
    def get_singleShotDriver(self):
        return self.singleShotDriver
    def set_singleShotDriver(self, singleShotDriver):
        self.singleShotDriver = singleShotDriver
    def _hasContent(self):
        if (
            self.Range is not None or
            self.defaultValue is not None or
            self.clockDriver is not None or
            self.singleShotDriver is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='driverType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('driverType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'driverType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='driverType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='driverType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='driverType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='driverType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Range is not None:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            self.Range.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='range', pretty_print=pretty_print)
        if self.defaultValue is not None:
            namespaceprefix_ = self.defaultValue_nsprefix_ + ':' if (UseCapturedNS_ and self.defaultValue_nsprefix_) else ''
            self.defaultValue.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='defaultValue', pretty_print=pretty_print)
        if self.clockDriver is not None:
            namespaceprefix_ = self.clockDriver_nsprefix_ + ':' if (UseCapturedNS_ and self.clockDriver_nsprefix_) else ''
            self.clockDriver.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='clockDriver', pretty_print=pretty_print)
        if self.singleShotDriver is not None:
            namespaceprefix_ = self.singleShotDriver_nsprefix_ + ':' if (UseCapturedNS_ and self.singleShotDriver_nsprefix_) else ''
            self.singleShotDriver.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='singleShotDriver', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'range':
            obj_ = Range.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
        elif nodeName_ == 'defaultValue':
            obj_ = unsignedBitVectorExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.defaultValue = obj_
            obj_.original_tagname_ = 'defaultValue'
        elif nodeName_ == 'clockDriver':
            obj_ = clockDriver.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.clockDriver = obj_
            obj_.original_tagname_ = 'clockDriver'
        elif nodeName_ == 'singleShotDriver':
            obj_ = singleShotDriver.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.singleShotDriver = obj_
            obj_.original_tagname_ = 'singleShotDriver'
# end class driverType


class drivers(GeneratedsSuper):
    """driver -- Wire port driver element. If no range is specified, default value applies to the entire range.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('driver', 'driverType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'driver', 'ref': 'driver', 'type': 'driver'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, driver=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if driver is None:
            self.driver = []
        else:
            self.driver = driver
        self.driver_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drivers)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drivers.subclass:
            return drivers.subclass(*args_, **kwargs_)
        else:
            return drivers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_driver(self):
        return self.driver
    def set_driver(self, driver):
        self.driver = driver
    def add_driver(self, value):
        self.driver.append(value)
    def insert_driver_at(self, index, value):
        self.driver.insert(index, value)
    def replace_driver_at(self, index, value):
        self.driver[index] = value
    def _hasContent(self):
        if (
            self.driver
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='drivers', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('drivers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'drivers':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='drivers')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='drivers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='drivers'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='drivers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for driver_ in self.driver:
            namespaceprefix_ = self.driver_nsprefix_ + ':' if (UseCapturedNS_ and self.driver_nsprefix_) else ''
            driver_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='driver', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'driver':
            obj_ = driverType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.driver.append(obj_)
            obj_.original_tagname_ = 'driver'
# end class drivers


class clockDriverType(GeneratedsSuper):
    """clockPeriod -- Clock period in units defined by the units attribute. Default is nanoseconds.
    clockPulseOffset -- Time until first pulse. Units are defined by the units attribute. Default is nanoseconds.
    clockPulseValue -- Value of port after first clock edge.
    clockPulseDuration -- Duration of first state in cycle. Units are defined by the units attribute. Default is nanoseconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('clockPeriod', 'clockPeriodType', 0, 0, {'name': 'clockPeriod', 'type': 'clockPeriodType'}, None),
        MemberSpec_('clockPulseOffset', 'clockPulseOffsetType', 0, 0, {'name': 'clockPulseOffset', 'type': 'clockPulseOffsetType'}, None),
        MemberSpec_('clockPulseValue', 'unsignedBitVectorExpression', 0, 0, {'name': 'clockPulseValue', 'type': 'unsignedBitVectorExpression'}, None),
        MemberSpec_('clockPulseDuration', 'clockPulseDurationType', 0, 0, {'name': 'clockPulseDuration', 'type': 'clockPulseDurationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, clockPeriod=None, clockPulseOffset=None, clockPulseValue=None, clockPulseDuration=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.clockPeriod = clockPeriod
        self.clockPeriod_nsprefix_ = "ipxact"
        self.clockPulseOffset = clockPulseOffset
        self.clockPulseOffset_nsprefix_ = "ipxact"
        self.clockPulseValue = clockPulseValue
        self.clockPulseValue_nsprefix_ = "ipxact"
        self.clockPulseDuration = clockPulseDuration
        self.clockPulseDuration_nsprefix_ = "ipxact"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clockDriverType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clockDriverType.subclass:
            return clockDriverType.subclass(*args_, **kwargs_)
        else:
            return clockDriverType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_clockPeriod(self):
        return self.clockPeriod
    def set_clockPeriod(self, clockPeriod):
        self.clockPeriod = clockPeriod
    def get_clockPulseOffset(self):
        return self.clockPulseOffset
    def set_clockPulseOffset(self, clockPulseOffset):
        self.clockPulseOffset = clockPulseOffset
    def get_clockPulseValue(self):
        return self.clockPulseValue
    def set_clockPulseValue(self, clockPulseValue):
        self.clockPulseValue = clockPulseValue
    def get_clockPulseDuration(self):
        return self.clockPulseDuration
    def set_clockPulseDuration(self, clockPulseDuration):
        self.clockPulseDuration = clockPulseDuration
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.clockPeriod is not None or
            self.clockPulseOffset is not None or
            self.clockPulseValue is not None or
            self.clockPulseDuration is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='clockDriverType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clockDriverType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'clockDriverType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clockDriverType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='clockDriverType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='clockDriverType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='clockDriverType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.clockPeriod is not None:
            namespaceprefix_ = self.clockPeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.clockPeriod_nsprefix_) else ''
            self.clockPeriod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='clockPeriod', pretty_print=pretty_print)
        if self.clockPulseOffset is not None:
            namespaceprefix_ = self.clockPulseOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.clockPulseOffset_nsprefix_) else ''
            self.clockPulseOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='clockPulseOffset', pretty_print=pretty_print)
        if self.clockPulseValue is not None:
            namespaceprefix_ = self.clockPulseValue_nsprefix_ + ':' if (UseCapturedNS_ and self.clockPulseValue_nsprefix_) else ''
            self.clockPulseValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='clockPulseValue', pretty_print=pretty_print)
        if self.clockPulseDuration is not None:
            namespaceprefix_ = self.clockPulseDuration_nsprefix_ + ':' if (UseCapturedNS_ and self.clockPulseDuration_nsprefix_) else ''
            self.clockPulseDuration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='clockPulseDuration', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'clockPeriod':
            obj_ = clockPeriodType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.clockPeriod = obj_
            obj_.original_tagname_ = 'clockPeriod'
        elif nodeName_ == 'clockPulseOffset':
            obj_ = clockPulseOffsetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.clockPulseOffset = obj_
            obj_.original_tagname_ = 'clockPulseOffset'
        elif nodeName_ == 'clockPulseValue':
            obj_ = unsignedBitVectorExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.clockPulseValue = obj_
            obj_.original_tagname_ = 'clockPulseValue'
        elif nodeName_ == 'clockPulseDuration':
            obj_ = clockPulseDurationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.clockPulseDuration = obj_
            obj_.original_tagname_ = 'clockPulseDuration'
# end class clockDriverType


class otherClockDriver(clockDriverType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('clockName', 'xs:Name', 0, 0, {'use': 'required', 'name': 'clockName'}),
        MemberSpec_('clockSource', 'xs:string', 0, 1, {'use': 'optional', 'name': 'clockSource'}),
    ]
    subclass = None
    superclass = clockDriverType
    def __init__(self, id=None, clockPeriod=None, clockPulseOffset=None, clockPulseValue=None, clockPulseDuration=None, clockName=None, clockSource=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("otherClockDriver"), self).__init__(id, clockPeriod, clockPulseOffset, clockPulseValue, clockPulseDuration,  **kwargs_)
        self.clockName = _cast(None, clockName)
        self.clockName_nsprefix_ = None
        self.clockSource = _cast(None, clockSource)
        self.clockSource_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, otherClockDriver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if otherClockDriver.subclass:
            return otherClockDriver.subclass(*args_, **kwargs_)
        else:
            return otherClockDriver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_clockName(self):
        return self.clockName
    def set_clockName(self, clockName):
        self.clockName = clockName
    def get_clockSource(self):
        return self.clockSource
    def set_clockSource(self, clockSource):
        self.clockSource = clockSource
    def _hasContent(self):
        if (
            super(otherClockDriver, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='otherClockDriver', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('otherClockDriver')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'otherClockDriver':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='otherClockDriver')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='otherClockDriver', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='otherClockDriver'):
        super(otherClockDriver, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='otherClockDriver')
        if self.clockName is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            outfile.write(' clockName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clockName), input_name='clockName')), ))
        if self.clockSource is not None and 'clockSource' not in already_processed:
            already_processed.add('clockSource')
            outfile.write(' clockSource=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clockSource), input_name='clockSource')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='otherClockDriver', fromsubclass_=False, pretty_print=True):
        super(otherClockDriver, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clockName', node)
        if value is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            self.clockName = value
        value = find_attr_value_('clockSource', node)
        if value is not None and 'clockSource' not in already_processed:
            already_processed.add('clockSource')
            self.clockSource = value
        super(otherClockDriver, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(otherClockDriver, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class otherClockDriver


class file(GeneratedsSuper):
    """name -- Path to the file or directory. If this path is a relative path, then it is relative to the containing XML file.
    isStructural -- Indicates that the current file is purely structural.
    isIncludeFile -- Indicate that the file is include file.
    logicalName -- Logical name for this file or directory e.g. VHDL library name.
    exportedName -- Defines exported names that can be accessed externally, e.g. exported function names from a C source file.
    buildCommand -- Command and flags used to build derived files from the sourceName files. If this element is present, the command and/or flags used to to build the file will override or augment any default builders at a higher level.
    define -- Specifies define symbols that are used in the source file.  The ipxact:name element gives the name to be defined and the text content of the ipxact:value element holds the value.  This element supports full configurability.
    imageType -- Relates the current file to a certain executable image type in the design.
    description -- String for describing this file to users
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('fileId', 'xs:token', 0, 1, {'use': 'optional', 'name': 'fileId'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'stringURIExpression', 0, 0, {'name': 'name', 'type': 'stringURIExpression'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('fileType', 'fileType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'fileType', 'ref': 'fileType', 'type': 'fileType'}, None),
        MemberSpec_('isStructural', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isStructural', 'type': 'xs:boolean'}, None),
        MemberSpec_('isIncludeFile', 'isIncludeFileType', 0, 1, {'minOccurs': '0', 'name': 'isIncludeFile', 'type': 'isIncludeFileType'}, None),
        MemberSpec_('logicalName', 'logicalNameType', 0, 1, {'minOccurs': '0', 'name': 'logicalName', 'type': 'logicalNameType'}, None),
        MemberSpec_('exportedName', 'exportedNameType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'exportedName', 'type': 'exportedNameType'}, None),
        MemberSpec_('buildCommand', 'buildCommandType', 0, 1, {'minOccurs': '0', 'name': 'buildCommand', 'type': 'buildCommandType'}, None),
        MemberSpec_('dependency', 'dependency', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'dependency', 'ref': 'dependency', 'type': 'dependency'}, None),
        MemberSpec_('define', 'nameValuePairType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'define', 'type': 'nameValuePairType'}, None),
        MemberSpec_('imageType', 'imageTypeType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'imageType', 'type': 'imageTypeType'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, fileId=None, id=None, name=None, isPresent=None, fileType=None, isStructural=False, isIncludeFile=None, logicalName=None, exportedName=None, buildCommand=None, dependency=None, define=None, imageType=None, description=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.fileId = _cast(None, fileId)
        self.fileId_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        if fileType is None:
            self.fileType = []
        else:
            self.fileType = fileType
        self.fileType_nsprefix_ = "ipxact"
        self.isStructural = isStructural
        self.isStructural_nsprefix_ = "ipxact"
        self.isIncludeFile = isIncludeFile
        self.isIncludeFile_nsprefix_ = "ipxact"
        self.logicalName = logicalName
        self.logicalName_nsprefix_ = "ipxact"
        if exportedName is None:
            self.exportedName = []
        else:
            self.exportedName = exportedName
        self.exportedName_nsprefix_ = "ipxact"
        self.buildCommand = buildCommand
        self.buildCommand_nsprefix_ = "ipxact"
        if dependency is None:
            self.dependency = []
        else:
            self.dependency = dependency
        self.dependency_nsprefix_ = "ipxact"
        if define is None:
            self.define = []
        else:
            self.define = define
        self.define_nsprefix_ = "ipxact"
        if imageType is None:
            self.imageType = []
        else:
            self.imageType = imageType
        self.imageType_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, file)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if file.subclass:
            return file.subclass(*args_, **kwargs_)
        else:
            return file(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_fileType(self):
        return self.fileType
    def set_fileType(self, fileType):
        self.fileType = fileType
    def add_fileType(self, value):
        self.fileType.append(value)
    def insert_fileType_at(self, index, value):
        self.fileType.insert(index, value)
    def replace_fileType_at(self, index, value):
        self.fileType[index] = value
    def get_isStructural(self):
        return self.isStructural
    def set_isStructural(self, isStructural):
        self.isStructural = isStructural
    def get_isIncludeFile(self):
        return self.isIncludeFile
    def set_isIncludeFile(self, isIncludeFile):
        self.isIncludeFile = isIncludeFile
    def get_logicalName(self):
        return self.logicalName
    def set_logicalName(self, logicalName):
        self.logicalName = logicalName
    def get_exportedName(self):
        return self.exportedName
    def set_exportedName(self, exportedName):
        self.exportedName = exportedName
    def add_exportedName(self, value):
        self.exportedName.append(value)
    def insert_exportedName_at(self, index, value):
        self.exportedName.insert(index, value)
    def replace_exportedName_at(self, index, value):
        self.exportedName[index] = value
    def get_buildCommand(self):
        return self.buildCommand
    def set_buildCommand(self, buildCommand):
        self.buildCommand = buildCommand
    def get_dependency(self):
        return self.dependency
    def set_dependency(self, dependency):
        self.dependency = dependency
    def add_dependency(self, value):
        self.dependency.append(value)
    def insert_dependency_at(self, index, value):
        self.dependency.insert(index, value)
    def replace_dependency_at(self, index, value):
        self.dependency[index] = value
    def get_define(self):
        return self.define
    def set_define(self, define):
        self.define = define
    def add_define(self, value):
        self.define.append(value)
    def insert_define_at(self, index, value):
        self.define.insert(index, value)
    def replace_define_at(self, index, value):
        self.define[index] = value
    def get_imageType(self):
        return self.imageType
    def set_imageType(self, imageType):
        self.imageType = imageType
    def add_imageType(self, value):
        self.imageType.append(value)
    def insert_imageType_at(self, index, value):
        self.imageType.insert(index, value)
    def replace_imageType_at(self, index, value):
        self.imageType[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_fileId(self):
        return self.fileId
    def set_fileId(self, fileId):
        self.fileId = fileId
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.isPresent is not None or
            self.fileType or
            self.isStructural or
            self.isIncludeFile is not None or
            self.logicalName is not None or
            self.exportedName or
            self.buildCommand is not None or
            self.dependency or
            self.define or
            self.imageType or
            self.description is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='file', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('file')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'file':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='file')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='file', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='file'):
        if self.fileId is not None and 'fileId' not in already_processed:
            already_processed.add('fileId')
            outfile.write(' fileId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fileId), input_name='fileId')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='file', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for fileType_ in self.fileType:
            namespaceprefix_ = self.fileType_nsprefix_ + ':' if (UseCapturedNS_ and self.fileType_nsprefix_) else ''
            fileType_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='fileType', pretty_print=pretty_print)
        if self.isStructural:
            namespaceprefix_ = self.isStructural_nsprefix_ + ':' if (UseCapturedNS_ and self.isStructural_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisStructural>%s</%sisStructural>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isStructural, input_name='isStructural'), namespaceprefix_ , eol_))
        if self.isIncludeFile is not None:
            namespaceprefix_ = self.isIncludeFile_nsprefix_ + ':' if (UseCapturedNS_ and self.isIncludeFile_nsprefix_) else ''
            self.isIncludeFile.export(outfile, level, namespaceprefix_, namespacedef_='', name_='isIncludeFile', pretty_print=pretty_print)
        if self.logicalName is not None:
            namespaceprefix_ = self.logicalName_nsprefix_ + ':' if (UseCapturedNS_ and self.logicalName_nsprefix_) else ''
            self.logicalName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='logicalName', pretty_print=pretty_print)
        for exportedName_ in self.exportedName:
            namespaceprefix_ = self.exportedName_nsprefix_ + ':' if (UseCapturedNS_ and self.exportedName_nsprefix_) else ''
            exportedName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='exportedName', pretty_print=pretty_print)
        if self.buildCommand is not None:
            namespaceprefix_ = self.buildCommand_nsprefix_ + ':' if (UseCapturedNS_ and self.buildCommand_nsprefix_) else ''
            self.buildCommand.export(outfile, level, namespaceprefix_, namespacedef_='', name_='buildCommand', pretty_print=pretty_print)
        for dependency_ in self.dependency:
            namespaceprefix_ = self.dependency_nsprefix_ + ':' if (UseCapturedNS_ and self.dependency_nsprefix_) else ''
            dependency_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='dependency', pretty_print=pretty_print)
        for define_ in self.define:
            namespaceprefix_ = self.define_nsprefix_ + ':' if (UseCapturedNS_ and self.define_nsprefix_) else ''
            define_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='define', pretty_print=pretty_print)
        for imageType_ in self.imageType:
            namespaceprefix_ = self.imageType_nsprefix_ + ':' if (UseCapturedNS_ and self.imageType_nsprefix_) else ''
            imageType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='imageType', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fileId', node)
        if value is not None and 'fileId' not in already_processed:
            already_processed.add('fileId')
            self.fileId = value
            self.fileId = ' '.join(self.fileId.split())
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            obj_ = stringURIExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'fileType':
            obj_ = fileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileType.append(obj_)
            obj_.original_tagname_ = 'fileType'
        elif nodeName_ == 'isStructural':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isStructural')
            ival_ = self.gds_validate_boolean(ival_, node, 'isStructural')
            self.isStructural = ival_
            self.isStructural_nsprefix_ = child_.prefix
        elif nodeName_ == 'isIncludeFile':
            obj_ = isIncludeFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isIncludeFile = obj_
            obj_.original_tagname_ = 'isIncludeFile'
        elif nodeName_ == 'logicalName':
            obj_ = logicalNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.logicalName = obj_
            obj_.original_tagname_ = 'logicalName'
        elif nodeName_ == 'exportedName':
            obj_ = exportedNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.exportedName.append(obj_)
            obj_.original_tagname_ = 'exportedName'
        elif nodeName_ == 'buildCommand':
            obj_ = buildCommandType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.buildCommand = obj_
            obj_.original_tagname_ = 'buildCommand'
        elif nodeName_ == 'dependency':
            obj_ = dependency.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dependency.append(obj_)
            obj_.original_tagname_ = 'dependency'
        elif nodeName_ == 'define':
            class_obj_ = self.get_class_obj_(child_, nameValuePairType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.define.append(obj_)
            obj_.original_tagname_ = 'define'
        elif nodeName_ == 'imageType':
            obj_ = imageTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imageType.append(obj_)
            obj_.original_tagname_ = 'imageType'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class file


class executableImage(GeneratedsSuper):
    """name -- Unique name
    parameters -- Additional information about the load module, e.g. stack base addresses, table addresses, etc.
    languageTools -- Default commands and flags for software language tools needed to build the executable image.
    fileSetRefGroup -- Contains a group of file set references that indicates the set of file sets complying with the tool set of the current executable image.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('imageId', 'xs:token', 0, 0, {'use': 'required', 'name': 'imageId'}),
        MemberSpec_('imageType', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'imageType'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('languageTools', 'languageToolsType', 0, 1, {'minOccurs': '0', 'name': 'languageTools', 'type': 'languageToolsType'}, None),
        MemberSpec_('fileSetRefGroup', 'fileSetRefGroupType', 0, 1, {'minOccurs': '0', 'name': 'fileSetRefGroup', 'type': 'fileSetRefGroupType'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, imageId=None, imageType=None, id=None, name=None, displayName=None, description=None, parameters=None, languageTools=None, fileSetRefGroup=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.imageId = _cast(None, imageId)
        self.imageId_nsprefix_ = None
        self.imageType = _cast(None, imageType)
        self.imageType_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.languageTools = languageTools
        self.languageTools_nsprefix_ = "ipxact"
        self.fileSetRefGroup = fileSetRefGroup
        self.fileSetRefGroup_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, executableImage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if executableImage.subclass:
            return executableImage.subclass(*args_, **kwargs_)
        else:
            return executableImage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_languageTools(self):
        return self.languageTools
    def set_languageTools(self, languageTools):
        self.languageTools = languageTools
    def get_fileSetRefGroup(self):
        return self.fileSetRefGroup
    def set_fileSetRefGroup(self, fileSetRefGroup):
        self.fileSetRefGroup = fileSetRefGroup
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_imageId(self):
        return self.imageId
    def set_imageId(self, imageId):
        self.imageId = imageId
    def get_imageType(self):
        return self.imageType
    def set_imageType(self, imageType):
        self.imageType = imageType
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.parameters is not None or
            self.languageTools is not None or
            self.fileSetRefGroup is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='executableImage', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('executableImage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'executableImage':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='executableImage')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='executableImage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='executableImage'):
        if self.imageId is not None and 'imageId' not in already_processed:
            already_processed.add('imageId')
            outfile.write(' imageId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageId), input_name='imageId')), ))
        if self.imageType is not None and 'imageType' not in already_processed:
            already_processed.add('imageType')
            outfile.write(' imageType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageType), input_name='imageType')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='executableImage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.languageTools is not None:
            namespaceprefix_ = self.languageTools_nsprefix_ + ':' if (UseCapturedNS_ and self.languageTools_nsprefix_) else ''
            self.languageTools.export(outfile, level, namespaceprefix_, namespacedef_='', name_='languageTools', pretty_print=pretty_print)
        if self.fileSetRefGroup is not None:
            namespaceprefix_ = self.fileSetRefGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.fileSetRefGroup_nsprefix_) else ''
            self.fileSetRefGroup.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fileSetRefGroup', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('imageId', node)
        if value is not None and 'imageId' not in already_processed:
            already_processed.add('imageId')
            self.imageId = value
            self.imageId = ' '.join(self.imageId.split())
        value = find_attr_value_('imageType', node)
        if value is not None and 'imageType' not in already_processed:
            already_processed.add('imageType')
            self.imageType = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'languageTools':
            obj_ = languageToolsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.languageTools = obj_
            obj_.original_tagname_ = 'languageTools'
        elif nodeName_ == 'fileSetRefGroup':
            obj_ = fileSetRefGroupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileSetRefGroup = obj_
            obj_.original_tagname_ = 'fileSetRefGroup'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class executableImage


class linkerCommandFile(GeneratedsSuper):
    """name -- Linker command file name.
    commandLineSwitch -- The command line switch to specify the linker command file.
    enable -- Specifies whether to generate and enable the linker command file.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'stringURIExpression', 0, 0, {'name': 'name', 'type': 'stringURIExpression'}, None),
        MemberSpec_('commandLineSwitch', 'stringExpression', 0, 0, {'name': 'commandLineSwitch', 'type': 'stringExpression'}, None),
        MemberSpec_('enable', 'unsignedBitExpression', 0, 0, {'name': 'enable', 'type': 'unsignedBitExpression'}, None),
        MemberSpec_('generatorRef', 'generatorRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'generatorRef', 'ref': 'generatorRef', 'type': 'generatorRef'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, commandLineSwitch=None, enable=None, generatorRef=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.commandLineSwitch = commandLineSwitch
        self.commandLineSwitch_nsprefix_ = "ipxact"
        self.enable = enable
        self.enable_nsprefix_ = "ipxact"
        if generatorRef is None:
            self.generatorRef = []
        else:
            self.generatorRef = generatorRef
        self.generatorRef_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, linkerCommandFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if linkerCommandFile.subclass:
            return linkerCommandFile.subclass(*args_, **kwargs_)
        else:
            return linkerCommandFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_commandLineSwitch(self):
        return self.commandLineSwitch
    def set_commandLineSwitch(self, commandLineSwitch):
        self.commandLineSwitch = commandLineSwitch
    def get_enable(self):
        return self.enable
    def set_enable(self, enable):
        self.enable = enable
    def get_generatorRef(self):
        return self.generatorRef
    def set_generatorRef(self, generatorRef):
        self.generatorRef = generatorRef
    def add_generatorRef(self, value):
        self.generatorRef.append(value)
    def insert_generatorRef_at(self, index, value):
        self.generatorRef.insert(index, value)
    def replace_generatorRef_at(self, index, value):
        self.generatorRef[index] = value
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def _hasContent(self):
        if (
            self.name is not None or
            self.commandLineSwitch is not None or
            self.enable is not None or
            self.generatorRef or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='linkerCommandFile', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('linkerCommandFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'linkerCommandFile':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='linkerCommandFile')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='linkerCommandFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='linkerCommandFile'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='linkerCommandFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.commandLineSwitch is not None:
            namespaceprefix_ = self.commandLineSwitch_nsprefix_ + ':' if (UseCapturedNS_ and self.commandLineSwitch_nsprefix_) else ''
            self.commandLineSwitch.export(outfile, level, namespaceprefix_, namespacedef_='', name_='commandLineSwitch', pretty_print=pretty_print)
        if self.enable is not None:
            namespaceprefix_ = self.enable_nsprefix_ + ':' if (UseCapturedNS_ and self.enable_nsprefix_) else ''
            self.enable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enable', pretty_print=pretty_print)
        for generatorRef_ in self.generatorRef:
            namespaceprefix_ = self.generatorRef_nsprefix_ + ':' if (UseCapturedNS_ and self.generatorRef_nsprefix_) else ''
            generatorRef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='generatorRef', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            obj_ = stringURIExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'commandLineSwitch':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.commandLineSwitch = obj_
            obj_.original_tagname_ = 'commandLineSwitch'
        elif nodeName_ == 'enable':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enable = obj_
            obj_.original_tagname_ = 'enable'
        elif nodeName_ == 'generatorRef':
            obj_ = generatorRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generatorRef.append(obj_)
            obj_.original_tagname_ = 'generatorRef'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class linkerCommandFile


class fileSetRef(GeneratedsSuper):
    """localName -- Refers to a fileSet defined within this description.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('localName', 'xs:Name', 0, 0, {'name': 'localName', 'type': 'xs:Name'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, localName=None, isPresent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.localName = localName
        self.localName_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSetRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSetRef.subclass:
            return fileSetRef.subclass(*args_, **kwargs_)
        else:
            return fileSetRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_localName(self):
        return self.localName
    def set_localName(self, localName):
        self.localName = localName
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.localName is not None or
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSetRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSetRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fileSetRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileSetRef')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fileSetRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='fileSetRef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSetRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.localName is not None:
            namespaceprefix_ = self.localName_nsprefix_ + ':' if (UseCapturedNS_ and self.localName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocalName>%s</%slocalName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.localName), input_name='localName')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'localName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'localName')
            value_ = self.gds_validate_string(value_, node, 'localName')
            self.localName = value_
            self.localName_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class fileSetRef


class fileSets(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('fileSet', 'fileSetType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'fileSet', 'ref': 'fileSet', 'type': 'fileSet'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, fileSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if fileSet is None:
            self.fileSet = []
        else:
            self.fileSet = fileSet
        self.fileSet_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSets)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSets.subclass:
            return fileSets.subclass(*args_, **kwargs_)
        else:
            return fileSets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fileSet(self):
        return self.fileSet
    def set_fileSet(self, fileSet):
        self.fileSet = fileSet
    def add_fileSet(self, value):
        self.fileSet.append(value)
    def insert_fileSet_at(self, index, value):
        self.fileSet.insert(index, value)
    def replace_fileSet_at(self, index, value):
        self.fileSet[index] = value
    def _hasContent(self):
        if (
            self.fileSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSets', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSets')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fileSets':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileSets')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fileSets', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='fileSets'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSets', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fileSet_ in self.fileSet:
            namespaceprefix_ = self.fileSet_nsprefix_ + ':' if (UseCapturedNS_ and self.fileSet_nsprefix_) else ''
            fileSet_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='fileSet', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fileSet':
            obj_ = fileSetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileSet.append(obj_)
            obj_.original_tagname_ = 'fileSet'
# end class fileSets


class fileBuilderType(GeneratedsSuper):
    """command -- Default command used to build files of the specified fileType.
    flags -- Flags given to the build command when building files of this type.
    replaceDefaultFlags -- If true, replace any default flags value with the value in the sibling flags element. Otherwise, append the contents of the sibling flags element to any default flags value.
    If the value is true and the "flags" element is empty or missing, this will have the result of clearing any default flags value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('fileType', 'fileType', 0, 0, {'name': 'fileType', 'ref': 'fileType', 'type': 'fileType'}, None),
        MemberSpec_('command', 'stringExpression', 0, 1, {'minOccurs': '0', 'name': 'command', 'type': 'stringExpression'}, None),
        MemberSpec_('flags', 'stringExpression', 0, 1, {'minOccurs': '0', 'name': 'flags', 'type': 'stringExpression'}, None),
        MemberSpec_('replaceDefaultFlags', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'replaceDefaultFlags', 'type': 'unsignedBitExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, fileType=None, command=None, flags=None, replaceDefaultFlags=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.fileType = fileType
        self.fileType_nsprefix_ = "ipxact"
        self.command = command
        self.command_nsprefix_ = "ipxact"
        self.flags = flags
        self.flags_nsprefix_ = "ipxact"
        self.replaceDefaultFlags = replaceDefaultFlags
        self.replaceDefaultFlags_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileBuilderType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileBuilderType.subclass:
            return fileBuilderType.subclass(*args_, **kwargs_)
        else:
            return fileBuilderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fileType(self):
        return self.fileType
    def set_fileType(self, fileType):
        self.fileType = fileType
    def get_command(self):
        return self.command
    def set_command(self, command):
        self.command = command
    def get_flags(self):
        return self.flags
    def set_flags(self, flags):
        self.flags = flags
    def get_replaceDefaultFlags(self):
        return self.replaceDefaultFlags
    def set_replaceDefaultFlags(self, replaceDefaultFlags):
        self.replaceDefaultFlags = replaceDefaultFlags
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.fileType is not None or
            self.command is not None or
            self.flags is not None or
            self.replaceDefaultFlags is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileBuilderType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileBuilderType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fileBuilderType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileBuilderType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fileBuilderType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='fileBuilderType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileBuilderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fileType is not None:
            namespaceprefix_ = self.fileType_nsprefix_ + ':' if (UseCapturedNS_ and self.fileType_nsprefix_) else ''
            self.fileType.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='fileType', pretty_print=pretty_print)
        if self.command is not None:
            namespaceprefix_ = self.command_nsprefix_ + ':' if (UseCapturedNS_ and self.command_nsprefix_) else ''
            self.command.export(outfile, level, namespaceprefix_, namespacedef_='', name_='command', pretty_print=pretty_print)
        if self.flags is not None:
            namespaceprefix_ = self.flags_nsprefix_ + ':' if (UseCapturedNS_ and self.flags_nsprefix_) else ''
            self.flags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flags', pretty_print=pretty_print)
        if self.replaceDefaultFlags is not None:
            namespaceprefix_ = self.replaceDefaultFlags_nsprefix_ + ':' if (UseCapturedNS_ and self.replaceDefaultFlags_nsprefix_) else ''
            self.replaceDefaultFlags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='replaceDefaultFlags', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fileType':
            obj_ = fileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileType = obj_
            obj_.original_tagname_ = 'fileType'
        elif nodeName_ == 'command':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.command = obj_
            obj_.original_tagname_ = 'command'
        elif nodeName_ == 'flags':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flags = obj_
            obj_.original_tagname_ = 'flags'
        elif nodeName_ == 'replaceDefaultFlags':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.replaceDefaultFlags = obj_
            obj_.original_tagname_ = 'replaceDefaultFlags'
# end class fileBuilderType


class fileSetType(GeneratedsSuper):
    """name -- Unique name
    group -- Identifies this filleSet as belonging to a particular group or having a particular purpose. Examples might be "diagnostics", "boot", "application", "interrupt", "deviceDriver", etc.
    defaultFileBuilder -- Default command and flags used to build derived files from the sourceName files in this file set.
    function -- Generator information if this file set describes a function. For example, this file set may describe diagnostics for which the DE can generate a diagnostics driver.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('group', 'xs:Name', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'group', 'type': 'groupType'}, None),
        MemberSpec_('file', 'file', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'file', 'ref': 'file', 'type': 'file'}, None),
        MemberSpec_('defaultFileBuilder', 'fileBuilderType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'defaultFileBuilder', 'type': 'fileBuilderType'}, None),
        MemberSpec_('dependency', 'dependency', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'dependency', 'ref': 'dependency', 'type': 'dependency'}, None),
        MemberSpec_('function', 'functionType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'function', 'type': 'functionType'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, group=None, file=None, defaultFileBuilder=None, dependency=None, function=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        if group is None:
            self.group = []
        else:
            self.group = group
        self.group_nsprefix_ = "ipxact"
        if file is None:
            self.file = []
        else:
            self.file = file
        self.file_nsprefix_ = "ipxact"
        if defaultFileBuilder is None:
            self.defaultFileBuilder = []
        else:
            self.defaultFileBuilder = defaultFileBuilder
        self.defaultFileBuilder_nsprefix_ = "ipxact"
        if dependency is None:
            self.dependency = []
        else:
            self.dependency = dependency
        self.dependency_nsprefix_ = "ipxact"
        if function is None:
            self.function = []
        else:
            self.function = function
        self.function_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSetType.subclass:
            return fileSetType.subclass(*args_, **kwargs_)
        else:
            return fileSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def add_group(self, value):
        self.group.append(value)
    def insert_group_at(self, index, value):
        self.group.insert(index, value)
    def replace_group_at(self, index, value):
        self.group[index] = value
    def get_file(self):
        return self.file
    def set_file(self, file):
        self.file = file
    def add_file(self, value):
        self.file.append(value)
    def insert_file_at(self, index, value):
        self.file.insert(index, value)
    def replace_file_at(self, index, value):
        self.file[index] = value
    def get_defaultFileBuilder(self):
        return self.defaultFileBuilder
    def set_defaultFileBuilder(self, defaultFileBuilder):
        self.defaultFileBuilder = defaultFileBuilder
    def add_defaultFileBuilder(self, value):
        self.defaultFileBuilder.append(value)
    def insert_defaultFileBuilder_at(self, index, value):
        self.defaultFileBuilder.insert(index, value)
    def replace_defaultFileBuilder_at(self, index, value):
        self.defaultFileBuilder[index] = value
    def get_dependency(self):
        return self.dependency
    def set_dependency(self, dependency):
        self.dependency = dependency
    def add_dependency(self, value):
        self.dependency.append(value)
    def insert_dependency_at(self, index, value):
        self.dependency.insert(index, value)
    def replace_dependency_at(self, index, value):
        self.dependency[index] = value
    def get_function(self):
        return self.function
    def set_function(self, function):
        self.function = function
    def add_function(self, value):
        self.function.append(value)
    def insert_function_at(self, index, value):
        self.function.insert(index, value)
    def replace_function_at(self, index, value):
        self.function[index] = value
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.group or
            self.file or
            self.defaultFileBuilder or
            self.dependency or
            self.function or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fileSetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileSetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fileSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='fileSetType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        for group_ in self.group:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            group_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group', pretty_print=pretty_print)
        for file_ in self.file:
            namespaceprefix_ = self.file_nsprefix_ + ':' if (UseCapturedNS_ and self.file_nsprefix_) else ''
            file_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='file', pretty_print=pretty_print)
        for defaultFileBuilder_ in self.defaultFileBuilder:
            namespaceprefix_ = self.defaultFileBuilder_nsprefix_ + ':' if (UseCapturedNS_ and self.defaultFileBuilder_nsprefix_) else ''
            defaultFileBuilder_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='defaultFileBuilder', pretty_print=pretty_print)
        for dependency_ in self.dependency:
            namespaceprefix_ = self.dependency_nsprefix_ + ':' if (UseCapturedNS_ and self.dependency_nsprefix_) else ''
            dependency_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='dependency', pretty_print=pretty_print)
        for function_ in self.function:
            namespaceprefix_ = self.function_nsprefix_ + ':' if (UseCapturedNS_ and self.function_nsprefix_) else ''
            function_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='function', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'group':
            obj_ = groupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
        elif nodeName_ == 'file':
            obj_ = file.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.file.append(obj_)
            obj_.original_tagname_ = 'file'
        elif nodeName_ == 'defaultFileBuilder':
            obj_ = fileBuilderType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.defaultFileBuilder.append(obj_)
            obj_.original_tagname_ = 'defaultFileBuilder'
        elif nodeName_ == 'dependency':
            obj_ = dependency.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dependency.append(obj_)
            obj_.original_tagname_ = 'dependency'
        elif nodeName_ == 'function':
            obj_ = functionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.function.append(obj_)
            obj_.original_tagname_ = 'function'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class fileSetType


class generatorRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generatorRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generatorRef.subclass:
            return generatorRef.subclass(*args_, **kwargs_)
        else:
            return generatorRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generatorRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generatorRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'generatorRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='generatorRef')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='generatorRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='generatorRef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generatorRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class generatorRef


class ipxactURI(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ipxactURI)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ipxactURI.subclass:
            return ipxactURI.subclass(*args_, **kwargs_)
        else:
            return ipxactURI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='ipxactURI', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ipxactURI')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ipxactURI':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ipxactURI')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ipxactURI', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='ipxactURI'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='ipxactURI', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ipxactURI


class fileType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('user', 'xs:string', 0, 1, {'use': 'optional', 'name': 'user'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', ['simpleFileType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, user=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.user = _cast(None, user)
        self.user_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileType.subclass:
            return fileType.subclass(*args_, **kwargs_)
        else:
            return fileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_user(self):
        return self.user
    def set_user(self, user):
        self.user = user
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_simpleFileType(self, value):
        result = True
        # Validate type simpleFileType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['unknown', 'cSource', 'cppSource', 'asmSource', 'vhdlSource', 'vhdlSource-87', 'vhdlSource-93', 'verilogSource', 'verilogSource-95', 'verilogSource-2001', 'swObject', 'swObjectLibrary', 'vhdlBinaryLibrary', 'verilogBinaryLibrary', 'unelaboratedHdl', 'executableHdl', 'systemVerilogSource', 'systemVerilogSource-3.0', 'systemVerilogSource-3.1', 'systemCSource', 'systemCSource-2.0', 'systemCSource-2.0.1', 'systemCSource-2.1', 'systemCSource-2.2', 'veraSource', 'eSource', 'perlSource', 'tclSource', 'OVASource', 'SVASource', 'pslSource', 'systemVerilogSource-3.1a', 'SDC', 'vhdlAmsSource', 'verilogAmsSource', 'systemCAmsSource', 'libertySource', 'user']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on simpleFileType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fileType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fileType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='fileType'):
        if self.user is not None and 'user' not in already_processed:
            already_processed.add('user')
            outfile.write(' user=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.user), input_name='user')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('user', node)
        if value is not None and 'user' not in already_processed:
            already_processed.add('user')
            self.user = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class fileType


class generatorChain(GeneratedsSuper):
    """vendor -- Name of the vendor who supplies this file.
    library -- Name of the logical library this element belongs to.
    name -- The name of the object.
    version -- Indicates the version of the named element.
    generatorChainSelector -- Select other generator chain files for inclusion into this chain. The boolean attribute "unique" (default false) specifies that only a single generator is valid in this context. If more that one generator is selected based on the selection criteria, DE will prompt the user to resolve to a single generator.
    componentGeneratorSelector -- Selects generators declared in components of the current design for inclusion into this generator chain.
    chainGroup -- Identifies this generator chain as belonging to the named group. This is used by other generator chains to select this chain for programmatic inclusion.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('hidden', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'hidden'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'name': 'vendor', 'type': 'xs:Name'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'name': 'library', 'type': 'xs:Name'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'name': 'version', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('generatorChainSelector', 'generatorChainSelectorType', 1, 0, {'name': 'generatorChainSelector', 'type': 'generatorChainSelectorType'}, 11),
        MemberSpec_('componentGeneratorSelector', 'generatorSelectorType', 1, 0, {'name': 'componentGeneratorSelector', 'type': 'generatorSelectorType'}, 11),
        MemberSpec_('generator', 'generator', 1, 0, {'name': 'generator', 'ref': 'generator', 'type': 'generator'}, 11),
        MemberSpec_('chainGroup', 'chainGroupType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'chainGroup', 'type': 'chainGroupType'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('choices', 'choices', 0, 1, {'minOccurs': '0', 'name': 'choices', 'ref': 'choices', 'type': 'choices'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'name': 'assertions', 'ref': 'assertions', 'type': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, hidden=False, id=None, vendor=None, library=None, name=None, version=None, generatorChainSelector=None, componentGeneratorSelector=None, generator=None, chainGroup=None, displayName=None, description=None, choices=None, parameters=None, assertions=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.hidden = _cast(bool, hidden)
        self.hidden_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.vendor = vendor
        self.vendor_nsprefix_ = "ipxact"
        self.library = library
        self.library_nsprefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.version = version
        self.version_nsprefix_ = "ipxact"
        if generatorChainSelector is None:
            self.generatorChainSelector = []
        else:
            self.generatorChainSelector = generatorChainSelector
        self.generatorChainSelector_nsprefix_ = "ipxact"
        if componentGeneratorSelector is None:
            self.componentGeneratorSelector = []
        else:
            self.componentGeneratorSelector = componentGeneratorSelector
        self.componentGeneratorSelector_nsprefix_ = "ipxact"
        if generator is None:
            self.generator = []
        else:
            self.generator = generator
        self.generator_nsprefix_ = "ipxact"
        if chainGroup is None:
            self.chainGroup = []
        else:
            self.chainGroup = chainGroup
        self.chainGroup_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.choices = choices
        self.choices_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.assertions = assertions
        self.assertions_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generatorChain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generatorChain.subclass:
            return generatorChain.subclass(*args_, **kwargs_)
        else:
            return generatorChain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_generatorChainSelector(self):
        return self.generatorChainSelector
    def set_generatorChainSelector(self, generatorChainSelector):
        self.generatorChainSelector = generatorChainSelector
    def add_generatorChainSelector(self, value):
        self.generatorChainSelector.append(value)
    def insert_generatorChainSelector_at(self, index, value):
        self.generatorChainSelector.insert(index, value)
    def replace_generatorChainSelector_at(self, index, value):
        self.generatorChainSelector[index] = value
    def get_componentGeneratorSelector(self):
        return self.componentGeneratorSelector
    def set_componentGeneratorSelector(self, componentGeneratorSelector):
        self.componentGeneratorSelector = componentGeneratorSelector
    def add_componentGeneratorSelector(self, value):
        self.componentGeneratorSelector.append(value)
    def insert_componentGeneratorSelector_at(self, index, value):
        self.componentGeneratorSelector.insert(index, value)
    def replace_componentGeneratorSelector_at(self, index, value):
        self.componentGeneratorSelector[index] = value
    def get_generator(self):
        return self.generator
    def set_generator(self, generator):
        self.generator = generator
    def add_generator(self, value):
        self.generator.append(value)
    def insert_generator_at(self, index, value):
        self.generator.insert(index, value)
    def replace_generator_at(self, index, value):
        self.generator[index] = value
    def get_chainGroup(self):
        return self.chainGroup
    def set_chainGroup(self, chainGroup):
        self.chainGroup = chainGroup
    def add_chainGroup(self, value):
        self.chainGroup.append(value)
    def insert_chainGroup_at(self, index, value):
        self.chainGroup.insert(index, value)
    def replace_chainGroup_at(self, index, value):
        self.chainGroup[index] = value
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_choices(self):
        return self.choices
    def set_choices(self, choices):
        self.choices = choices
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_assertions(self):
        return self.assertions
    def set_assertions(self, assertions):
        self.assertions = assertions
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_hidden(self):
        return self.hidden
    def set_hidden(self, hidden):
        self.hidden = hidden
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.generatorChainSelector or
            self.componentGeneratorSelector or
            self.generator or
            self.chainGroup or
            self.displayName is not None or
            self.description is not None or
            self.choices is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generatorChain', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generatorChain')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'generatorChain':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='generatorChain')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='generatorChain', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='generatorChain'):
        if self.hidden and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_boolean(self.hidden, input_name='hidden'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generatorChain', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            namespaceprefix_ = self.vendor_nsprefix_ + ':' if (UseCapturedNS_ and self.vendor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), namespaceprefix_ , eol_))
        if self.library is not None:
            namespaceprefix_ = self.library_nsprefix_ + ':' if (UseCapturedNS_ and self.library_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slibrary>%s</%slibrary>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespaceprefix_ , eol_))
        for generatorChainSelector_ in self.generatorChainSelector:
            namespaceprefix_ = self.generatorChainSelector_nsprefix_ + ':' if (UseCapturedNS_ and self.generatorChainSelector_nsprefix_) else ''
            generatorChainSelector_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generatorChainSelector', pretty_print=pretty_print)
        for componentGeneratorSelector_ in self.componentGeneratorSelector:
            namespaceprefix_ = self.componentGeneratorSelector_nsprefix_ + ':' if (UseCapturedNS_ and self.componentGeneratorSelector_nsprefix_) else ''
            componentGeneratorSelector_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='componentGeneratorSelector', pretty_print=pretty_print)
        for generator_ in self.generator:
            namespaceprefix_ = self.generator_nsprefix_ + ':' if (UseCapturedNS_ and self.generator_nsprefix_) else ''
            generator_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='generator', pretty_print=pretty_print)
        for chainGroup_ in self.chainGroup:
            namespaceprefix_ = self.chainGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.chainGroup_nsprefix_) else ''
            chainGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='chainGroup', pretty_print=pretty_print)
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.choices is not None:
            namespaceprefix_ = self.choices_nsprefix_ + ':' if (UseCapturedNS_ and self.choices_nsprefix_) else ''
            self.choices.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='choices', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            namespaceprefix_ = self.assertions_nsprefix_ + ':' if (UseCapturedNS_ and self.assertions_nsprefix_) else ''
            self.assertions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            if value in ('true', '1'):
                self.hidden = True
            elif value in ('false', '0'):
                self.hidden = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vendor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vendor')
            value_ = self.gds_validate_string(value_, node, 'vendor')
            self.vendor = value_
            self.vendor_nsprefix_ = child_.prefix
        elif nodeName_ == 'library':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'library')
            value_ = self.gds_validate_string(value_, node, 'library')
            self.library = value_
            self.library_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'version')
            value_ = self.gds_validate_string(value_, node, 'version')
            self.version = value_
            self.version_nsprefix_ = child_.prefix
        elif nodeName_ == 'generatorChainSelector':
            obj_ = generatorChainSelectorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generatorChainSelector.append(obj_)
            obj_.original_tagname_ = 'generatorChainSelector'
        elif nodeName_ == 'componentGeneratorSelector':
            obj_ = generatorSelectorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.componentGeneratorSelector.append(obj_)
            obj_.original_tagname_ = 'componentGeneratorSelector'
        elif nodeName_ == 'generator':
            obj_ = generator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generator.append(obj_)
            obj_.original_tagname_ = 'generator'
        elif nodeName_ == 'chainGroup':
            obj_ = chainGroupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.chainGroup.append(obj_)
            obj_.original_tagname_ = 'chainGroup'
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'choices':
            obj_ = choices.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.choices = obj_
            obj_.original_tagname_ = 'choices'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class generatorChain


class groupSelector(GeneratedsSuper):
    """name -- Specifies a generator group name or a generator chain group name to be selected for inclusion in the generator chain.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('multipleGroupSelectionOperator', 'multipleGroupSelectionOperatorType', 0, 1, {'use': 'optional', 'name': 'multipleGroupSelectionOperator'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'nameType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'name', 'type': 'nameType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, multipleGroupSelectionOperator='or', id=None, name=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.multipleGroupSelectionOperator = _cast(None, multipleGroupSelectionOperator)
        self.multipleGroupSelectionOperator_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if name is None:
            self.name = []
        else:
            self.name = name
        self.name_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupSelector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupSelector.subclass:
            return groupSelector.subclass(*args_, **kwargs_)
        else:
            return groupSelector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def add_name(self, value):
        self.name.append(value)
    def insert_name_at(self, index, value):
        self.name.insert(index, value)
    def replace_name_at(self, index, value):
        self.name[index] = value
    def get_multipleGroupSelectionOperator(self):
        return self.multipleGroupSelectionOperator
    def set_multipleGroupSelectionOperator(self, multipleGroupSelectionOperator):
        self.multipleGroupSelectionOperator = multipleGroupSelectionOperator
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_multipleGroupSelectionOperatorType(self, value):
        # Validate type multipleGroupSelectionOperatorType, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['and', 'or']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on multipleGroupSelectionOperatorType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.name
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='groupSelector', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('groupSelector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'groupSelector':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='groupSelector')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='groupSelector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='groupSelector'):
        if self.multipleGroupSelectionOperator != "or" and 'multipleGroupSelectionOperator' not in already_processed:
            already_processed.add('multipleGroupSelectionOperator')
            outfile.write(' multipleGroupSelectionOperator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.multipleGroupSelectionOperator), input_name='multipleGroupSelectionOperator')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='groupSelector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for name_ in self.name:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            name_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('multipleGroupSelectionOperator', node)
        if value is not None and 'multipleGroupSelectionOperator' not in already_processed:
            already_processed.add('multipleGroupSelectionOperator')
            self.multipleGroupSelectionOperator = value
            self.validate_multipleGroupSelectionOperatorType(self.multipleGroupSelectionOperator)    # validate type multipleGroupSelectionOperatorType
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            obj_ = nameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
# end class groupSelector


class generatorSelectorType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('groupSelector', 'groupSelector', 0, 0, {'name': 'groupSelector', 'ref': 'groupSelector', 'type': 'groupSelector'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, groupSelector=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.groupSelector = groupSelector
        self.groupSelector_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generatorSelectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generatorSelectorType.subclass:
            return generatorSelectorType.subclass(*args_, **kwargs_)
        else:
            return generatorSelectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_groupSelector(self):
        return self.groupSelector
    def set_groupSelector(self, groupSelector):
        self.groupSelector = groupSelector
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.groupSelector is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generatorSelectorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generatorSelectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'generatorSelectorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='generatorSelectorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='generatorSelectorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='generatorSelectorType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generatorSelectorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.groupSelector is not None:
            namespaceprefix_ = self.groupSelector_nsprefix_ + ':' if (UseCapturedNS_ and self.groupSelector_nsprefix_) else ''
            self.groupSelector.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='groupSelector', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'groupSelector':
            obj_ = groupSelector.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groupSelector = obj_
            obj_.original_tagname_ = 'groupSelector'
# end class generatorSelectorType


class componentGenerators(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('componentGenerator', 'instanceGeneratorType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'componentGenerator', 'ref': 'componentGenerator', 'type': 'componentGenerator'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentGenerator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if componentGenerator is None:
            self.componentGenerator = []
        else:
            self.componentGenerator = componentGenerator
        self.componentGenerator_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentGenerators)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentGenerators.subclass:
            return componentGenerators.subclass(*args_, **kwargs_)
        else:
            return componentGenerators(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_componentGenerator(self):
        return self.componentGenerator
    def set_componentGenerator(self, componentGenerator):
        self.componentGenerator = componentGenerator
    def add_componentGenerator(self, value):
        self.componentGenerator.append(value)
    def insert_componentGenerator_at(self, index, value):
        self.componentGenerator.insert(index, value)
    def replace_componentGenerator_at(self, index, value):
        self.componentGenerator[index] = value
    def _hasContent(self):
        if (
            self.componentGenerator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='componentGenerators', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentGenerators')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'componentGenerators':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='componentGenerators')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='componentGenerators', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='componentGenerators'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='componentGenerators', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for componentGenerator_ in self.componentGenerator:
            namespaceprefix_ = self.componentGenerator_nsprefix_ + ':' if (UseCapturedNS_ and self.componentGenerator_nsprefix_) else ''
            componentGenerator_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='componentGenerator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'componentGenerator':
            obj_ = instanceGeneratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.componentGenerator.append(obj_)
            obj_.original_tagname_ = 'componentGenerator'
# end class componentGenerators


class abstractorGenerators(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('abstractorGenerator', 'instanceGeneratorType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'abstractorGenerator', 'ref': 'abstractorGenerator', 'type': 'abstractorGenerator'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, abstractorGenerator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if abstractorGenerator is None:
            self.abstractorGenerator = []
        else:
            self.abstractorGenerator = abstractorGenerator
        self.abstractorGenerator_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorGenerators)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorGenerators.subclass:
            return abstractorGenerators.subclass(*args_, **kwargs_)
        else:
            return abstractorGenerators(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_abstractorGenerator(self):
        return self.abstractorGenerator
    def set_abstractorGenerator(self, abstractorGenerator):
        self.abstractorGenerator = abstractorGenerator
    def add_abstractorGenerator(self, value):
        self.abstractorGenerator.append(value)
    def insert_abstractorGenerator_at(self, index, value):
        self.abstractorGenerator.insert(index, value)
    def replace_abstractorGenerator_at(self, index, value):
        self.abstractorGenerator[index] = value
    def _hasContent(self):
        if (
            self.abstractorGenerator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorGenerators', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorGenerators')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractorGenerators':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractorGenerators')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractorGenerators', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='abstractorGenerators'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorGenerators', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for abstractorGenerator_ in self.abstractorGenerator:
            namespaceprefix_ = self.abstractorGenerator_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractorGenerator_nsprefix_) else ''
            abstractorGenerator_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='abstractorGenerator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'abstractorGenerator':
            obj_ = instanceGeneratorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractorGenerator.append(obj_)
            obj_.original_tagname_ = 'abstractorGenerator'
# end class abstractorGenerators


class generatorType(GeneratedsSuper):
    """name -- Unique name
    apiType -- Indicates the type of API used by the generator. Valid value are TGI_2009, TGI_2014_BASE, TGI_2014_EXTENDED, and none. If this element is not present, TGI_2014_BASE is assumed. The type TGI_2009 indicates a generator using the 1685-2009 version of the TGI API. This is not part of the 1685-2014 version of the standard and may not be supported by Design Environments.
    generatorExe -- The pathname to the executable file that implements the generator
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('hidden', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'hidden'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('phase', 'realExpression', 0, 1, {'minOccurs': '0', 'name': 'phase', 'ref': 'phase', 'type': 'phase'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('apiType', 'apiTypeType', 0, 1, {'minOccurs': '0', 'name': 'apiType', 'type': 'apiTypeType'}, None),
        MemberSpec_('transportMethods', 'transportMethodsType', 0, 1, {'minOccurs': '0', 'name': 'transportMethods', 'type': 'transportMethodsType'}, None),
        MemberSpec_('generatorExe', 'ipxactURI', 0, 0, {'name': 'generatorExe', 'type': 'ipxactURI'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, hidden=False, id=None, name=None, displayName=None, description=None, phase=None, parameters=None, apiType=None, transportMethods=None, generatorExe=None, vendorExtensions=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.hidden = _cast(bool, hidden)
        self.hidden_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.phase = phase
        self.phase_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.apiType = apiType
        self.apiType_nsprefix_ = "ipxact"
        self.transportMethods = transportMethods
        self.transportMethods_nsprefix_ = "ipxact"
        self.generatorExe = generatorExe
        self.generatorExe_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generatorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generatorType.subclass:
            return generatorType.subclass(*args_, **kwargs_)
        else:
            return generatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_phase(self):
        return self.phase
    def set_phase(self, phase):
        self.phase = phase
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_apiType(self):
        return self.apiType
    def set_apiType(self, apiType):
        self.apiType = apiType
    def get_transportMethods(self):
        return self.transportMethods
    def set_transportMethods(self, transportMethods):
        self.transportMethods = transportMethods
    def get_generatorExe(self):
        return self.generatorExe
    def set_generatorExe(self, generatorExe):
        self.generatorExe = generatorExe
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_hidden(self):
        return self.hidden
    def set_hidden(self, hidden):
        self.hidden = hidden
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.phase is not None or
            self.parameters is not None or
            self.apiType is not None or
            self.transportMethods is not None or
            self.generatorExe is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generatorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generatorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'generatorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='generatorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='generatorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='generatorType'):
        if self.hidden and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_boolean(self.hidden, input_name='hidden'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generatorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.phase is not None:
            namespaceprefix_ = self.phase_nsprefix_ + ':' if (UseCapturedNS_ and self.phase_nsprefix_) else ''
            self.phase.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='phase', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.apiType is not None:
            namespaceprefix_ = self.apiType_nsprefix_ + ':' if (UseCapturedNS_ and self.apiType_nsprefix_) else ''
            self.apiType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='apiType', pretty_print=pretty_print)
        if self.transportMethods is not None:
            namespaceprefix_ = self.transportMethods_nsprefix_ + ':' if (UseCapturedNS_ and self.transportMethods_nsprefix_) else ''
            self.transportMethods.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transportMethods', pretty_print=pretty_print)
        if self.generatorExe is not None:
            namespaceprefix_ = self.generatorExe_nsprefix_ + ':' if (UseCapturedNS_ and self.generatorExe_nsprefix_) else ''
            self.generatorExe.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generatorExe', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            if value in ('true', '1'):
                self.hidden = True
            elif value in ('false', '0'):
                self.hidden = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'phase':
            class_obj_ = self.get_class_obj_(child_, realExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.phase = obj_
            obj_.original_tagname_ = 'phase'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'apiType':
            obj_ = apiTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.apiType = obj_
            obj_.original_tagname_ = 'apiType'
        elif nodeName_ == 'transportMethods':
            obj_ = transportMethodsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transportMethods = obj_
            obj_.original_tagname_ = 'transportMethods'
        elif nodeName_ == 'generatorExe':
            class_obj_ = self.get_class_obj_(child_, ipxactURI)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generatorExe = obj_
            obj_.original_tagname_ = 'generatorExe'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class generatorType


class Component(GeneratedsSuper):
    """vendor -- Name of the vendor who supplies this file.
    library -- Name of the logical library this element belongs to.
    name -- The name of the object.
    version -- Indicates the version of the named element.
    componentGenerators -- Generator list is tools-specific.
    whiteboxElements -- A list of whiteboxElements
    cpus -- cpu's in the component
    otherClockDrivers -- Defines a set of clock drivers that are not directly associated with an input port of the component.
    resetTypes -- A list of user defined resetTypes applicable to this component.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'name': 'vendor', 'type': 'xs:Name'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'name': 'library', 'type': 'xs:Name'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'name': 'version', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('BusInterfaces', 'busInterfaces', 0, 1, {'minOccurs': '0', 'name': 'busInterfaces', 'ref': 'busInterfaces', 'type': 'busInterfaces'}, None),
        MemberSpec_('indirectInterfaces', 'indirectInterfaces', 0, 1, {'minOccurs': '0', 'name': 'indirectInterfaces', 'ref': 'indirectInterfaces', 'type': 'indirectInterfaces'}, None),
        MemberSpec_('channels', 'channels', 0, 1, {'minOccurs': '0', 'name': 'channels', 'ref': 'channels', 'type': 'channels'}, None),
        MemberSpec_('remapStates', 'remapStates', 0, 1, {'minOccurs': '0', 'name': 'remapStates', 'ref': 'remapStates', 'type': 'remapStates'}, None),
        MemberSpec_('addressSpaces', 'addressSpaces', 0, 1, {'minOccurs': '0', 'name': 'addressSpaces', 'ref': 'addressSpaces', 'type': 'addressSpaces'}, None),
        MemberSpec_('memoryMaps', 'memoryMaps', 0, 1, {'minOccurs': '0', 'name': 'memoryMaps', 'ref': 'memoryMaps', 'type': 'memoryMaps'}, None),
        MemberSpec_('model', 'modelType', 0, 1, {'minOccurs': '0', 'name': 'model', 'ref': 'model', 'type': 'model'}, None),
        MemberSpec_('componentGenerators', 'componentGenerators', 0, 1, {'minOccurs': '0', 'name': 'componentGenerators', 'ref': 'componentGenerators', 'type': 'componentGenerators'}, None),
        MemberSpec_('choices', 'choices', 0, 1, {'minOccurs': '0', 'name': 'choices', 'ref': 'choices', 'type': 'choices'}, None),
        MemberSpec_('fileSets', 'fileSets', 0, 1, {'minOccurs': '0', 'name': 'fileSets', 'ref': 'fileSets', 'type': 'fileSets'}, None),
        MemberSpec_('whiteboxElements', 'whiteboxElementsType', 0, 1, {'minOccurs': '0', 'name': 'whiteboxElements', 'type': 'whiteboxElementsType'}, None),
        MemberSpec_('cpus', 'cpusType', 0, 1, {'minOccurs': '0', 'name': 'cpus', 'type': 'cpusType'}, None),
        MemberSpec_('otherClockDrivers', 'otherClocks', 0, 1, {'minOccurs': '0', 'name': 'otherClockDrivers', 'type': 'otherClocks'}, None),
        MemberSpec_('resetTypes', 'resetTypesType', 0, 1, {'minOccurs': '0', 'name': 'resetTypes', 'type': 'resetTypesType'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'name': 'assertions', 'ref': 'assertions', 'type': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, BusInterfaces=None, indirectInterfaces=None, channels=None, remapStates=None, addressSpaces=None, memoryMaps=None, model=None, componentGenerators=None, choices=None, fileSets=None, whiteboxElements=None, cpus=None, otherClockDrivers=None, resetTypes=None, description=None, parameters=None, assertions=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.vendor = vendor
        self.vendor_nsprefix_ = "ipxact"
        self.library = library
        self.library_nsprefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.version = version
        self.version_nsprefix_ = "ipxact"
        self.BusInterfaces = BusInterfaces
        self.BusInterfaces_nsprefix_ = "ipxact"
        self.indirectInterfaces = indirectInterfaces
        self.indirectInterfaces_nsprefix_ = "ipxact"
        self.channels = channels
        self.channels_nsprefix_ = "ipxact"
        self.remapStates = remapStates
        self.remapStates_nsprefix_ = "ipxact"
        self.addressSpaces = addressSpaces
        self.addressSpaces_nsprefix_ = "ipxact"
        self.memoryMaps = memoryMaps
        self.memoryMaps_nsprefix_ = "ipxact"
        self.model = model
        self.model_nsprefix_ = "ipxact"
        self.componentGenerators = componentGenerators
        self.componentGenerators_nsprefix_ = "ipxact"
        self.choices = choices
        self.choices_nsprefix_ = "ipxact"
        self.fileSets = fileSets
        self.fileSets_nsprefix_ = "ipxact"
        self.whiteboxElements = whiteboxElements
        self.whiteboxElements_nsprefix_ = "ipxact"
        self.cpus = cpus
        self.cpus_nsprefix_ = "ipxact"
        self.otherClockDrivers = otherClockDrivers
        self.otherClockDrivers_nsprefix_ = "ipxact"
        self.resetTypes = resetTypes
        self.resetTypes_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.assertions = assertions
        self.assertions_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Component)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Component.subclass:
            return Component.subclass(*args_, **kwargs_)
        else:
            return Component(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_busInterfaces(self):
        return self.BusInterfaces
    def set_busInterfaces(self, BusInterfaces):
        self.BusInterfaces = BusInterfaces
    def get_indirectInterfaces(self):
        return self.indirectInterfaces
    def set_indirectInterfaces(self, indirectInterfaces):
        self.indirectInterfaces = indirectInterfaces
    def get_channels(self):
        return self.channels
    def set_channels(self, channels):
        self.channels = channels
    def get_remapStates(self):
        return self.remapStates
    def set_remapStates(self, remapStates):
        self.remapStates = remapStates
    def get_addressSpaces(self):
        return self.addressSpaces
    def set_addressSpaces(self, addressSpaces):
        self.addressSpaces = addressSpaces
    def get_memoryMaps(self):
        return self.memoryMaps
    def set_memoryMaps(self, memoryMaps):
        self.memoryMaps = memoryMaps
    def get_model(self):
        return self.model
    def set_model(self, model):
        self.model = model
    def get_componentGenerators(self):
        return self.componentGenerators
    def set_componentGenerators(self, componentGenerators):
        self.componentGenerators = componentGenerators
    def get_choices(self):
        return self.choices
    def set_choices(self, choices):
        self.choices = choices
    def get_fileSets(self):
        return self.fileSets
    def set_fileSets(self, fileSets):
        self.fileSets = fileSets
    def get_whiteboxElements(self):
        return self.whiteboxElements
    def set_whiteboxElements(self, whiteboxElements):
        self.whiteboxElements = whiteboxElements
    def get_cpus(self):
        return self.cpus
    def set_cpus(self, cpus):
        self.cpus = cpus
    def get_otherClockDrivers(self):
        return self.otherClockDrivers
    def set_otherClockDrivers(self, otherClockDrivers):
        self.otherClockDrivers = otherClockDrivers
    def get_resetTypes(self):
        return self.resetTypes
    def set_resetTypes(self, resetTypes):
        self.resetTypes = resetTypes
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_assertions(self):
        return self.assertions
    def set_assertions(self, assertions):
        self.assertions = assertions
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.BusInterfaces is not None or
            self.indirectInterfaces is not None or
            self.channels is not None or
            self.remapStates is not None or
            self.addressSpaces is not None or
            self.memoryMaps is not None or
            self.model is not None or
            self.componentGenerators is not None or
            self.choices is not None or
            self.fileSets is not None or
            self.whiteboxElements is not None or
            self.cpus is not None or
            self.otherClockDrivers is not None or
            self.resetTypes is not None or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='componentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'componentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='componentType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='componentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='componentType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='componentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            namespaceprefix_ = self.vendor_nsprefix_ + ':' if (UseCapturedNS_ and self.vendor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), namespaceprefix_ , eol_))
        if self.library is not None:
            namespaceprefix_ = self.library_nsprefix_ + ':' if (UseCapturedNS_ and self.library_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slibrary>%s</%slibrary>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespaceprefix_ , eol_))
        if self.BusInterfaces is not None:
            namespaceprefix_ = self.BusInterfaces_nsprefix_ + ':' if (UseCapturedNS_ and self.BusInterfaces_nsprefix_) else ''
            self.BusInterfaces.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='busInterfaces', pretty_print=pretty_print)
        if self.indirectInterfaces is not None:
            namespaceprefix_ = self.indirectInterfaces_nsprefix_ + ':' if (UseCapturedNS_ and self.indirectInterfaces_nsprefix_) else ''
            self.indirectInterfaces.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='indirectInterfaces', pretty_print=pretty_print)
        if self.channels is not None:
            namespaceprefix_ = self.channels_nsprefix_ + ':' if (UseCapturedNS_ and self.channels_nsprefix_) else ''
            self.channels.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='channels', pretty_print=pretty_print)
        if self.remapStates is not None:
            namespaceprefix_ = self.remapStates_nsprefix_ + ':' if (UseCapturedNS_ and self.remapStates_nsprefix_) else ''
            self.remapStates.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='remapStates', pretty_print=pretty_print)
        if self.addressSpaces is not None:
            namespaceprefix_ = self.addressSpaces_nsprefix_ + ':' if (UseCapturedNS_ and self.addressSpaces_nsprefix_) else ''
            self.addressSpaces.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='addressSpaces', pretty_print=pretty_print)
        if self.memoryMaps is not None:
            namespaceprefix_ = self.memoryMaps_nsprefix_ + ':' if (UseCapturedNS_ and self.memoryMaps_nsprefix_) else ''
            self.memoryMaps.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='memoryMaps', pretty_print=pretty_print)
        if self.model is not None:
            namespaceprefix_ = self.model_nsprefix_ + ':' if (UseCapturedNS_ and self.model_nsprefix_) else ''
            self.model.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='model', pretty_print=pretty_print)
        if self.componentGenerators is not None:
            namespaceprefix_ = self.componentGenerators_nsprefix_ + ':' if (UseCapturedNS_ and self.componentGenerators_nsprefix_) else ''
            self.componentGenerators.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='componentGenerators', pretty_print=pretty_print)
        if self.choices is not None:
            namespaceprefix_ = self.choices_nsprefix_ + ':' if (UseCapturedNS_ and self.choices_nsprefix_) else ''
            self.choices.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='choices', pretty_print=pretty_print)
        if self.fileSets is not None:
            namespaceprefix_ = self.fileSets_nsprefix_ + ':' if (UseCapturedNS_ and self.fileSets_nsprefix_) else ''
            self.fileSets.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='fileSets', pretty_print=pretty_print)
        if self.whiteboxElements is not None:
            namespaceprefix_ = self.whiteboxElements_nsprefix_ + ':' if (UseCapturedNS_ and self.whiteboxElements_nsprefix_) else ''
            self.whiteboxElements.export(outfile, level, namespaceprefix_, namespacedef_='', name_='whiteboxElements', pretty_print=pretty_print)
        if self.cpus is not None:
            namespaceprefix_ = self.cpus_nsprefix_ + ':' if (UseCapturedNS_ and self.cpus_nsprefix_) else ''
            self.cpus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cpus', pretty_print=pretty_print)
        if self.otherClockDrivers is not None:
            namespaceprefix_ = self.otherClockDrivers_nsprefix_ + ':' if (UseCapturedNS_ and self.otherClockDrivers_nsprefix_) else ''
            self.otherClockDrivers.export(outfile, level, namespaceprefix_, namespacedef_='', name_='otherClockDrivers', pretty_print=pretty_print)
        if self.resetTypes is not None:
            namespaceprefix_ = self.resetTypes_nsprefix_ + ':' if (UseCapturedNS_ and self.resetTypes_nsprefix_) else ''
            self.resetTypes.export(outfile, level, namespaceprefix_, namespacedef_='', name_='resetTypes', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            namespaceprefix_ = self.assertions_nsprefix_ + ':' if (UseCapturedNS_ and self.assertions_nsprefix_) else ''
            self.assertions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vendor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vendor')
            value_ = self.gds_validate_string(value_, node, 'vendor')
            self.vendor = value_
            self.vendor_nsprefix_ = child_.prefix
        elif nodeName_ == 'library':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'library')
            value_ = self.gds_validate_string(value_, node, 'library')
            self.library = value_
            self.library_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'version')
            value_ = self.gds_validate_string(value_, node, 'version')
            self.version = value_
            self.version_nsprefix_ = child_.prefix
        elif nodeName_ == 'busInterfaces':
            obj_ = BusInterfaces.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BusInterfaces = obj_
            obj_.original_tagname_ = 'busInterfaces'
        elif nodeName_ == 'indirectInterfaces':
            obj_ = indirectInterfaces.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.indirectInterfaces = obj_
            obj_.original_tagname_ = 'indirectInterfaces'
        elif nodeName_ == 'channels':
            obj_ = channels.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channels = obj_
            obj_.original_tagname_ = 'channels'
        elif nodeName_ == 'remapStates':
            obj_ = remapStates.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remapStates = obj_
            obj_.original_tagname_ = 'remapStates'
        elif nodeName_ == 'addressSpaces':
            obj_ = addressSpaces.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressSpaces = obj_
            obj_.original_tagname_ = 'addressSpaces'
        elif nodeName_ == 'memoryMaps':
            obj_ = memoryMaps.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.memoryMaps = obj_
            obj_.original_tagname_ = 'memoryMaps'
        elif nodeName_ == 'model':
            obj_ = Model.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.model = obj_
            obj_.original_tagname_ = 'model'
        elif nodeName_ == 'componentGenerators':
            obj_ = componentGenerators.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.componentGenerators = obj_
            obj_.original_tagname_ = 'componentGenerators'
        elif nodeName_ == 'choices':
            obj_ = choices.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.choices = obj_
            obj_.original_tagname_ = 'choices'
        elif nodeName_ == 'fileSets':
            obj_ = fileSets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileSets = obj_
            obj_.original_tagname_ = 'fileSets'
        elif nodeName_ == 'whiteboxElements':
            obj_ = whiteboxElementsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.whiteboxElements = obj_
            obj_.original_tagname_ = 'whiteboxElements'
        elif nodeName_ == 'cpus':
            obj_ = cpusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cpus = obj_
            obj_.original_tagname_ = 'cpus'
        elif nodeName_ == 'otherClockDrivers':
            obj_ = otherClocks.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.otherClockDrivers = obj_
            obj_.original_tagname_ = 'otherClockDrivers'
        elif nodeName_ == 'resetTypes':
            obj_ = resetTypesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.resetTypes = obj_
            obj_.original_tagname_ = 'resetTypes'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class Component


class whiteboxElementType(GeneratedsSuper):
    """name -- Unique name
    whiteboxType -- Indicates the type of the element. The pin and signal types refer to elements within the HDL description. The register type refers to a register in the memory map. The interface type refers to a group of signals addressed as a single unit.
    driveable -- If true, indicates that the white box element can be driven (e.g. have a new value forced into it).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('whiteboxType', ['simpleWhiteboxType', 'xs:token'], 0, 0, {'name': 'whiteboxType', 'type': 'xs:token'}, None),
        MemberSpec_('driveable', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'driveable', 'type': 'xs:boolean'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, whiteboxType=None, driveable=False, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.whiteboxType = whiteboxType
        self.validate_simpleWhiteboxType(self.whiteboxType)
        self.whiteboxType_nsprefix_ = "ipxact"
        self.driveable = driveable
        self.driveable_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, whiteboxElementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if whiteboxElementType.subclass:
            return whiteboxElementType.subclass(*args_, **kwargs_)
        else:
            return whiteboxElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_whiteboxType(self):
        return self.whiteboxType
    def set_whiteboxType(self, whiteboxType):
        self.whiteboxType = whiteboxType
    def get_driveable(self):
        return self.driveable
    def set_driveable(self, driveable):
        self.driveable = driveable
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_simpleWhiteboxType(self, value):
        result = True
        # Validate type simpleWhiteboxType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['signal', 'pin', 'interface']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on simpleWhiteboxType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.whiteboxType is not None or
            self.driveable or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='whiteboxElementType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('whiteboxElementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'whiteboxElementType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='whiteboxElementType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='whiteboxElementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='whiteboxElementType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='whiteboxElementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.whiteboxType is not None:
            namespaceprefix_ = self.whiteboxType_nsprefix_ + ':' if (UseCapturedNS_ and self.whiteboxType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swhiteboxType>%s</%swhiteboxType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.whiteboxType), input_name='whiteboxType')), namespaceprefix_ , eol_))
        if self.driveable:
            namespaceprefix_ = self.driveable_nsprefix_ + ':' if (UseCapturedNS_ and self.driveable_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdriveable>%s</%sdriveable>%s' % (namespaceprefix_ , self.gds_format_boolean(self.driveable, input_name='driveable'), namespaceprefix_ , eol_))
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'whiteboxType':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'whiteboxType')
            value_ = self.gds_validate_string(value_, node, 'whiteboxType')
            self.whiteboxType = value_
            self.whiteboxType_nsprefix_ = child_.prefix
            # validate type simpleWhiteboxType
            self.validate_simpleWhiteboxType(self.whiteboxType)
        elif nodeName_ == 'driveable':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'driveable')
            ival_ = self.gds_validate_boolean(ival_, node, 'driveable')
            self.driveable = ival_
            self.driveable_nsprefix_ = child_.prefix
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class whiteboxElementType


class complexBitSteeringExpression(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', ['simpleBitSteeringExpression', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complexBitSteeringExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complexBitSteeringExpression.subclass:
            return complexBitSteeringExpression.subclass(*args_, **kwargs_)
        else:
            return complexBitSteeringExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_simpleBitSteeringExpression(self, value):
        result = True
        # Validate type simpleBitSteeringExpression, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='complexBitSteeringExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complexBitSteeringExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'complexBitSteeringExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='complexBitSteeringExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='complexBitSteeringExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='complexBitSteeringExpression'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='complexBitSteeringExpression', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class complexBitSteeringExpression


class viewRef(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:NMTOKEN', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRef.subclass:
            return viewRef.subclass(*args_, **kwargs_)
        else:
            return viewRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRef', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewRef':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewRef')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='viewRef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class viewRef


class BusInterfaces(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('BusInterface', 'busInterface', 1, 0, {'maxOccurs': 'unbounded', 'name': 'busInterface', 'ref': 'busInterface', 'type': 'busInterface'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, BusInterface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if BusInterface is None:
            self.BusInterface = []
        else:
            self.BusInterface = BusInterface
        self.BusInterface_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusInterfaces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusInterfaces.subclass:
            return BusInterfaces.subclass(*args_, **kwargs_)
        else:
            return BusInterfaces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_busInterface(self):
        return self.BusInterface
    def set_busInterface(self, BusInterface):
        self.BusInterface = BusInterface
    def add_busInterface(self, value):
        self.BusInterface.append(value)
    def insert_busInterface_at(self, index, value):
        self.BusInterface.insert(index, value)
    def replace_busInterface_at(self, index, value):
        self.BusInterface[index] = value
    def _hasContent(self):
        if (
            self.BusInterface
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='busInterfaces', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('busInterfaces')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'busInterfaces':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='busInterfaces')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='busInterfaces', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='busInterfaces'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='busInterfaces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for busInterface_ in self.BusInterface:
            namespaceprefix_ = self.BusInterface_nsprefix_ + ':' if (UseCapturedNS_ and self.BusInterface_nsprefix_) else ''
            busInterface_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='busInterface', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'busInterface':
            obj_ = BusInterface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BusInterface.append(obj_)
            obj_.original_tagname_ = 'busInterface'
# end class BusInterfaces


class BusInterface(GeneratedsSuper):
    """name -- Unique name
    busType -- The bus type of this interface. Refers to bus definition using vendor, library, name, version attributes along with any configurable element values needed to configure this interface.
    master -- If this element is present, the bus interface can serve as a master.  This element encapsulates additional information related to its role as master.
    slave -- If this element is present, the bus interface can serve as a slave.
    system -- If this element is present, the bus interface is a system interface, neither master nor slave, with a specific function on the bus.
    mirroredSlave -- If this element is present, the bus interface represents a mirrored slave interface. All directional constraints on ports are reversed relative to the specification in the bus definition.
    mirroredMaster -- If this element is present, the bus interface represents a mirrored master interface. All directional constraints on ports are reversed relative to the specification in the bus definition.
    mirroredSystem -- If this element is present, the bus interface represents a mirrored system interface. All directional constraints on ports are reversed relative to the specification in the bus definition.
    monitor -- Indicates that this is a (passive) monitor interface. All of the ports in the interface must be inputs. The type of interface to be monitored is specified with the required interfaceType attribute. The ipxact:group element must be specified if monitoring a system interface.
    connectionRequired -- Indicates whether a connection to this interface is required for proper component functionality.
    bitSteering -- Indicates whether bit steering should be used to map this interface onto a bus of different data width.
    Values are "on", "off" (defaults to "off").
    endianness -- 'big': means the most significant element of any multi-element  data field is stored at the lowest memory address. 'little' means the least significant element of any multi-element data field is stored at the lowest memory address. If this element is not present the default is 'little' endian.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('busType', 'configurableLibraryRefType', 0, 0, {'name': 'busType', 'type': 'configurableLibraryRefType'}, None),
        MemberSpec_('AbstractionTypes', 'abstractionTypes', 0, 1, {'minOccurs': '0', 'name': 'abstractionTypes', 'ref': 'abstractionTypes', 'type': 'abstractionTypes'}, None),
        MemberSpec_('master', 'masterType', 0, 0, {'name': 'master', 'type': 'masterType'}, None),
        MemberSpec_('slave', 'slaveType', 0, 0, {'name': 'slave', 'type': 'slaveType'}, None),
        MemberSpec_('system', 'systemType', 0, 0, {'name': 'system', 'type': 'systemType'}, None),
        MemberSpec_('mirroredSlave', 'mirroredSlaveType', 0, 0, {'name': 'mirroredSlave', 'type': 'mirroredSlaveType'}, None),
        MemberSpec_('mirroredMaster', 'mirroredMasterType', 0, 0, {'name': 'mirroredMaster', 'type': 'mirroredMasterType'}, None),
        MemberSpec_('mirroredSystem', 'mirroredSystemType', 0, 0, {'name': 'mirroredSystem', 'type': 'mirroredSystemType'}, None),
        MemberSpec_('monitor', 'monitorType', 0, 0, {'name': 'monitor', 'type': 'monitorType'}, None),
        MemberSpec_('connectionRequired', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'connectionRequired', 'type': 'xs:boolean'}, None),
        MemberSpec_('bitsInLau', 'unsignedPositiveLongintExpression', 0, 1, {'minOccurs': '0', 'name': 'bitsInLau', 'ref': 'bitsInLau', 'type': 'bitsInLau'}, None),
        MemberSpec_('bitSteering', 'complexBitSteeringExpression', 0, 1, {'default': 'off', 'minOccurs': '0', 'name': 'bitSteering', 'type': 'complexBitSteeringExpression'}, None),
        MemberSpec_('endianness', ['endianessType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'endianness', 'type': 'xs:string'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, isPresent=None, busType=None, AbstractionTypes=None, master=None, slave=None, system=None, mirroredSlave=None, mirroredMaster=None, mirroredSystem=None, monitor=None, connectionRequired=False, bitsInLau=None, bitSteering=None, endianness=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.busType = busType
        self.busType_nsprefix_ = "ipxact"
        self.AbstractionTypes = AbstractionTypes
        self.AbstractionTypes_nsprefix_ = "ipxact"
        self.master = master
        self.master_nsprefix_ = "ipxact"
        self.slave = slave
        self.slave_nsprefix_ = "ipxact"
        self.system = system
        self.system_nsprefix_ = "ipxact"
        self.mirroredSlave = mirroredSlave
        self.mirroredSlave_nsprefix_ = "ipxact"
        self.mirroredMaster = mirroredMaster
        self.mirroredMaster_nsprefix_ = "ipxact"
        self.mirroredSystem = mirroredSystem
        self.mirroredSystem_nsprefix_ = "ipxact"
        self.monitor = monitor
        self.monitor_nsprefix_ = "ipxact"
        self.connectionRequired = connectionRequired
        self.connectionRequired_nsprefix_ = "ipxact"
        self.bitsInLau = bitsInLau
        self.bitsInLau_nsprefix_ = "ipxact"
        if bitSteering is None:
            self.bitSteering = globals()['complexBitSteeringExpression']('off')
        else:
            self.bitSteering = bitSteering
        self.bitSteering_nsprefix_ = "ipxact"
        self.endianness = endianness
        self.validate_endianessType(self.endianness)
        self.endianness_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusInterface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusInterface.subclass:
            return BusInterface.subclass(*args_, **kwargs_)
        else:
            return BusInterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_busType(self):
        return self.busType
    def set_busType(self, busType):
        self.busType = busType
    def get_abstractionTypes(self):
        return self.AbstractionTypes
    def set_abstractionTypes(self, AbstractionTypes):
        self.AbstractionTypes = AbstractionTypes
    def get_master(self):
        return self.master
    def set_master(self, master):
        self.master = master
    def get_slave(self):
        return self.slave
    def set_slave(self, slave):
        self.slave = slave
    def get_system(self):
        return self.system
    def set_system(self, system):
        self.system = system
    def get_mirroredSlave(self):
        return self.mirroredSlave
    def set_mirroredSlave(self, mirroredSlave):
        self.mirroredSlave = mirroredSlave
    def get_mirroredMaster(self):
        return self.mirroredMaster
    def set_mirroredMaster(self, mirroredMaster):
        self.mirroredMaster = mirroredMaster
    def get_mirroredSystem(self):
        return self.mirroredSystem
    def set_mirroredSystem(self, mirroredSystem):
        self.mirroredSystem = mirroredSystem
    def get_monitor(self):
        return self.monitor
    def set_monitor(self, monitor):
        self.monitor = monitor
    def get_connectionRequired(self):
        return self.connectionRequired
    def set_connectionRequired(self, connectionRequired):
        self.connectionRequired = connectionRequired
    def get_bitsInLau(self):
        return self.bitsInLau
    def set_bitsInLau(self, bitsInLau):
        self.bitsInLau = bitsInLau
    def get_bitSteering(self):
        return self.bitSteering
    def set_bitSteering(self, bitSteering):
        self.bitSteering = bitSteering
    def get_endianness(self):
        return self.endianness
    def set_endianness(self, endianness):
        self.endianness = endianness
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def validate_endianessType(self, value):
        result = True
        # Validate type endianessType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['big', 'little']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on endianessType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.busType is not None or
            self.AbstractionTypes is not None or
            self.master is not None or
            self.slave is not None or
            self.system is not None or
            self.mirroredSlave is not None or
            self.mirroredMaster is not None or
            self.mirroredSystem is not None or
            self.monitor is not None or
            self.connectionRequired or
            self.bitsInLau is not None or
            self.bitSteering is not None or
            self.endianness is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='busInterfaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('busInterfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'busInterfaceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='busInterfaceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='busInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='busInterfaceType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='busInterfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.busType is not None:
            namespaceprefix_ = self.busType_nsprefix_ + ':' if (UseCapturedNS_ and self.busType_nsprefix_) else ''
            self.busType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='busType', pretty_print=pretty_print)
        if self.AbstractionTypes is not None:
            namespaceprefix_ = self.AbstractionTypes_nsprefix_ + ':' if (UseCapturedNS_ and self.AbstractionTypes_nsprefix_) else ''
            self.AbstractionTypes.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='abstractionTypes', pretty_print=pretty_print)
        if self.master is not None:
            namespaceprefix_ = self.master_nsprefix_ + ':' if (UseCapturedNS_ and self.master_nsprefix_) else ''
            self.master.export(outfile, level, namespaceprefix_, namespacedef_='', name_='master', pretty_print=pretty_print)
        if self.slave is not None:
            namespaceprefix_ = self.slave_nsprefix_ + ':' if (UseCapturedNS_ and self.slave_nsprefix_) else ''
            self.slave.export(outfile, level, namespaceprefix_, namespacedef_='', name_='slave', pretty_print=pretty_print)
        if self.system is not None:
            namespaceprefix_ = self.system_nsprefix_ + ':' if (UseCapturedNS_ and self.system_nsprefix_) else ''
            self.system.export(outfile, level, namespaceprefix_, namespacedef_='', name_='system', pretty_print=pretty_print)
        if self.mirroredSlave is not None:
            namespaceprefix_ = self.mirroredSlave_nsprefix_ + ':' if (UseCapturedNS_ and self.mirroredSlave_nsprefix_) else ''
            self.mirroredSlave.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mirroredSlave', pretty_print=pretty_print)
        if self.mirroredMaster is not None:
            namespaceprefix_ = self.mirroredMaster_nsprefix_ + ':' if (UseCapturedNS_ and self.mirroredMaster_nsprefix_) else ''
            self.mirroredMaster.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mirroredMaster', pretty_print=pretty_print)
        if self.mirroredSystem is not None:
            namespaceprefix_ = self.mirroredSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.mirroredSystem_nsprefix_) else ''
            self.mirroredSystem.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mirroredSystem', pretty_print=pretty_print)
        if self.monitor is not None:
            namespaceprefix_ = self.monitor_nsprefix_ + ':' if (UseCapturedNS_ and self.monitor_nsprefix_) else ''
            self.monitor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='monitor', pretty_print=pretty_print)
        if self.connectionRequired:
            namespaceprefix_ = self.connectionRequired_nsprefix_ + ':' if (UseCapturedNS_ and self.connectionRequired_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconnectionRequired>%s</%sconnectionRequired>%s' % (namespaceprefix_ , self.gds_format_boolean(self.connectionRequired, input_name='connectionRequired'), namespaceprefix_ , eol_))
        if self.bitsInLau is not None:
            namespaceprefix_ = self.bitsInLau_nsprefix_ + ':' if (UseCapturedNS_ and self.bitsInLau_nsprefix_) else ''
            self.bitsInLau.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='bitsInLau', pretty_print=pretty_print)
        if self.bitSteering is not None:
            namespaceprefix_ = self.bitSteering_nsprefix_ + ':' if (UseCapturedNS_ and self.bitSteering_nsprefix_) else ''
            self.bitSteering.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bitSteering', pretty_print=pretty_print)
        if self.endianness is not None:
            namespaceprefix_ = self.endianness_nsprefix_ + ':' if (UseCapturedNS_ and self.endianness_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendianness>%s</%sendianness>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.endianness), input_name='endianness')), namespaceprefix_ , eol_))
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'busType':
            obj_ = ConfigurableLibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.busType = obj_
            obj_.original_tagname_ = 'busType'
        elif nodeName_ == 'abstractionTypes':
            obj_ = AbstractionTypes.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AbstractionTypes = obj_
            obj_.original_tagname_ = 'abstractionTypes'
        elif nodeName_ == 'master':
            obj_ = Master.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.master = obj_
            obj_.original_tagname_ = 'master'
        elif nodeName_ == 'slave':
            obj_ = Slave.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.slave = obj_
            obj_.original_tagname_ = 'slave'
        elif nodeName_ == 'system':
            obj_ = systemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.system = obj_
            obj_.original_tagname_ = 'system'
        elif nodeName_ == 'mirroredSlave':
            obj_ = mirroredSlaveType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mirroredSlave = obj_
            obj_.original_tagname_ = 'mirroredSlave'
        elif nodeName_ == 'mirroredMaster':
            obj_ = mirroredMasterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mirroredMaster = obj_
            obj_.original_tagname_ = 'mirroredMaster'
        elif nodeName_ == 'mirroredSystem':
            obj_ = mirroredSystemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mirroredSystem = obj_
            obj_.original_tagname_ = 'mirroredSystem'
        elif nodeName_ == 'monitor':
            obj_ = monitorType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.monitor = obj_
            obj_.original_tagname_ = 'monitor'
        elif nodeName_ == 'connectionRequired':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'connectionRequired')
            ival_ = self.gds_validate_boolean(ival_, node, 'connectionRequired')
            self.connectionRequired = ival_
            self.connectionRequired_nsprefix_ = child_.prefix
        elif nodeName_ == 'bitsInLau':
            obj_ = unsignedPositiveLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bitsInLau = obj_
            obj_.original_tagname_ = 'bitsInLau'
        elif nodeName_ == 'bitSteering':
            obj_ = complexBitSteeringExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bitSteering = obj_
            obj_.original_tagname_ = 'bitSteering'
        elif nodeName_ == 'endianness':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'endianness')
            value_ = self.gds_validate_string(value_, node, 'endianness')
            self.endianness = value_
            self.endianness_nsprefix_ = child_.prefix
            # validate type endianessType
            self.validate_endianessType(self.endianness)
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class BusInterface


class channels(GeneratedsSuper):
    """channel -- Defines a set of mirrored interfaces of this component that are connected to one another.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('channel', 'channelType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'channel', 'type': 'channelType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, channel=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if channel is None:
            self.channel = []
        else:
            self.channel = channel
        self.channel_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, channels)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if channels.subclass:
            return channels.subclass(*args_, **kwargs_)
        else:
            return channels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_channel(self):
        return self.channel
    def set_channel(self, channel):
        self.channel = channel
    def add_channel(self, value):
        self.channel.append(value)
    def insert_channel_at(self, index, value):
        self.channel.insert(index, value)
    def replace_channel_at(self, index, value):
        self.channel[index] = value
    def _hasContent(self):
        if (
            self.channel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='channels', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('channels')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'channels':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='channels')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='channels', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='channels'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='channels', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for channel_ in self.channel:
            namespaceprefix_ = self.channel_nsprefix_ + ':' if (UseCapturedNS_ and self.channel_nsprefix_) else ''
            channel_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='channel', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'channel':
            obj_ = channelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.channel.append(obj_)
            obj_.original_tagname_ = 'channel'
# end class channels


class remapStates(GeneratedsSuper):
    """remapState -- Contains a list of ports and values in remapPort and a list of registers and values that when all evaluate to true which tell the decoder to enter this remap state. The name attribute identifies the name of the state. If
    a list of remapPorts and/or remapRegisters is not defined then the condition for that state cannot be defined.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('remapState', 'remapStateType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'remapState', 'type': 'remapStateType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, remapState=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if remapState is None:
            self.remapState = []
        else:
            self.remapState = remapState
        self.remapState_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapStates.subclass:
            return remapStates.subclass(*args_, **kwargs_)
        else:
            return remapStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_remapState(self):
        return self.remapState
    def set_remapState(self, remapState):
        self.remapState = remapState
    def add_remapState(self, value):
        self.remapState.append(value)
    def insert_remapState_at(self, index, value):
        self.remapState.insert(index, value)
    def replace_remapState_at(self, index, value):
        self.remapState[index] = value
    def _hasContent(self):
        if (
            self.remapState
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapStates', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapStates')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'remapStates':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='remapStates')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='remapStates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='remapStates'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapStates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remapState_ in self.remapState:
            namespaceprefix_ = self.remapState_nsprefix_ + ':' if (UseCapturedNS_ and self.remapState_nsprefix_) else ''
            remapState_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='remapState', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'remapState':
            obj_ = remapStateType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remapState.append(obj_)
            obj_.original_tagname_ = 'remapState'
# end class remapStates


class transparentBridge(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('masterRef', 'xs:Name', 0, 0, {'use': 'required', 'name': 'masterRef'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, masterRef=None, id=None, isPresent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.masterRef = _cast(None, masterRef)
        self.masterRef_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transparentBridge)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transparentBridge.subclass:
            return transparentBridge.subclass(*args_, **kwargs_)
        else:
            return transparentBridge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_masterRef(self):
        return self.masterRef
    def set_masterRef(self, masterRef):
        self.masterRef = masterRef
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transparentBridge', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transparentBridge')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'transparentBridge':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transparentBridge')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='transparentBridge', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='transparentBridge'):
        if self.masterRef is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            outfile.write(' masterRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.masterRef), input_name='masterRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transparentBridge', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterRef', node)
        if value is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            self.masterRef = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class transparentBridge


class abstractorBusInterfaceType(GeneratedsSuper):
    """name -- Unique name
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('AbstractionTypes', 'abstractionTypes', 0, 1, {'minOccurs': '0', 'name': 'abstractionTypes', 'ref': 'abstractionTypes', 'type': 'abstractionTypes'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, AbstractionTypes=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.AbstractionTypes = AbstractionTypes
        self.AbstractionTypes_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorBusInterfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorBusInterfaceType.subclass:
            return abstractorBusInterfaceType.subclass(*args_, **kwargs_)
        else:
            return abstractorBusInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_abstractionTypes(self):
        return self.AbstractionTypes
    def set_abstractionTypes(self, AbstractionTypes):
        self.AbstractionTypes = AbstractionTypes
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.AbstractionTypes is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorBusInterfaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorBusInterfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractorBusInterfaceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractorBusInterfaceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractorBusInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='abstractorBusInterfaceType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorBusInterfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.AbstractionTypes is not None:
            namespaceprefix_ = self.AbstractionTypes_nsprefix_ + ':' if (UseCapturedNS_ and self.AbstractionTypes_nsprefix_) else ''
            self.AbstractionTypes.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='abstractionTypes', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'abstractionTypes':
            obj_ = AbstractionTypes.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AbstractionTypes = obj_
            obj_.original_tagname_ = 'abstractionTypes'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class abstractorBusInterfaceType


class indirectInterfaces(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('indirectInterface', 'indirectInterfaceType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'indirectInterface', 'ref': 'indirectInterface', 'type': 'indirectInterface'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, indirectInterface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if indirectInterface is None:
            self.indirectInterface = []
        else:
            self.indirectInterface = indirectInterface
        self.indirectInterface_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indirectInterfaces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indirectInterfaces.subclass:
            return indirectInterfaces.subclass(*args_, **kwargs_)
        else:
            return indirectInterfaces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_indirectInterface(self):
        return self.indirectInterface
    def set_indirectInterface(self, indirectInterface):
        self.indirectInterface = indirectInterface
    def add_indirectInterface(self, value):
        self.indirectInterface.append(value)
    def insert_indirectInterface_at(self, index, value):
        self.indirectInterface.insert(index, value)
    def replace_indirectInterface_at(self, index, value):
        self.indirectInterface[index] = value
    def _hasContent(self):
        if (
            self.indirectInterface
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indirectInterfaces', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indirectInterfaces')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'indirectInterfaces':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='indirectInterfaces')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='indirectInterfaces', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='indirectInterfaces'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indirectInterfaces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for indirectInterface_ in self.indirectInterface:
            namespaceprefix_ = self.indirectInterface_nsprefix_ + ':' if (UseCapturedNS_ and self.indirectInterface_nsprefix_) else ''
            indirectInterface_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='indirectInterface', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'indirectInterface':
            obj_ = indirectInterfaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.indirectInterface.append(obj_)
            obj_.original_tagname_ = 'indirectInterface'
# end class indirectInterfaces


class indirectInterfaceType(GeneratedsSuper):
    """name -- Unique name
    memoryMapRef -- A reference to a memoryMap. This memoryMap is indirectly accessible through this interface.
    endianness -- 'big': means the most significant element of any multi-element  data field is stored at the lowest memory address. 'little' means the least significant element of any multi-element data field is stored at the lowest memory address. If this element is not present the default is 'little' endian.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('indirectAddressRef', 'xs:Name', 0, 0, {'name': 'indirectAddressRef', 'ref': 'indirectAddressRef', 'type': 'xs:Name'}, None),
        MemberSpec_('indirectDataRef', 'xs:Name', 0, 0, {'name': 'indirectDataRef', 'ref': 'indirectDataRef', 'type': 'xs:Name'}, None),
        MemberSpec_('memoryMapRef', 'memoryMapRefType', 0, 0, {'name': 'memoryMapRef', 'type': 'xs:Name'}, 14),
        MemberSpec_('transparentBridge', 'transparentBridge', 1, 0, {'maxOccurs': 'unbounded', 'name': 'transparentBridge', 'ref': 'transparentBridge', 'type': 'transparentBridge'}, 14),
        MemberSpec_('bitsInLau', 'unsignedPositiveLongintExpression', 0, 1, {'minOccurs': '0', 'name': 'bitsInLau', 'ref': 'bitsInLau', 'type': 'bitsInLau'}, None),
        MemberSpec_('endianness', ['endianessType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'endianness', 'type': 'xs:string'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, indirectAddressRef=None, indirectDataRef=None, memoryMapRef=None, transparentBridge=None, bitsInLau=None, endianness=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.indirectAddressRef = indirectAddressRef
        self.indirectAddressRef_nsprefix_ = "ipxact"
        self.indirectDataRef = indirectDataRef
        self.indirectDataRef_nsprefix_ = "ipxact"
        self.memoryMapRef = memoryMapRef
        self.memoryMapRef_nsprefix_ = "ipxact"
        if transparentBridge is None:
            self.transparentBridge = []
        else:
            self.transparentBridge = transparentBridge
        self.transparentBridge_nsprefix_ = "ipxact"
        self.bitsInLau = bitsInLau
        self.bitsInLau_nsprefix_ = "ipxact"
        self.endianness = endianness
        self.validate_endianessType(self.endianness)
        self.endianness_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indirectInterfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indirectInterfaceType.subclass:
            return indirectInterfaceType.subclass(*args_, **kwargs_)
        else:
            return indirectInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_indirectAddressRef(self):
        return self.indirectAddressRef
    def set_indirectAddressRef(self, indirectAddressRef):
        self.indirectAddressRef = indirectAddressRef
    def get_indirectDataRef(self):
        return self.indirectDataRef
    def set_indirectDataRef(self, indirectDataRef):
        self.indirectDataRef = indirectDataRef
    def get_memoryMapRef(self):
        return self.memoryMapRef
    def set_memoryMapRef(self, memoryMapRef):
        self.memoryMapRef = memoryMapRef
    def get_transparentBridge(self):
        return self.transparentBridge
    def set_transparentBridge(self, transparentBridge):
        self.transparentBridge = transparentBridge
    def add_transparentBridge(self, value):
        self.transparentBridge.append(value)
    def insert_transparentBridge_at(self, index, value):
        self.transparentBridge.insert(index, value)
    def replace_transparentBridge_at(self, index, value):
        self.transparentBridge[index] = value
    def get_bitsInLau(self):
        return self.bitsInLau
    def set_bitsInLau(self, bitsInLau):
        self.bitsInLau = bitsInLau
    def get_endianness(self):
        return self.endianness
    def set_endianness(self, endianness):
        self.endianness = endianness
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def validate_endianessType(self, value):
        result = True
        # Validate type endianessType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['big', 'little']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on endianessType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.indirectAddressRef is not None or
            self.indirectDataRef is not None or
            self.memoryMapRef is not None or
            self.transparentBridge or
            self.bitsInLau is not None or
            self.endianness is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indirectInterfaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indirectInterfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'indirectInterfaceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='indirectInterfaceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='indirectInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='indirectInterfaceType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indirectInterfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.indirectAddressRef is not None:
            namespaceprefix_ = self.indirectAddressRef_nsprefix_ + ':' if (UseCapturedNS_ and self.indirectAddressRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindirectAddressRef>%s</%sindirectAddressRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indirectAddressRef), input_name='indirectAddressRef')), namespaceprefix_ , eol_))
        if self.indirectDataRef is not None:
            namespaceprefix_ = self.indirectDataRef_nsprefix_ + ':' if (UseCapturedNS_ and self.indirectDataRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindirectDataRef>%s</%sindirectDataRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indirectDataRef), input_name='indirectDataRef')), namespaceprefix_ , eol_))
        if self.memoryMapRef is not None:
            namespaceprefix_ = self.memoryMapRef_nsprefix_ + ':' if (UseCapturedNS_ and self.memoryMapRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smemoryMapRef>%s</%smemoryMapRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.memoryMapRef), input_name='memoryMapRef')), namespaceprefix_ , eol_))
        for transparentBridge_ in self.transparentBridge:
            namespaceprefix_ = self.transparentBridge_nsprefix_ + ':' if (UseCapturedNS_ and self.transparentBridge_nsprefix_) else ''
            transparentBridge_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='transparentBridge', pretty_print=pretty_print)
        if self.bitsInLau is not None:
            namespaceprefix_ = self.bitsInLau_nsprefix_ + ':' if (UseCapturedNS_ and self.bitsInLau_nsprefix_) else ''
            self.bitsInLau.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='bitsInLau', pretty_print=pretty_print)
        if self.endianness is not None:
            namespaceprefix_ = self.endianness_nsprefix_ + ':' if (UseCapturedNS_ and self.endianness_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendianness>%s</%sendianness>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.endianness), input_name='endianness')), namespaceprefix_ , eol_))
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'indirectAddressRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'indirectAddressRef')
            value_ = self.gds_validate_string(value_, node, 'indirectAddressRef')
            self.indirectAddressRef = value_
            self.indirectAddressRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'indirectDataRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'indirectDataRef')
            value_ = self.gds_validate_string(value_, node, 'indirectDataRef')
            self.indirectDataRef = value_
            self.indirectDataRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'memoryMapRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'memoryMapRef')
            value_ = self.gds_validate_string(value_, node, 'memoryMapRef')
            self.memoryMapRef = value_
            self.memoryMapRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'transparentBridge':
            obj_ = transparentBridge.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transparentBridge.append(obj_)
            obj_.original_tagname_ = 'transparentBridge'
        elif nodeName_ == 'bitsInLau':
            obj_ = unsignedPositiveLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bitsInLau = obj_
            obj_.original_tagname_ = 'bitsInLau'
        elif nodeName_ == 'endianness':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'endianness')
            value_ = self.gds_validate_string(value_, node, 'endianness')
            self.endianness = value_
            self.endianness_nsprefix_ = child_.prefix
            # validate type endianessType
            self.validate_endianessType(self.endianness)
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class indirectInterfaceType


class AbstractionTypes(GeneratedsSuper):
    """abstractionType -- The abstraction type/level of this interface. Refers to abstraction definition using vendor, library, name, version attributes along with any configurable element values needed to configure this abstraction. Bus definition can be found through a reference in this file.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('abstractionType', 'abstractionTypeType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'abstractionType', 'type': 'abstractionTypeType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, abstractionType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if abstractionType is None:
            self.abstractionType = []
        else:
            self.abstractionType = abstractionType
        self.abstractionType_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractionTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractionTypes.subclass:
            return AbstractionTypes.subclass(*args_, **kwargs_)
        else:
            return AbstractionTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_abstractionType(self):
        return self.abstractionType
    def set_abstractionType(self, abstractionType):
        self.abstractionType = abstractionType
    def add_abstractionType(self, value):
        self.abstractionType.append(value)
    def insert_abstractionType_at(self, index, value):
        self.abstractionType.insert(index, value)
    def replace_abstractionType_at(self, index, value):
        self.abstractionType[index] = value
    def _hasContent(self):
        if (
            self.abstractionType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractionTypes', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractionTypes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractionTypes':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractionTypes')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractionTypes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='abstractionTypes'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractionTypes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for abstractionType_ in self.abstractionType:
            namespaceprefix_ = self.abstractionType_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractionType_nsprefix_) else ''
            abstractionType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstractionType', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'abstractionType':
            obj_ = AbstractionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractionType.append(obj_)
            obj_.original_tagname_ = 'abstractionType'
# end class AbstractionTypes


class abstractionDefinition(GeneratedsSuper):
    """vendor -- Name of the vendor who supplies this file.
    library -- Name of the logical library this element belongs to.
    name -- The name of the object.
    version -- Indicates the version of the named element.
    busType -- Reference to the busDefinition that this abstractionDefinition implements.
    extends -- Optional name of abstraction type that this abstraction definition is compatible with. This abstraction definition may change the definitions of ports in the existing abstraction definition and add new ports, the ports in the original abstraction are not deleted but may be marked illegal to disallow their use.
    This abstraction definition may only extend another abstraction definition if the bus type of this abstraction definition extends the bus type of the extended abstraction definition
    ports -- This is a list of logical ports defined by the bus.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'name': 'vendor', 'type': 'xs:Name'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'name': 'library', 'type': 'xs:Name'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'name': 'version', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('busType', 'libraryRefType', 0, 0, {'name': 'busType', 'type': 'libraryRefType'}, None),
        MemberSpec_('extends', 'libraryRefType', 0, 1, {'minOccurs': '0', 'name': 'extends', 'type': 'libraryRefType'}, None),
        MemberSpec_('ports', 'portsType', 0, 0, {'name': 'ports', 'type': 'portsType'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'name': 'assertions', 'ref': 'assertions', 'type': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, busType=None, extends=None, ports=None, description=None, parameters=None, assertions=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.vendor = vendor
        self.vendor_nsprefix_ = "ipxact"
        self.library = library
        self.library_nsprefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.version = version
        self.version_nsprefix_ = "ipxact"
        self.busType = busType
        self.busType_nsprefix_ = "ipxact"
        self.extends = extends
        self.extends_nsprefix_ = "ipxact"
        self.ports = ports
        self.ports_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.assertions = assertions
        self.assertions_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractionDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractionDefinition.subclass:
            return abstractionDefinition.subclass(*args_, **kwargs_)
        else:
            return abstractionDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_busType(self):
        return self.busType
    def set_busType(self, busType):
        self.busType = busType
    def get_extends(self):
        return self.extends
    def set_extends(self, extends):
        self.extends = extends
    def get_ports(self):
        return self.ports
    def set_ports(self, ports):
        self.ports = ports
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_assertions(self):
        return self.assertions
    def set_assertions(self, assertions):
        self.assertions = assertions
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.busType is not None or
            self.extends is not None or
            self.ports is not None or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractionDefinition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractionDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractionDefinition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractionDefinition')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractionDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='abstractionDefinition'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractionDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            namespaceprefix_ = self.vendor_nsprefix_ + ':' if (UseCapturedNS_ and self.vendor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), namespaceprefix_ , eol_))
        if self.library is not None:
            namespaceprefix_ = self.library_nsprefix_ + ':' if (UseCapturedNS_ and self.library_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slibrary>%s</%slibrary>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespaceprefix_ , eol_))
        if self.busType is not None:
            namespaceprefix_ = self.busType_nsprefix_ + ':' if (UseCapturedNS_ and self.busType_nsprefix_) else ''
            self.busType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='busType', pretty_print=pretty_print)
        if self.extends is not None:
            namespaceprefix_ = self.extends_nsprefix_ + ':' if (UseCapturedNS_ and self.extends_nsprefix_) else ''
            self.extends.export(outfile, level, namespaceprefix_, namespacedef_='', name_='extends', pretty_print=pretty_print)
        if self.ports is not None:
            namespaceprefix_ = self.ports_nsprefix_ + ':' if (UseCapturedNS_ and self.ports_nsprefix_) else ''
            self.ports.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ports', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            namespaceprefix_ = self.assertions_nsprefix_ + ':' if (UseCapturedNS_ and self.assertions_nsprefix_) else ''
            self.assertions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vendor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vendor')
            value_ = self.gds_validate_string(value_, node, 'vendor')
            self.vendor = value_
            self.vendor_nsprefix_ = child_.prefix
        elif nodeName_ == 'library':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'library')
            value_ = self.gds_validate_string(value_, node, 'library')
            self.library = value_
            self.library_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'version')
            value_ = self.gds_validate_string(value_, node, 'version')
            self.version = value_
            self.version_nsprefix_ = child_.prefix
        elif nodeName_ == 'busType':
            obj_ = LibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.busType = obj_
            obj_.original_tagname_ = 'busType'
        elif nodeName_ == 'extends':
            obj_ = LibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.extends = obj_
            obj_.original_tagname_ = 'extends'
        elif nodeName_ == 'ports':
            obj_ = Ports.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ports = obj_
            obj_.original_tagname_ = 'ports'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class abstractionDefinition


class addressBankType(GeneratedsSuper):
    """name -- Unique name
    addressBlock -- An address block within the bank.  No address information is supplied.
    bank -- A nested bank of blocks within a bank.  No address information is supplied.
    subspaceMap -- A subspace map within the bank.  No address information is supplied.
    Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.
    usage -- Indicates the usage of this block.  Possible values are 'memory', 'register' and 'reserved'.
    parameters -- Any additional parameters needed to describe this address block to the generators.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('bankAlignment', 'ipxact:bankAlignmentType', 0, 0, {'use': 'required', 'name': 'bankAlignment'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType43', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType43'}, None),
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 0, {'name': 'baseAddress', 'ref': 'baseAddress', 'type': 'baseAddress'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 0, {'name': 'addressBlock', 'type': 'bankedBlockType'}, 15),
        MemberSpec_('bank', 'addressBankType', 1, 0, {'name': 'bank', 'type': 'bankedBankType'}, 15),
        MemberSpec_('subspaceMap', 'bankedSubspaceType', 1, 0, {'name': 'subspaceMap', 'type': 'bankedSubspaceType'}, 15),
        MemberSpec_('usage', ['usageType', 'xs:token'], 0, 1, {'minOccurs': '0', 'name': 'usage', 'type': 'xs:token'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, bankAlignment=None, id=None, name=None, displayName=None, description=None, accessHandles=None, baseAddress=None, isPresent=None, addressBlock=None, bank=None, subspaceMap=None, usage=None, volatile=None, access=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.bankAlignment = _cast(None, bankAlignment)
        self.bankAlignment_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = "ipxact"
        self.baseAddress = baseAddress
        self.baseAddress_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        self.addressBlock_nsprefix_ = "ipxact"
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        self.bank_nsprefix_ = "ipxact"
        if subspaceMap is None:
            self.subspaceMap = []
        else:
            self.subspaceMap = subspaceMap
        self.subspaceMap_nsprefix_ = "ipxact"
        self.usage = usage
        self.validate_usageType(self.usage)
        self.usage_nsprefix_ = "ipxact"
        self.volatile = volatile
        self.volatile_nsprefix_ = "ipxact"
        self.access = access
        self.access_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressBankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressBankType.subclass:
            return addressBankType.subclass(*args_, **kwargs_)
        else:
            return addressBankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_baseAddress(self):
        return self.baseAddress
    def set_baseAddress(self, baseAddress):
        self.baseAddress = baseAddress
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_addressBlock(self):
        return self.addressBlock
    def set_addressBlock(self, addressBlock):
        self.addressBlock = addressBlock
    def add_addressBlock(self, value):
        self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value):
        self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value):
        self.addressBlock[index] = value
    def get_bank(self):
        return self.bank
    def set_bank(self, bank):
        self.bank = bank
    def add_bank(self, value):
        self.bank.append(value)
    def insert_bank_at(self, index, value):
        self.bank.insert(index, value)
    def replace_bank_at(self, index, value):
        self.bank[index] = value
    def get_subspaceMap(self):
        return self.subspaceMap
    def set_subspaceMap(self, subspaceMap):
        self.subspaceMap = subspaceMap
    def add_subspaceMap(self, value):
        self.subspaceMap.append(value)
    def insert_subspaceMap_at(self, index, value):
        self.subspaceMap.insert(index, value)
    def replace_subspaceMap_at(self, index, value):
        self.subspaceMap[index] = value
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_bankAlignment(self):
        return self.bankAlignment
    def set_bankAlignment(self, bankAlignment):
        self.bankAlignment = bankAlignment
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_usageType(self, value):
        result = True
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['memory', 'register', 'reserved']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on usageType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_bankAlignmentType(self, value):
        # Validate type ipxact:bankAlignmentType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['serial', 'parallel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on bankAlignmentType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.baseAddress is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.subspaceMap or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressBankType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressBankType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'addressBankType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addressBankType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addressBankType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='addressBankType'):
        if self.bankAlignment is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            outfile.write(' bankAlignment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bankAlignment), input_name='bankAlignment')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressBankType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.baseAddress is not None:
            namespaceprefix_ = self.baseAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.baseAddress_nsprefix_) else ''
            self.baseAddress.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='baseAddress', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            namespaceprefix_ = self.addressBlock_nsprefix_ + ':' if (UseCapturedNS_ and self.addressBlock_nsprefix_) else ''
            addressBlock_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            namespaceprefix_ = self.bank_nsprefix_ + ':' if (UseCapturedNS_ and self.bank_nsprefix_) else ''
            bank_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bank', pretty_print=pretty_print)
        for subspaceMap_ in self.subspaceMap:
            namespaceprefix_ = self.subspaceMap_nsprefix_ + ':' if (UseCapturedNS_ and self.subspaceMap_nsprefix_) else ''
            subspaceMap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subspaceMap', pretty_print=pretty_print)
        if self.usage is not None:
            namespaceprefix_ = self.usage_nsprefix_ + ':' if (UseCapturedNS_ and self.usage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susage>%s</%susage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), namespaceprefix_ , eol_))
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bankAlignment', node)
        if value is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            self.bankAlignment = value
            self.bankAlignment = ' '.join(self.bankAlignment.split())
            self.validate_bankAlignmentType(self.bankAlignment)    # validate type bankAlignmentType
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType43.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'baseAddress':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = bankedBlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = bankedBankType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'subspaceMap':
            obj_ = bankedSubspaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subspaceMap.append(obj_)
            obj_.original_tagname_ = 'subspaceMap'
        elif nodeName_ == 'usage':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'usage')
            value_ = self.gds_validate_string(value_, node, 'usage')
            self.usage = value_
            self.usage_nsprefix_ = child_.prefix
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class addressBankType


class localAddressBankType(GeneratedsSuper):
    """name -- Unique name
    addressBlock -- An address block within the bank.  No address information is supplied.
    bank -- A nested bank of blocks within a bank.  No address information is supplied.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('bankAlignment', 'ipxact:bankAlignmentType', 0, 0, {'use': 'required', 'name': 'bankAlignment'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType44', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType44'}, None),
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 0, {'name': 'baseAddress', 'ref': 'baseAddress', 'type': 'baseAddress'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 0, {'name': 'addressBlock', 'type': 'bankedBlockType'}, 16),
        MemberSpec_('bank', 'addressBankType', 1, 0, {'name': 'bank', 'type': 'localBankedBankType'}, 16),
        MemberSpec_('usage', ['usageType', 'xs:token'], 0, 1, {'minOccurs': '0', 'name': 'usage', 'type': 'xs:token'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, bankAlignment=None, id=None, name=None, displayName=None, description=None, accessHandles=None, baseAddress=None, isPresent=None, addressBlock=None, bank=None, usage=None, volatile=None, access=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.bankAlignment = _cast(None, bankAlignment)
        self.bankAlignment_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = "ipxact"
        self.baseAddress = baseAddress
        self.baseAddress_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        self.addressBlock_nsprefix_ = "ipxact"
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        self.bank_nsprefix_ = "ipxact"
        self.usage = usage
        self.validate_usageType(self.usage)
        self.usage_nsprefix_ = "ipxact"
        self.volatile = volatile
        self.volatile_nsprefix_ = "ipxact"
        self.access = access
        self.access_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, localAddressBankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if localAddressBankType.subclass:
            return localAddressBankType.subclass(*args_, **kwargs_)
        else:
            return localAddressBankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_baseAddress(self):
        return self.baseAddress
    def set_baseAddress(self, baseAddress):
        self.baseAddress = baseAddress
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_addressBlock(self):
        return self.addressBlock
    def set_addressBlock(self, addressBlock):
        self.addressBlock = addressBlock
    def add_addressBlock(self, value):
        self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value):
        self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value):
        self.addressBlock[index] = value
    def get_bank(self):
        return self.bank
    def set_bank(self, bank):
        self.bank = bank
    def add_bank(self, value):
        self.bank.append(value)
    def insert_bank_at(self, index, value):
        self.bank.insert(index, value)
    def replace_bank_at(self, index, value):
        self.bank[index] = value
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_bankAlignment(self):
        return self.bankAlignment
    def set_bankAlignment(self, bankAlignment):
        self.bankAlignment = bankAlignment
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_usageType(self, value):
        result = True
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['memory', 'register', 'reserved']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on usageType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_bankAlignmentType(self, value):
        # Validate type ipxact:bankAlignmentType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['serial', 'parallel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on bankAlignmentType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.baseAddress is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='localAddressBankType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('localAddressBankType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'localAddressBankType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='localAddressBankType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='localAddressBankType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='localAddressBankType'):
        if self.bankAlignment is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            outfile.write(' bankAlignment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bankAlignment), input_name='bankAlignment')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='localAddressBankType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.baseAddress is not None:
            namespaceprefix_ = self.baseAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.baseAddress_nsprefix_) else ''
            self.baseAddress.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='baseAddress', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            namespaceprefix_ = self.addressBlock_nsprefix_ + ':' if (UseCapturedNS_ and self.addressBlock_nsprefix_) else ''
            addressBlock_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            namespaceprefix_ = self.bank_nsprefix_ + ':' if (UseCapturedNS_ and self.bank_nsprefix_) else ''
            bank_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bank', pretty_print=pretty_print)
        if self.usage is not None:
            namespaceprefix_ = self.usage_nsprefix_ + ':' if (UseCapturedNS_ and self.usage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susage>%s</%susage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), namespaceprefix_ , eol_))
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bankAlignment', node)
        if value is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            self.bankAlignment = value
            self.bankAlignment = ' '.join(self.bankAlignment.split())
            self.validate_bankAlignmentType(self.bankAlignment)    # validate type bankAlignmentType
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType44.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'baseAddress':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = bankedBlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = localBankedBankType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'usage':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'usage')
            value_ = self.gds_validate_string(value_, node, 'usage')
            self.usage = value_
            self.usage_nsprefix_ = child_.prefix
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class localAddressBankType


class addressBlockType(GeneratedsSuper):
    """name -- Unique name
    typeIdentifier -- Identifier name used to indicate that multiple addressBlock elements contain the exact same information except for the elements in the addressBlockInstanceGroup.
    The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:
    range -- The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:
    number_of_bits_in_block = ipxact:addressUnitBits * ipxact:range
    number_of_rows_in_block = number_of_bits_in_block / ipxact:width
      
    * width -- The bit width of a row in the address block. The range and the width are related by the following formulas:
      number_of_bits_in_block = ipxact:addressUnitBits * ipxact:range
      number_of_rows_in_block = number_of_bits_in_block / ipxact:width
      A single register
    * register -- A single register
    * registerFile -- A structure of registers and register files
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType45', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType45'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 0, {'name': 'baseAddress', 'ref': 'baseAddress', 'type': 'baseAddress'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'typeIdentifier', 'type': 'xs:Name'}, None),
        MemberSpec_('Range', 'unsignedPositiveLongintExpression', 0, 0, {'name': 'range', 'type': 'unsignedPositiveLongintExpression'}, None),
        MemberSpec_('width', 'unsignedIntExpression', 0, 0, {'name': 'width', 'type': 'unsignedIntExpression'}, None),
        MemberSpec_('usage', ['usageType', 'xs:token'], 0, 1, {'minOccurs': '0', 'name': 'usage', 'type': 'xs:token'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('register', 'registerType51', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'register', 'type': 'registerType51'}, 23),
        MemberSpec_('registerFile', 'registerFile', 0, 0, {'name': 'registerFile', 'ref': 'registerFile', 'type': 'registerFile'}, 23),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, baseAddress=None, typeIdentifier=None, Range=None, width=None, usage=None, volatile=None, access=None, parameters=None, register=None, registerFile=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.baseAddress = baseAddress
        self.baseAddress_nsprefix_ = "ipxact"
        self.typeIdentifier = typeIdentifier
        self.typeIdentifier_nsprefix_ = "ipxact"
        self.Range = Range
        self.Range_nsprefix_ = "ipxact"
        self.width = width
        self.width_nsprefix_ = "ipxact"
        self.usage = usage
        self.validate_usageType(self.usage)
        self.usage_nsprefix_ = "ipxact"
        self.volatile = volatile
        self.volatile_nsprefix_ = "ipxact"
        self.access = access
        self.access_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        if register is None:
            self.register = []
        else:
            self.register = register
        self.register_nsprefix_ = "ipxact"
        self.registerFile = registerFile
        self.registerFile_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressBlockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressBlockType.subclass:
            return addressBlockType.subclass(*args_, **kwargs_)
        else:
            return addressBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_baseAddress(self):
        return self.baseAddress
    def set_baseAddress(self, baseAddress):
        self.baseAddress = baseAddress
    def get_typeIdentifier(self):
        return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier):
        self.typeIdentifier = typeIdentifier
    def get_range(self):
        return self.Range
    def set_range(self, Range):
        self.Range = Range
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_register(self):
        return self.register
    def set_register(self, register):
        self.register = register
    def add_register(self, value):
        self.register.append(value)
    def insert_register_at(self, index, value):
        self.register.insert(index, value)
    def replace_register_at(self, index, value):
        self.register[index] = value
    def get_registerFile(self):
        return self.registerFile
    def set_registerFile(self, registerFile):
        self.registerFile = registerFile
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_usageType(self, value):
        result = True
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['memory', 'register', 'reserved']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on usageType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.baseAddress is not None or
            self.typeIdentifier is not None or
            self.Range is not None or
            self.width is not None or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.register or
            self.registerFile is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressBlockType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressBlockType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'addressBlockType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addressBlockType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addressBlockType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='addressBlockType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressBlockType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.baseAddress is not None:
            namespaceprefix_ = self.baseAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.baseAddress_nsprefix_) else ''
            self.baseAddress.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='baseAddress', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            namespaceprefix_ = self.typeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.typeIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stypeIdentifier>%s</%stypeIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), namespaceprefix_ , eol_))
        if self.Range is not None:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            self.Range.export(outfile, level, namespaceprefix_, namespacedef_='', name_='range', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.usage is not None:
            namespaceprefix_ = self.usage_nsprefix_ + ':' if (UseCapturedNS_ and self.usage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susage>%s</%susage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), namespaceprefix_ , eol_))
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        for register_ in self.register:
            namespaceprefix_ = self.register_nsprefix_ + ':' if (UseCapturedNS_ and self.register_nsprefix_) else ''
            register_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='register', pretty_print=pretty_print)
        if self.registerFile is not None:
            namespaceprefix_ = self.registerFile_nsprefix_ + ':' if (UseCapturedNS_ and self.registerFile_nsprefix_) else ''
            self.registerFile.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='registerFile', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType45.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'baseAddress':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        elif nodeName_ == 'typeIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeIdentifier')
            value_ = self.gds_validate_string(value_, node, 'typeIdentifier')
            self.typeIdentifier = value_
            self.typeIdentifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'range':
            obj_ = unsignedPositiveLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
        elif nodeName_ == 'width':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'usage':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'usage')
            value_ = self.gds_validate_string(value_, node, 'usage')
            self.usage = value_
            self.usage_nsprefix_ = child_.prefix
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'register':
            obj_ = registerType51.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.register.append(obj_)
            obj_.original_tagname_ = 'register'
        elif nodeName_ == 'registerFile':
            obj_ = registerFile.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.registerFile = obj_
            obj_.original_tagname_ = 'registerFile'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class addressBlockType


class addrSpaceRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('addressSpaceRef', 'xs:Name', 0, 0, {'use': 'required', 'name': 'addressSpaceRef'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, addressSpaceRef=None, id=None, isPresent=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.addressSpaceRef = _cast(None, addressSpaceRef)
        self.addressSpaceRef_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addrSpaceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addrSpaceRefType.subclass:
            return addrSpaceRefType.subclass(*args_, **kwargs_)
        else:
            return addrSpaceRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_addressSpaceRef(self):
        return self.addressSpaceRef
    def set_addressSpaceRef(self, addressSpaceRef):
        self.addressSpaceRef = addressSpaceRef
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addrSpaceRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addrSpaceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'addrSpaceRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addrSpaceRefType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addrSpaceRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='addrSpaceRefType'):
        if self.addressSpaceRef is not None and 'addressSpaceRef' not in already_processed:
            already_processed.add('addressSpaceRef')
            outfile.write(' addressSpaceRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.addressSpaceRef), input_name='addressSpaceRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addrSpaceRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('addressSpaceRef', node)
        if value is not None and 'addressSpaceRef' not in already_processed:
            already_processed.add('addressSpaceRef')
            self.addressSpaceRef = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class addrSpaceRefType


class memoryMapRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('memoryMapRef', 'xs:Name', 0, 0, {'use': 'required', 'name': 'memoryMapRef'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, memoryMapRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.memoryMapRef = _cast(None, memoryMapRef)
        self.memoryMapRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, memoryMapRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if memoryMapRefType.subclass:
            return memoryMapRefType.subclass(*args_, **kwargs_)
        else:
            return memoryMapRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_memoryMapRef(self):
        return self.memoryMapRef
    def set_memoryMapRef(self, memoryMapRef):
        self.memoryMapRef = memoryMapRef
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='memoryMapRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memoryMapRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'memoryMapRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='memoryMapRefType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='memoryMapRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='memoryMapRefType'):
        if self.memoryMapRef is not None and 'memoryMapRef' not in already_processed:
            already_processed.add('memoryMapRef')
            outfile.write(' memoryMapRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.memoryMapRef), input_name='memoryMapRef')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='memoryMapRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('memoryMapRef', node)
        if value is not None and 'memoryMapRef' not in already_processed:
            already_processed.add('memoryMapRef')
            self.memoryMapRef = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class memoryMapRefType


class bankedBankType(GeneratedsSuper):
    """name -- Unique name
    addressBlock -- An address block within the bank.  No address information is supplied.
    bank -- A nested bank of blocks within a bank.  No address information is supplied.
    subspaceMap -- A subspace map within the bank.  No address information is supplied.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('bankAlignment', 'ipxact:bankAlignmentType', 0, 0, {'use': 'required', 'name': 'bankAlignment'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType46', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType46'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 0, {'name': 'addressBlock', 'type': 'bankedBlockType'}, 17),
        MemberSpec_('bank', 'addressBankType', 1, 0, {'name': 'bank', 'type': 'bankedBankType'}, 17),
        MemberSpec_('subspaceMap', 'bankedSubspaceType', 1, 0, {'name': 'subspaceMap', 'type': 'bankedSubspaceType'}, 17),
        MemberSpec_('usage', ['usageType', 'xs:token'], 0, 1, {'minOccurs': '0', 'name': 'usage', 'type': 'xs:token'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, bankAlignment=None, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, addressBlock=None, bank=None, subspaceMap=None, usage=None, volatile=None, access=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.bankAlignment = _cast(None, bankAlignment)
        self.bankAlignment_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        self.addressBlock_nsprefix_ = "ipxact"
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        self.bank_nsprefix_ = "ipxact"
        if subspaceMap is None:
            self.subspaceMap = []
        else:
            self.subspaceMap = subspaceMap
        self.subspaceMap_nsprefix_ = "ipxact"
        self.usage = usage
        self.validate_usageType(self.usage)
        self.usage_nsprefix_ = "ipxact"
        self.volatile = volatile
        self.volatile_nsprefix_ = "ipxact"
        self.access = access
        self.access_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bankedBankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bankedBankType.subclass:
            return bankedBankType.subclass(*args_, **kwargs_)
        else:
            return bankedBankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_addressBlock(self):
        return self.addressBlock
    def set_addressBlock(self, addressBlock):
        self.addressBlock = addressBlock
    def add_addressBlock(self, value):
        self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value):
        self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value):
        self.addressBlock[index] = value
    def get_bank(self):
        return self.bank
    def set_bank(self, bank):
        self.bank = bank
    def add_bank(self, value):
        self.bank.append(value)
    def insert_bank_at(self, index, value):
        self.bank.insert(index, value)
    def replace_bank_at(self, index, value):
        self.bank[index] = value
    def get_subspaceMap(self):
        return self.subspaceMap
    def set_subspaceMap(self, subspaceMap):
        self.subspaceMap = subspaceMap
    def add_subspaceMap(self, value):
        self.subspaceMap.append(value)
    def insert_subspaceMap_at(self, index, value):
        self.subspaceMap.insert(index, value)
    def replace_subspaceMap_at(self, index, value):
        self.subspaceMap[index] = value
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_bankAlignment(self):
        return self.bankAlignment
    def set_bankAlignment(self, bankAlignment):
        self.bankAlignment = bankAlignment
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_usageType(self, value):
        result = True
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['memory', 'register', 'reserved']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on usageType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_bankAlignmentType(self, value):
        # Validate type ipxact:bankAlignmentType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['serial', 'parallel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on bankAlignmentType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.subspaceMap or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='bankedBankType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bankedBankType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bankedBankType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bankedBankType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bankedBankType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='bankedBankType'):
        if self.bankAlignment is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            outfile.write(' bankAlignment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bankAlignment), input_name='bankAlignment')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='bankedBankType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            namespaceprefix_ = self.addressBlock_nsprefix_ + ':' if (UseCapturedNS_ and self.addressBlock_nsprefix_) else ''
            addressBlock_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            namespaceprefix_ = self.bank_nsprefix_ + ':' if (UseCapturedNS_ and self.bank_nsprefix_) else ''
            bank_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bank', pretty_print=pretty_print)
        for subspaceMap_ in self.subspaceMap:
            namespaceprefix_ = self.subspaceMap_nsprefix_ + ':' if (UseCapturedNS_ and self.subspaceMap_nsprefix_) else ''
            subspaceMap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subspaceMap', pretty_print=pretty_print)
        if self.usage is not None:
            namespaceprefix_ = self.usage_nsprefix_ + ':' if (UseCapturedNS_ and self.usage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susage>%s</%susage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), namespaceprefix_ , eol_))
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bankAlignment', node)
        if value is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            self.bankAlignment = value
            self.bankAlignment = ' '.join(self.bankAlignment.split())
            self.validate_bankAlignmentType(self.bankAlignment)    # validate type bankAlignmentType
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType46.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = bankedBlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = bankedBankType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'subspaceMap':
            obj_ = bankedSubspaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subspaceMap.append(obj_)
            obj_.original_tagname_ = 'subspaceMap'
        elif nodeName_ == 'usage':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'usage')
            value_ = self.gds_validate_string(value_, node, 'usage')
            self.usage = value_
            self.usage_nsprefix_ = child_.prefix
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class bankedBankType


class localBankedBankType(GeneratedsSuper):
    """name -- Unique name
    addressBlock -- An address block within the bank.  No address information is supplied.
    bank -- A nested bank of blocks within a bank.  No address information is supplied.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('bankAlignment', 'ipxact:bankAlignmentType', 0, 0, {'use': 'required', 'name': 'bankAlignment'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType47', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType47'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 0, {'name': 'addressBlock', 'type': 'bankedBlockType'}, 18),
        MemberSpec_('bank', 'addressBankType', 1, 0, {'name': 'bank', 'type': 'localBankedBankType'}, 18),
        MemberSpec_('usage', ['usageType', 'xs:token'], 0, 1, {'minOccurs': '0', 'name': 'usage', 'type': 'xs:token'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, bankAlignment=None, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, addressBlock=None, bank=None, usage=None, volatile=None, access=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.bankAlignment = _cast(None, bankAlignment)
        self.bankAlignment_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        self.addressBlock_nsprefix_ = "ipxact"
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        self.bank_nsprefix_ = "ipxact"
        self.usage = usage
        self.validate_usageType(self.usage)
        self.usage_nsprefix_ = "ipxact"
        self.volatile = volatile
        self.volatile_nsprefix_ = "ipxact"
        self.access = access
        self.access_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, localBankedBankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if localBankedBankType.subclass:
            return localBankedBankType.subclass(*args_, **kwargs_)
        else:
            return localBankedBankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_addressBlock(self):
        return self.addressBlock
    def set_addressBlock(self, addressBlock):
        self.addressBlock = addressBlock
    def add_addressBlock(self, value):
        self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value):
        self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value):
        self.addressBlock[index] = value
    def get_bank(self):
        return self.bank
    def set_bank(self, bank):
        self.bank = bank
    def add_bank(self, value):
        self.bank.append(value)
    def insert_bank_at(self, index, value):
        self.bank.insert(index, value)
    def replace_bank_at(self, index, value):
        self.bank[index] = value
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_bankAlignment(self):
        return self.bankAlignment
    def set_bankAlignment(self, bankAlignment):
        self.bankAlignment = bankAlignment
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_usageType(self, value):
        result = True
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['memory', 'register', 'reserved']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on usageType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_bankAlignmentType(self, value):
        # Validate type ipxact:bankAlignmentType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['serial', 'parallel']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on bankAlignmentType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='localBankedBankType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('localBankedBankType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'localBankedBankType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='localBankedBankType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='localBankedBankType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='localBankedBankType'):
        if self.bankAlignment is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            outfile.write(' bankAlignment=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.bankAlignment), input_name='bankAlignment')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='localBankedBankType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            namespaceprefix_ = self.addressBlock_nsprefix_ + ':' if (UseCapturedNS_ and self.addressBlock_nsprefix_) else ''
            addressBlock_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            namespaceprefix_ = self.bank_nsprefix_ + ':' if (UseCapturedNS_ and self.bank_nsprefix_) else ''
            bank_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bank', pretty_print=pretty_print)
        if self.usage is not None:
            namespaceprefix_ = self.usage_nsprefix_ + ':' if (UseCapturedNS_ and self.usage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susage>%s</%susage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), namespaceprefix_ , eol_))
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bankAlignment', node)
        if value is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            self.bankAlignment = value
            self.bankAlignment = ' '.join(self.bankAlignment.split())
            self.validate_bankAlignmentType(self.bankAlignment)    # validate type bankAlignmentType
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType47.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = bankedBlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = localBankedBankType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'usage':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'usage')
            value_ = self.gds_validate_string(value_, node, 'usage')
            self.usage = value_
            self.usage_nsprefix_ = child_.prefix
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class localBankedBankType


class bankedBlockType(GeneratedsSuper):
    """name -- Unique name
    range -- The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:
    number_of_bits_in_block = ipxact:addressUnitBits * ipxact:range
    number_of_rows_in_block = number_of_bits_in_block / ipxact:width
      
    * width -- The bit width of a row in the address block. The range and the width are related by the following formulas:
      number_of_bits_in_block = ipxact:addressUnitBits * ipxact:range
      number_of_rows_in_block = number_of_bits_in_block / ipxact:width
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType48', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType48'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('Range', 'unsignedPositiveLongintExpression', 0, 0, {'name': 'range', 'type': 'unsignedPositiveLongintExpression'}, None),
        MemberSpec_('width', 'unsignedIntExpression', 0, 0, {'name': 'width', 'type': 'unsignedIntExpression'}, None),
        MemberSpec_('usage', ['usageType', 'xs:token'], 0, 1, {'minOccurs': '0', 'name': 'usage', 'type': 'xs:token'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('register', 'registerType51', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'register', 'type': 'registerType51'}, 23),
        MemberSpec_('registerFile', 'registerFile', 0, 0, {'name': 'registerFile', 'ref': 'registerFile', 'type': 'registerFile'}, 23),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, Range=None, width=None, usage=None, volatile=None, access=None, parameters=None, register=None, registerFile=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.Range = Range
        self.Range_nsprefix_ = "ipxact"
        self.width = width
        self.width_nsprefix_ = "ipxact"
        self.usage = usage
        self.validate_usageType(self.usage)
        self.usage_nsprefix_ = "ipxact"
        self.volatile = volatile
        self.volatile_nsprefix_ = "ipxact"
        self.access = access
        self.access_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        if register is None:
            self.register = []
        else:
            self.register = register
        self.register_nsprefix_ = "ipxact"
        self.registerFile = registerFile
        self.registerFile_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bankedBlockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bankedBlockType.subclass:
            return bankedBlockType.subclass(*args_, **kwargs_)
        else:
            return bankedBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_range(self):
        return self.Range
    def set_range(self, Range):
        self.Range = Range
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_register(self):
        return self.register
    def set_register(self, register):
        self.register = register
    def add_register(self, value):
        self.register.append(value)
    def insert_register_at(self, index, value):
        self.register.insert(index, value)
    def replace_register_at(self, index, value):
        self.register[index] = value
    def get_registerFile(self):
        return self.registerFile
    def set_registerFile(self, registerFile):
        self.registerFile = registerFile
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_usageType(self, value):
        result = True
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['memory', 'register', 'reserved']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on usageType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.Range is not None or
            self.width is not None or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.register or
            self.registerFile is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='bankedBlockType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bankedBlockType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bankedBlockType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bankedBlockType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bankedBlockType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='bankedBlockType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='bankedBlockType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.Range is not None:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            self.Range.export(outfile, level, namespaceprefix_, namespacedef_='', name_='range', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.usage is not None:
            namespaceprefix_ = self.usage_nsprefix_ + ':' if (UseCapturedNS_ and self.usage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susage>%s</%susage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), namespaceprefix_ , eol_))
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        for register_ in self.register:
            namespaceprefix_ = self.register_nsprefix_ + ':' if (UseCapturedNS_ and self.register_nsprefix_) else ''
            register_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='register', pretty_print=pretty_print)
        if self.registerFile is not None:
            namespaceprefix_ = self.registerFile_nsprefix_ + ':' if (UseCapturedNS_ and self.registerFile_nsprefix_) else ''
            self.registerFile.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='registerFile', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType48.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'range':
            obj_ = unsignedPositiveLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
        elif nodeName_ == 'width':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'usage':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'usage')
            value_ = self.gds_validate_string(value_, node, 'usage')
            self.usage = value_
            self.usage_nsprefix_ = child_.prefix
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'register':
            obj_ = registerType51.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.register.append(obj_)
            obj_.original_tagname_ = 'register'
        elif nodeName_ == 'registerFile':
            obj_ = registerFile.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.registerFile = obj_
            obj_.original_tagname_ = 'registerFile'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class bankedBlockType


class bankedSubspaceType(GeneratedsSuper):
    """name -- Unique name
    parameters -- Any parameters that may apply to the subspace reference.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('masterRef', 'xs:Name', 0, 0, {'use': 'required', 'name': 'masterRef'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, masterRef=None, id=None, name=None, displayName=None, description=None, isPresent=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.masterRef = _cast(None, masterRef)
        self.masterRef_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bankedSubspaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bankedSubspaceType.subclass:
            return bankedSubspaceType.subclass(*args_, **kwargs_)
        else:
            return bankedSubspaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_masterRef(self):
        return self.masterRef
    def set_masterRef(self, masterRef):
        self.masterRef = masterRef
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='bankedSubspaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bankedSubspaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'bankedSubspaceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='bankedSubspaceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='bankedSubspaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='bankedSubspaceType'):
        if self.masterRef is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            outfile.write(' masterRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.masterRef), input_name='masterRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='bankedSubspaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterRef', node)
        if value is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            self.masterRef = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class bankedSubspaceType


class fieldType(GeneratedsSuper):
    """name -- Unique name
    bitOffset -- Offset of this field's bit 0 from bit 0 of the register.
    typeIdentifier -- Identifier name used to indicate that multiple field elements contain the exact same information for the elements in the fieldDefinitionGroup.
    bitWidth -- Width of the field in bits.
    Indicates whether the data is volatile. The presumed value is 'false' if not present.
    volatile -- Indicates whether the data is volatile. The presumed value is 'false' if not present.
    modifiedWriteValue -- If present this element describes the modification of field data caused by a write operation. 'oneToClear' means that in a bitwise fashion each write data bit of a one will clear the corresponding bit in the field. 'oneToSet' means that in a bitwise fashion each write data bit of a one will set the corresponding bit in the field.  'oneToToggle' means that in a bitwise fashion each write data bit of a one will toggle the corresponding bit in the field. 'zeroToClear' means that in a bitwise fashion each write data bit of a zero will clear the corresponding bit in the field. 'zeroToSet' means that in a bitwise fashion each write data bit of a zero will set the corresponding bit in the field. 'zeroToToggle' means that in a bitwise fashion each write data bit of a zero will toggle the corresponding bit in the field. 'clear' means any write to this field clears the field. 'set' means any write to the field sets the field. 'modify' means any write to this field may modify that data. If this element is not present the write operation data is written.
    writeValueConstraint -- The legal values that may be written to a field. If not specified the legal values are not specified.
    readAction -- A list of possible actions for a read to set the field after the read. 'clear' means that after a read the field is cleared. 'set' means that after a read the field is set. 'modify' means after a read the field is modified. If not present the field value is not modified after a read.
    testable -- Can the field be tested with an automated register test routine. The presumed value is true if not specified.
    reserved -- Indicates that the field should be documented as reserved. The presumed value is 'false' if not present.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('fieldID', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'fieldID'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType49', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType49'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('bitOffset', 'unsignedIntExpression', 0, 0, {'name': 'bitOffset', 'type': 'unsignedIntExpression'}, None),
        MemberSpec_('resets', 'resetsType', 0, 1, {'minOccurs': '0', 'name': 'resets', 'type': 'resetsType'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'typeIdentifier', 'type': 'xs:Name'}, None),
        MemberSpec_('bitWidth', 'unsignedPositiveIntExpression', 0, 0, {'name': 'bitWidth', 'type': 'unsignedPositiveIntExpression'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('enumeratedValues', 'enumeratedValues', 0, 1, {'minOccurs': '0', 'name': 'enumeratedValues', 'ref': 'enumeratedValues', 'type': 'enumeratedValues'}, None),
        MemberSpec_('modifiedWriteValue', 'modifiedWriteValueType56', 0, 1, {'minOccurs': '0', 'name': 'modifiedWriteValue', 'type': 'modifiedWriteValueType56'}, None),
        MemberSpec_('writeValueConstraint', 'writeValueConstraintType', 0, 1, {'minOccurs': '0', 'name': 'writeValueConstraint', 'type': 'writeValueConstraintType'}, None),
        MemberSpec_('readAction', 'readActionType57', 0, 1, {'minOccurs': '0', 'name': 'readAction', 'type': 'readActionType57'}, None),
        MemberSpec_('testable', 'testableType', 0, 1, {'minOccurs': '0', 'name': 'testable', 'type': 'testableType'}, None),
        MemberSpec_('reserved', 'unsignedBitExpression', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'reserved', 'type': 'unsignedBitExpression'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, fieldID=None, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, bitOffset=None, resets=None, typeIdentifier=None, bitWidth=None, volatile=None, access=None, enumeratedValues=None, modifiedWriteValue=None, writeValueConstraint=None, readAction=None, testable=None, reserved=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.fieldID = _cast(None, fieldID)
        self.fieldID_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.bitOffset = bitOffset
        self.bitOffset_nsprefix_ = "ipxact"
        self.resets = resets
        self.resets_nsprefix_ = "ipxact"
        self.typeIdentifier = typeIdentifier
        self.typeIdentifier_nsprefix_ = "ipxact"
        self.bitWidth = bitWidth
        self.bitWidth_nsprefix_ = "ipxact"
        self.volatile = volatile
        self.volatile_nsprefix_ = "ipxact"
        self.access = access
        self.access_nsprefix_ = "ipxact"
        self.enumeratedValues = enumeratedValues
        self.enumeratedValues_nsprefix_ = "ipxact"
        self.modifiedWriteValue = modifiedWriteValue
        self.modifiedWriteValue_nsprefix_ = "ipxact"
        self.writeValueConstraint = writeValueConstraint
        self.writeValueConstraint_nsprefix_ = "ipxact"
        self.readAction = readAction
        self.readAction_nsprefix_ = "ipxact"
        self.testable = testable
        self.testable_nsprefix_ = "ipxact"
        if reserved is None:
            self.reserved = globals()['unsignedBitExpression']('false')
        else:
            self.reserved = reserved
        self.reserved_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fieldType.subclass:
            return fieldType.subclass(*args_, **kwargs_)
        else:
            return fieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_bitOffset(self):
        return self.bitOffset
    def set_bitOffset(self, bitOffset):
        self.bitOffset = bitOffset
    def get_resets(self):
        return self.resets
    def set_resets(self, resets):
        self.resets = resets
    def get_typeIdentifier(self):
        return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier):
        self.typeIdentifier = typeIdentifier
    def get_bitWidth(self):
        return self.bitWidth
    def set_bitWidth(self, bitWidth):
        self.bitWidth = bitWidth
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_enumeratedValues(self):
        return self.enumeratedValues
    def set_enumeratedValues(self, enumeratedValues):
        self.enumeratedValues = enumeratedValues
    def get_modifiedWriteValue(self):
        return self.modifiedWriteValue
    def set_modifiedWriteValue(self, modifiedWriteValue):
        self.modifiedWriteValue = modifiedWriteValue
    def get_writeValueConstraint(self):
        return self.writeValueConstraint
    def set_writeValueConstraint(self, writeValueConstraint):
        self.writeValueConstraint = writeValueConstraint
    def get_readAction(self):
        return self.readAction
    def set_readAction(self, readAction):
        self.readAction = readAction
    def get_testable(self):
        return self.testable
    def set_testable(self, testable):
        self.testable = testable
    def get_reserved(self):
        return self.reserved
    def set_reserved(self, reserved):
        self.reserved = reserved
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_fieldID(self):
        return self.fieldID
    def set_fieldID(self, fieldID):
        self.fieldID = fieldID
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.bitOffset is not None or
            self.resets is not None or
            self.typeIdentifier is not None or
            self.bitWidth is not None or
            self.volatile is not None or
            self.access is not None or
            self.enumeratedValues is not None or
            self.modifiedWriteValue is not None or
            self.writeValueConstraint is not None or
            self.readAction is not None or
            self.testable is not None or
            self.reserved is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fieldType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fieldType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fieldType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fieldType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fieldType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='fieldType'):
        if self.fieldID is not None and 'fieldID' not in already_processed:
            already_processed.add('fieldID')
            outfile.write(' fieldID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fieldID), input_name='fieldID')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fieldType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.bitOffset is not None:
            namespaceprefix_ = self.bitOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.bitOffset_nsprefix_) else ''
            self.bitOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bitOffset', pretty_print=pretty_print)
        if self.resets is not None:
            namespaceprefix_ = self.resets_nsprefix_ + ':' if (UseCapturedNS_ and self.resets_nsprefix_) else ''
            self.resets.export(outfile, level, namespaceprefix_, namespacedef_='', name_='resets', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            namespaceprefix_ = self.typeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.typeIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stypeIdentifier>%s</%stypeIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), namespaceprefix_ , eol_))
        if self.bitWidth is not None:
            namespaceprefix_ = self.bitWidth_nsprefix_ + ':' if (UseCapturedNS_ and self.bitWidth_nsprefix_) else ''
            self.bitWidth.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bitWidth', pretty_print=pretty_print)
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        if self.enumeratedValues is not None:
            namespaceprefix_ = self.enumeratedValues_nsprefix_ + ':' if (UseCapturedNS_ and self.enumeratedValues_nsprefix_) else ''
            self.enumeratedValues.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='enumeratedValues', pretty_print=pretty_print)
        if self.modifiedWriteValue is not None:
            namespaceprefix_ = self.modifiedWriteValue_nsprefix_ + ':' if (UseCapturedNS_ and self.modifiedWriteValue_nsprefix_) else ''
            self.modifiedWriteValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modifiedWriteValue', pretty_print=pretty_print)
        if self.writeValueConstraint is not None:
            namespaceprefix_ = self.writeValueConstraint_nsprefix_ + ':' if (UseCapturedNS_ and self.writeValueConstraint_nsprefix_) else ''
            self.writeValueConstraint.export(outfile, level, namespaceprefix_, namespacedef_='', name_='writeValueConstraint', pretty_print=pretty_print)
        if self.readAction is not None:
            namespaceprefix_ = self.readAction_nsprefix_ + ':' if (UseCapturedNS_ and self.readAction_nsprefix_) else ''
            self.readAction.export(outfile, level, namespaceprefix_, namespacedef_='', name_='readAction', pretty_print=pretty_print)
        if self.testable is not None:
            namespaceprefix_ = self.testable_nsprefix_ + ':' if (UseCapturedNS_ and self.testable_nsprefix_) else ''
            self.testable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='testable', pretty_print=pretty_print)
        if self.reserved is not None:
            namespaceprefix_ = self.reserved_nsprefix_ + ':' if (UseCapturedNS_ and self.reserved_nsprefix_) else ''
            self.reserved.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reserved', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fieldID', node)
        if value is not None and 'fieldID' not in already_processed:
            already_processed.add('fieldID')
            self.fieldID = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType49.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'bitOffset':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bitOffset = obj_
            obj_.original_tagname_ = 'bitOffset'
        elif nodeName_ == 'resets':
            obj_ = resetsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.resets = obj_
            obj_.original_tagname_ = 'resets'
        elif nodeName_ == 'typeIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeIdentifier')
            value_ = self.gds_validate_string(value_, node, 'typeIdentifier')
            self.typeIdentifier = value_
            self.typeIdentifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'bitWidth':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bitWidth = obj_
            obj_.original_tagname_ = 'bitWidth'
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'enumeratedValues':
            obj_ = enumeratedValues.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enumeratedValues = obj_
            obj_.original_tagname_ = 'enumeratedValues'
        elif nodeName_ == 'modifiedWriteValue':
            obj_ = modifiedWriteValueType56.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modifiedWriteValue = obj_
            obj_.original_tagname_ = 'modifiedWriteValue'
        elif nodeName_ == 'writeValueConstraint':
            obj_ = writeValueConstraintType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.writeValueConstraint = obj_
            obj_.original_tagname_ = 'writeValueConstraint'
        elif nodeName_ == 'readAction':
            obj_ = readActionType57.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.readAction = obj_
            obj_.original_tagname_ = 'readAction'
        elif nodeName_ == 'testable':
            obj_ = testableType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.testable = obj_
            obj_.original_tagname_ = 'testable'
        elif nodeName_ == 'reserved':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reserved = obj_
            obj_.original_tagname_ = 'reserved'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class fieldType


class memoryMapType(GeneratedsSuper):
    """name -- Unique name
    subspaceMap -- Maps in an address subspace from across a bus bridge.  Its masterRef attribute refers by name to the master bus interface on the other side of the bridge.  It must match the masterRef attribute of a bridge element on the slave interface, and that bridge element must be designated as opaque.
    memoryRemap -- Additional memory map elements that are dependent on the component state.
    shared -- When the value is 'yes', the contents of the memoryMap are shared by all the references to this memoryMap, when the value is 'no' the contents of the memoryMap is not shared and when the value is 'undefined' (default) the sharing of the memoryMap is undefined.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'addressBlock', 'ref': 'addressBlock', 'type': 'addressBlock'}, None),
        MemberSpec_('bank', 'addressBankType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'bank', 'ref': 'bank', 'type': 'bank'}, None),
        MemberSpec_('subspaceMap', 'subspaceRefType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'subspaceMap', 'type': 'subspaceRefType'}, None),
        MemberSpec_('memoryRemap', 'memoryRemapType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'memoryRemap', 'type': 'memoryRemapType'}, None),
        MemberSpec_('addressUnitBits', 'unsignedPositiveLongintExpression', 0, 1, {'minOccurs': '0', 'name': 'addressUnitBits', 'ref': 'addressUnitBits', 'type': 'addressUnitBits'}, None),
        MemberSpec_('shared', ['sharedType', 'xs:token'], 0, 1, {'minOccurs': '0', 'name': 'shared', 'type': 'xs:token'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, addressBlock=None, bank=None, subspaceMap=None, memoryRemap=None, addressUnitBits=None, shared=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        self.addressBlock_nsprefix_ = "ipxact"
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        self.bank_nsprefix_ = "ipxact"
        if subspaceMap is None:
            self.subspaceMap = []
        else:
            self.subspaceMap = subspaceMap
        self.subspaceMap_nsprefix_ = "ipxact"
        if memoryRemap is None:
            self.memoryRemap = []
        else:
            self.memoryRemap = memoryRemap
        self.memoryRemap_nsprefix_ = "ipxact"
        self.addressUnitBits = addressUnitBits
        self.addressUnitBits_nsprefix_ = "ipxact"
        self.shared = shared
        self.validate_sharedType(self.shared)
        self.shared_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, memoryMapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if memoryMapType.subclass:
            return memoryMapType.subclass(*args_, **kwargs_)
        else:
            return memoryMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_addressBlock(self):
        return self.addressBlock
    def set_addressBlock(self, addressBlock):
        self.addressBlock = addressBlock
    def add_addressBlock(self, value):
        self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value):
        self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value):
        self.addressBlock[index] = value
    def get_bank(self):
        return self.bank
    def set_bank(self, bank):
        self.bank = bank
    def add_bank(self, value):
        self.bank.append(value)
    def insert_bank_at(self, index, value):
        self.bank.insert(index, value)
    def replace_bank_at(self, index, value):
        self.bank[index] = value
    def get_subspaceMap(self):
        return self.subspaceMap
    def set_subspaceMap(self, subspaceMap):
        self.subspaceMap = subspaceMap
    def add_subspaceMap(self, value):
        self.subspaceMap.append(value)
    def insert_subspaceMap_at(self, index, value):
        self.subspaceMap.insert(index, value)
    def replace_subspaceMap_at(self, index, value):
        self.subspaceMap[index] = value
    def get_memoryRemap(self):
        return self.memoryRemap
    def set_memoryRemap(self, memoryRemap):
        self.memoryRemap = memoryRemap
    def add_memoryRemap(self, value):
        self.memoryRemap.append(value)
    def insert_memoryRemap_at(self, index, value):
        self.memoryRemap.insert(index, value)
    def replace_memoryRemap_at(self, index, value):
        self.memoryRemap[index] = value
    def get_addressUnitBits(self):
        return self.addressUnitBits
    def set_addressUnitBits(self, addressUnitBits):
        self.addressUnitBits = addressUnitBits
    def get_shared(self):
        return self.shared
    def set_shared(self, shared):
        self.shared = shared
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_sharedType(self, value):
        result = True
        # Validate type sharedType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['yes', 'no', 'undefined']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on sharedType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.subspaceMap or
            self.memoryRemap or
            self.addressUnitBits is not None or
            self.shared is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='memoryMapType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memoryMapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'memoryMapType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='memoryMapType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='memoryMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='memoryMapType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='memoryMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            namespaceprefix_ = self.addressBlock_nsprefix_ + ':' if (UseCapturedNS_ and self.addressBlock_nsprefix_) else ''
            addressBlock_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            namespaceprefix_ = self.bank_nsprefix_ + ':' if (UseCapturedNS_ and self.bank_nsprefix_) else ''
            bank_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='bank', pretty_print=pretty_print)
        for subspaceMap_ in self.subspaceMap:
            namespaceprefix_ = self.subspaceMap_nsprefix_ + ':' if (UseCapturedNS_ and self.subspaceMap_nsprefix_) else ''
            subspaceMap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subspaceMap', pretty_print=pretty_print)
        for memoryRemap_ in self.memoryRemap:
            namespaceprefix_ = self.memoryRemap_nsprefix_ + ':' if (UseCapturedNS_ and self.memoryRemap_nsprefix_) else ''
            memoryRemap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='memoryRemap', pretty_print=pretty_print)
        if self.addressUnitBits is not None:
            namespaceprefix_ = self.addressUnitBits_nsprefix_ + ':' if (UseCapturedNS_ and self.addressUnitBits_nsprefix_) else ''
            self.addressUnitBits.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='addressUnitBits', pretty_print=pretty_print)
        if self.shared is not None:
            namespaceprefix_ = self.shared_nsprefix_ + ':' if (UseCapturedNS_ and self.shared_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshared>%s</%sshared>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.shared), input_name='shared')), namespaceprefix_ , eol_))
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = addressBlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = addressBankType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'subspaceMap':
            obj_ = subspaceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subspaceMap.append(obj_)
            obj_.original_tagname_ = 'subspaceMap'
        elif nodeName_ == 'memoryRemap':
            obj_ = memoryRemapType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.memoryRemap.append(obj_)
            obj_.original_tagname_ = 'memoryRemap'
        elif nodeName_ == 'addressUnitBits':
            obj_ = unsignedPositiveLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressUnitBits = obj_
            obj_.original_tagname_ = 'addressUnitBits'
        elif nodeName_ == 'shared':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'shared')
            value_ = self.gds_validate_string(value_, node, 'shared')
            self.shared = value_
            self.shared_nsprefix_ = child_.prefix
            # validate type sharedType
            self.validate_sharedType(self.shared)
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class memoryMapType


class memoryRemapType(GeneratedsSuper):
    """name -- Unique name
    subspaceMap -- Maps in an address subspace from across a bus bridge.  Its masterRef attribute refers by name to the master bus interface on the other side of the bridge.  It must match the masterRef attribute of a bridge element on the slave interface, and that bridge element must be designated as opaque.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('state', 'xs:Name', 0, 0, {'use': 'required', 'name': 'state'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'addressBlock', 'ref': 'addressBlock', 'type': 'addressBlock'}, None),
        MemberSpec_('bank', 'addressBankType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'bank', 'ref': 'bank', 'type': 'bank'}, None),
        MemberSpec_('subspaceMap', 'subspaceRefType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'subspaceMap', 'type': 'subspaceRefType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, state=None, id=None, name=None, displayName=None, description=None, isPresent=None, addressBlock=None, bank=None, subspaceMap=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.state = _cast(None, state)
        self.state_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        self.addressBlock_nsprefix_ = "ipxact"
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        self.bank_nsprefix_ = "ipxact"
        if subspaceMap is None:
            self.subspaceMap = []
        else:
            self.subspaceMap = subspaceMap
        self.subspaceMap_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, memoryRemapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if memoryRemapType.subclass:
            return memoryRemapType.subclass(*args_, **kwargs_)
        else:
            return memoryRemapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_addressBlock(self):
        return self.addressBlock
    def set_addressBlock(self, addressBlock):
        self.addressBlock = addressBlock
    def add_addressBlock(self, value):
        self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value):
        self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value):
        self.addressBlock[index] = value
    def get_bank(self):
        return self.bank
    def set_bank(self, bank):
        self.bank = bank
    def add_bank(self, value):
        self.bank.append(value)
    def insert_bank_at(self, index, value):
        self.bank.insert(index, value)
    def replace_bank_at(self, index, value):
        self.bank[index] = value
    def get_subspaceMap(self):
        return self.subspaceMap
    def set_subspaceMap(self, subspaceMap):
        self.subspaceMap = subspaceMap
    def add_subspaceMap(self, value):
        self.subspaceMap.append(value)
    def insert_subspaceMap_at(self, index, value):
        self.subspaceMap.insert(index, value)
    def replace_subspaceMap_at(self, index, value):
        self.subspaceMap[index] = value
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.subspaceMap
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='memoryRemapType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memoryRemapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'memoryRemapType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='memoryRemapType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='memoryRemapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='memoryRemapType'):
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='memoryRemapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            namespaceprefix_ = self.addressBlock_nsprefix_ + ':' if (UseCapturedNS_ and self.addressBlock_nsprefix_) else ''
            addressBlock_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            namespaceprefix_ = self.bank_nsprefix_ + ':' if (UseCapturedNS_ and self.bank_nsprefix_) else ''
            bank_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='bank', pretty_print=pretty_print)
        for subspaceMap_ in self.subspaceMap:
            namespaceprefix_ = self.subspaceMap_nsprefix_ + ':' if (UseCapturedNS_ and self.subspaceMap_nsprefix_) else ''
            subspaceMap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subspaceMap', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = addressBlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = addressBankType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'subspaceMap':
            obj_ = subspaceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subspaceMap.append(obj_)
            obj_.original_tagname_ = 'subspaceMap'
# end class memoryRemapType


class localMemoryMapType(GeneratedsSuper):
    """name -- Unique name
    bank -- Represents a bank of memory made up of address blocks or other banks.  It has a bankAlignment attribute indicating whether its blocks are aligned in 'parallel' (occupying adjacent bit fields) or 'serial' (occupying contiguous addresses). Its child blocks do not contain addresses or bit offsets.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 1, {'name': 'addressBlock', 'ref': 'addressBlock', 'type': 'addressBlock'}, 20),
        MemberSpec_('bank', 'addressBankType', 1, 1, {'name': 'bank', 'type': 'localAddressBankType'}, 20),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, addressBlock=None, bank=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        self.addressBlock_nsprefix_ = "ipxact"
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        self.bank_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, localMemoryMapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if localMemoryMapType.subclass:
            return localMemoryMapType.subclass(*args_, **kwargs_)
        else:
            return localMemoryMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_addressBlock(self):
        return self.addressBlock
    def set_addressBlock(self, addressBlock):
        self.addressBlock = addressBlock
    def add_addressBlock(self, value):
        self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value):
        self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value):
        self.addressBlock[index] = value
    def get_bank(self):
        return self.bank
    def set_bank(self, bank):
        self.bank = bank
    def add_bank(self, value):
        self.bank.append(value)
    def insert_bank_at(self, index, value):
        self.bank.insert(index, value)
    def replace_bank_at(self, index, value):
        self.bank[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='localMemoryMapType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('localMemoryMapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'localMemoryMapType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='localMemoryMapType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='localMemoryMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='localMemoryMapType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='localMemoryMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            namespaceprefix_ = self.addressBlock_nsprefix_ + ':' if (UseCapturedNS_ and self.addressBlock_nsprefix_) else ''
            addressBlock_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            namespaceprefix_ = self.bank_nsprefix_ + ':' if (UseCapturedNS_ and self.bank_nsprefix_) else ''
            bank_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bank', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = addressBlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = localAddressBankType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
# end class localMemoryMapType


class subspaceRefType(GeneratedsSuper):
    """name -- Unique name
    parameters -- Any parameters that may apply to the subspace reference.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('masterRef', 'xs:Name', 0, 0, {'use': 'required', 'name': 'masterRef'}),
        MemberSpec_('segmentRef', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'segmentRef'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 0, {'name': 'baseAddress', 'ref': 'baseAddress', 'type': 'baseAddress'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, masterRef=None, segmentRef=None, name=None, displayName=None, description=None, isPresent=None, baseAddress=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.masterRef = _cast(None, masterRef)
        self.masterRef_nsprefix_ = None
        self.segmentRef = _cast(None, segmentRef)
        self.segmentRef_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        self.baseAddress = baseAddress
        self.baseAddress_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subspaceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subspaceRefType.subclass:
            return subspaceRefType.subclass(*args_, **kwargs_)
        else:
            return subspaceRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_baseAddress(self):
        return self.baseAddress
    def set_baseAddress(self, baseAddress):
        self.baseAddress = baseAddress
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_masterRef(self):
        return self.masterRef
    def set_masterRef(self, masterRef):
        self.masterRef = masterRef
    def get_segmentRef(self):
        return self.segmentRef
    def set_segmentRef(self, segmentRef):
        self.segmentRef = segmentRef
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.baseAddress is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='subspaceRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subspaceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'subspaceRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='subspaceRefType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='subspaceRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='subspaceRefType'):
        if self.masterRef is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            outfile.write(' masterRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.masterRef), input_name='masterRef')), ))
        if self.segmentRef is not None and 'segmentRef' not in already_processed:
            already_processed.add('segmentRef')
            outfile.write(' segmentRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segmentRef), input_name='segmentRef')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='subspaceRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.baseAddress is not None:
            namespaceprefix_ = self.baseAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.baseAddress_nsprefix_) else ''
            self.baseAddress.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='baseAddress', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterRef', node)
        if value is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            self.masterRef = value
        value = find_attr_value_('segmentRef', node)
        if value is not None and 'segmentRef' not in already_processed:
            already_processed.add('segmentRef')
            self.segmentRef = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'baseAddress':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class subspaceRefType


class addressSpaces(GeneratedsSuper):
    """addressSpace -- This defines a logical space, referenced by a bus master.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('addressSpace', 'addressSpaceType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'addressSpace', 'type': 'addressSpaceType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, addressSpace=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if addressSpace is None:
            self.addressSpace = []
        else:
            self.addressSpace = addressSpace
        self.addressSpace_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressSpaces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressSpaces.subclass:
            return addressSpaces.subclass(*args_, **kwargs_)
        else:
            return addressSpaces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_addressSpace(self):
        return self.addressSpace
    def set_addressSpace(self, addressSpace):
        self.addressSpace = addressSpace
    def add_addressSpace(self, value):
        self.addressSpace.append(value)
    def insert_addressSpace_at(self, index, value):
        self.addressSpace.insert(index, value)
    def replace_addressSpace_at(self, index, value):
        self.addressSpace[index] = value
    def _hasContent(self):
        if (
            self.addressSpace
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressSpaces', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressSpaces')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'addressSpaces':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addressSpaces')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addressSpaces', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='addressSpaces'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressSpaces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for addressSpace_ in self.addressSpace:
            namespaceprefix_ = self.addressSpace_nsprefix_ + ':' if (UseCapturedNS_ and self.addressSpace_nsprefix_) else ''
            addressSpace_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressSpace', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'addressSpace':
            obj_ = addressSpaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressSpace.append(obj_)
            obj_.original_tagname_ = 'addressSpace'
# end class addressSpaces


class memoryMaps(GeneratedsSuper):
    """memoryMap -- The set of address blocks a bus slave contributes to the bus' address space.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('memoryMap', 'memoryMapType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'memoryMap', 'type': 'memoryMapType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, memoryMap=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if memoryMap is None:
            self.memoryMap = []
        else:
            self.memoryMap = memoryMap
        self.memoryMap_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, memoryMaps)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if memoryMaps.subclass:
            return memoryMaps.subclass(*args_, **kwargs_)
        else:
            return memoryMaps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_memoryMap(self):
        return self.memoryMap
    def set_memoryMap(self, memoryMap):
        self.memoryMap = memoryMap
    def add_memoryMap(self, value):
        self.memoryMap.append(value)
    def insert_memoryMap_at(self, index, value):
        self.memoryMap.insert(index, value)
    def replace_memoryMap_at(self, index, value):
        self.memoryMap[index] = value
    def _hasContent(self):
        if (
            self.memoryMap
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='memoryMaps', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memoryMaps')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'memoryMaps':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='memoryMaps')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='memoryMaps', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='memoryMaps'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='memoryMaps', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for memoryMap_ in self.memoryMap:
            namespaceprefix_ = self.memoryMap_nsprefix_ + ':' if (UseCapturedNS_ and self.memoryMap_nsprefix_) else ''
            memoryMap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='memoryMap', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'memoryMap':
            obj_ = memoryMapType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.memoryMap.append(obj_)
            obj_.original_tagname_ = 'memoryMap'
# end class memoryMaps


class alternateRegisters(GeneratedsSuper):
    """alternateRegister -- Alternate definition for the current register
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('alternateRegister', 'alternateRegisterType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'alternateRegister', 'type': 'alternateRegisterType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, alternateRegister=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if alternateRegister is None:
            self.alternateRegister = []
        else:
            self.alternateRegister = alternateRegister
        self.alternateRegister_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateRegisters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateRegisters.subclass:
            return alternateRegisters.subclass(*args_, **kwargs_)
        else:
            return alternateRegisters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateRegister(self):
        return self.alternateRegister
    def set_alternateRegister(self, alternateRegister):
        self.alternateRegister = alternateRegister
    def add_alternateRegister(self, value):
        self.alternateRegister.append(value)
    def insert_alternateRegister_at(self, index, value):
        self.alternateRegister.insert(index, value)
    def replace_alternateRegister_at(self, index, value):
        self.alternateRegister[index] = value
    def _hasContent(self):
        if (
            self.alternateRegister
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='alternateRegisters', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateRegisters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateRegisters':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateRegisters')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateRegisters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='alternateRegisters'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='alternateRegisters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateRegister_ in self.alternateRegister:
            namespaceprefix_ = self.alternateRegister_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateRegister_nsprefix_) else ''
            alternateRegister_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateRegister', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateRegister':
            obj_ = alternateRegisterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateRegister.append(obj_)
            obj_.original_tagname_ = 'alternateRegister'
# end class alternateRegisters


class enumeratedValues(GeneratedsSuper):
    """enumeratedValue -- Enumerates specific values that can be assigned to the bit field. The name of this enumerated value. This may be used as a token in generating code.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('enumeratedValue', 'enumeratedValueType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'enumeratedValue', 'type': 'enumeratedValueType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, enumeratedValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if enumeratedValue is None:
            self.enumeratedValue = []
        else:
            self.enumeratedValue = enumeratedValue
        self.enumeratedValue_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, enumeratedValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if enumeratedValues.subclass:
            return enumeratedValues.subclass(*args_, **kwargs_)
        else:
            return enumeratedValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_enumeratedValue(self):
        return self.enumeratedValue
    def set_enumeratedValue(self, enumeratedValue):
        self.enumeratedValue = enumeratedValue
    def add_enumeratedValue(self, value):
        self.enumeratedValue.append(value)
    def insert_enumeratedValue_at(self, index, value):
        self.enumeratedValue.insert(index, value)
    def replace_enumeratedValue_at(self, index, value):
        self.enumeratedValue[index] = value
    def _hasContent(self):
        if (
            self.enumeratedValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='enumeratedValues', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('enumeratedValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'enumeratedValues':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='enumeratedValues')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='enumeratedValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='enumeratedValues'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='enumeratedValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for enumeratedValue_ in self.enumeratedValue:
            namespaceprefix_ = self.enumeratedValue_nsprefix_ + ':' if (UseCapturedNS_ and self.enumeratedValue_nsprefix_) else ''
            enumeratedValue_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enumeratedValue', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'enumeratedValue':
            obj_ = enumeratedValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enumeratedValue.append(obj_)
            obj_.original_tagname_ = 'enumeratedValue'
# end class enumeratedValues


class valueMaskConfigType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, valueMaskConfigType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if valueMaskConfigType.subclass:
            return valueMaskConfigType.subclass(*args_, **kwargs_)
        else:
            return valueMaskConfigType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='valueMaskConfigType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('valueMaskConfigType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'valueMaskConfigType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='valueMaskConfigType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='valueMaskConfigType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='valueMaskConfigType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='valueMaskConfigType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class valueMaskConfigType


class writeValueConstraintType(GeneratedsSuper):
    """writeAsRead -- writeAsRead indicates that only a value immediately read before a write is a legal value to be written.
    useEnumeratedValues -- useEnumeratedValues indicates that only write enumeration value shall be legal values to be written.
    minimum -- The minimum legal value that may be written to a field
    maximum -- The maximum legal value that may be written to a field
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('writeAsRead', 'xs:boolean', 0, 0, {'name': 'writeAsRead', 'type': 'xs:boolean'}, 24),
        MemberSpec_('useEnumeratedValues', 'xs:boolean', 0, 0, {'name': 'useEnumeratedValues', 'type': 'xs:boolean'}, 24),
        MemberSpec_('minimum', 'unsignedBitVectorExpression', 0, 0, {'name': 'minimum', 'type': 'unsignedBitVectorExpression'}, 24),
        MemberSpec_('maximum', 'unsignedBitVectorExpression', 0, 0, {'name': 'maximum', 'type': 'unsignedBitVectorExpression'}, 24),
    ]
    subclass = None
    superclass = None
    def __init__(self, writeAsRead=None, useEnumeratedValues=None, minimum=None, maximum=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.writeAsRead = writeAsRead
        self.writeAsRead_nsprefix_ = "ipxact"
        self.useEnumeratedValues = useEnumeratedValues
        self.useEnumeratedValues_nsprefix_ = "ipxact"
        self.minimum = minimum
        self.minimum_nsprefix_ = "ipxact"
        self.maximum = maximum
        self.maximum_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, writeValueConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if writeValueConstraintType.subclass:
            return writeValueConstraintType.subclass(*args_, **kwargs_)
        else:
            return writeValueConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_writeAsRead(self):
        return self.writeAsRead
    def set_writeAsRead(self, writeAsRead):
        self.writeAsRead = writeAsRead
    def get_useEnumeratedValues(self):
        return self.useEnumeratedValues
    def set_useEnumeratedValues(self, useEnumeratedValues):
        self.useEnumeratedValues = useEnumeratedValues
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def _hasContent(self):
        if (
            self.writeAsRead is not None or
            self.useEnumeratedValues is not None or
            self.minimum is not None or
            self.maximum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='writeValueConstraintType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('writeValueConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'writeValueConstraintType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='writeValueConstraintType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='writeValueConstraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='writeValueConstraintType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='writeValueConstraintType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.writeAsRead is not None:
            namespaceprefix_ = self.writeAsRead_nsprefix_ + ':' if (UseCapturedNS_ and self.writeAsRead_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swriteAsRead>%s</%swriteAsRead>%s' % (namespaceprefix_ , self.gds_format_boolean(self.writeAsRead, input_name='writeAsRead'), namespaceprefix_ , eol_))
        if self.useEnumeratedValues is not None:
            namespaceprefix_ = self.useEnumeratedValues_nsprefix_ + ':' if (UseCapturedNS_ and self.useEnumeratedValues_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suseEnumeratedValues>%s</%suseEnumeratedValues>%s' % (namespaceprefix_ , self.gds_format_boolean(self.useEnumeratedValues, input_name='useEnumeratedValues'), namespaceprefix_ , eol_))
        if self.minimum is not None:
            namespaceprefix_ = self.minimum_nsprefix_ + ':' if (UseCapturedNS_ and self.minimum_nsprefix_) else ''
            self.minimum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='minimum', pretty_print=pretty_print)
        if self.maximum is not None:
            namespaceprefix_ = self.maximum_nsprefix_ + ':' if (UseCapturedNS_ and self.maximum_nsprefix_) else ''
            self.maximum.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maximum', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'writeAsRead':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'writeAsRead')
            ival_ = self.gds_validate_boolean(ival_, node, 'writeAsRead')
            self.writeAsRead = ival_
            self.writeAsRead_nsprefix_ = child_.prefix
        elif nodeName_ == 'useEnumeratedValues':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'useEnumeratedValues')
            ival_ = self.gds_validate_boolean(ival_, node, 'useEnumeratedValues')
            self.useEnumeratedValues = ival_
            self.useEnumeratedValues_nsprefix_ = child_.prefix
        elif nodeName_ == 'minimum':
            obj_ = unsignedBitVectorExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.minimum = obj_
            obj_.original_tagname_ = 'minimum'
        elif nodeName_ == 'maximum':
            obj_ = unsignedBitVectorExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maximum = obj_
            obj_.original_tagname_ = 'maximum'
# end class writeValueConstraintType


class registerFile(GeneratedsSuper):
    """name -- Unique name
    dim -- Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.
    addressOffset -- Offset from the address block's baseAddress or the containing register file's addressOffset, expressed as the number of addressUnitBits from the containing memoryMap or localMemoryMap.
    typeIdentifier -- Identifier name used to indicate that multiple registerFile elements contain the exact same information except for the elements in the registerFileInstanceGroup.
    range -- The range of a register file.  Expressed as the number of addressable units accessible to the block. Specified in units of addressUnitBits.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType58', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType58'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('dim', 'dimType59', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'dim', 'type': 'dimType59'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'name': 'addressOffset', 'type': 'unsignedLongintExpression'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'typeIdentifier', 'type': 'xs:Name'}, None),
        MemberSpec_('Range', 'unsignedPositiveLongintExpression', 0, 0, {'name': 'range', 'type': 'unsignedPositiveLongintExpression'}, None),
        MemberSpec_('registerData', 'xs:string', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'registerData', 'ref': 'registerData', 'type': 'xs:string'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, dim=None, addressOffset=None, typeIdentifier=None, Range=None, registerData=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = "ipxact"
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        if dim is None:
            self.dim = []
        else:
            self.dim = dim
        self.dim_nsprefix_ = "ipxact"
        self.addressOffset = addressOffset
        self.addressOffset_nsprefix_ = "ipxact"
        self.typeIdentifier = typeIdentifier
        self.typeIdentifier_nsprefix_ = "ipxact"
        self.Range = Range
        self.Range_nsprefix_ = "ipxact"
        if registerData is None:
            self.registerData = []
        else:
            self.registerData = registerData
        self.registerData_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, registerFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if registerFile.subclass:
            return registerFile.subclass(*args_, **kwargs_)
        else:
            return registerFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_dim(self):
        return self.dim
    def set_dim(self, dim):
        self.dim = dim
    def add_dim(self, value):
        self.dim.append(value)
    def insert_dim_at(self, index, value):
        self.dim.insert(index, value)
    def replace_dim_at(self, index, value):
        self.dim[index] = value
    def get_addressOffset(self):
        return self.addressOffset
    def set_addressOffset(self, addressOffset):
        self.addressOffset = addressOffset
    def get_typeIdentifier(self):
        return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier):
        self.typeIdentifier = typeIdentifier
    def get_range(self):
        return self.Range
    def set_range(self, Range):
        self.Range = Range
    def get_registerData(self):
        return self.registerData
    def set_registerData(self, registerData):
        self.registerData = registerData
    def add_registerData(self, value):
        self.registerData.append(value)
    def insert_registerData_at(self, index, value):
        self.registerData.insert(index, value)
    def replace_registerData_at(self, index, value):
        self.registerData[index] = value
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.dim or
            self.addressOffset is not None or
            self.typeIdentifier is not None or
            self.Range is not None or
            self.registerData or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='registerFile', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('registerFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'registerFile':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='registerFile')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='registerFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='registerFile'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='registerFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for dim_ in self.dim:
            namespaceprefix_ = self.dim_nsprefix_ + ':' if (UseCapturedNS_ and self.dim_nsprefix_) else ''
            dim_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dim', pretty_print=pretty_print)
        if self.addressOffset is not None:
            namespaceprefix_ = self.addressOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.addressOffset_nsprefix_) else ''
            self.addressOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressOffset', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            namespaceprefix_ = self.typeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.typeIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stypeIdentifier>%s</%stypeIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), namespaceprefix_ , eol_))
        if self.Range is not None:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            self.Range.export(outfile, level, namespaceprefix_, namespacedef_='', name_='range', pretty_print=pretty_print)
        for registerData_ in self.registerData:
            namespaceprefix_ = self.registerData_nsprefix_ + ':' if (UseCapturedNS_ and self.registerData_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sregisterData>%s</%sregisterData>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(registerData_), input_name='registerData')), namespaceprefix_ , eol_))
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType58.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'dim':
            obj_ = dimType59.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dim.append(obj_)
            obj_.original_tagname_ = 'dim'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'typeIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeIdentifier')
            value_ = self.gds_validate_string(value_, node, 'typeIdentifier')
            self.typeIdentifier = value_
            self.typeIdentifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'range':
            obj_ = unsignedPositiveLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
        elif nodeName_ == 'registerData':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'registerData')
            value_ = self.gds_validate_string(value_, node, 'registerData')
            self.registerData.append(value_)
            self.registerData_nsprefix_ = child_.prefix
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class registerFile


class reset(GeneratedsSuper):
    """value -- The value itself.
    mask -- Mask to be anded with the value before comparing to the reset value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('resetTypeRef', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'resetTypeRef'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('value', 'stringExpression', 0, 0, {'name': 'value', 'type': 'unsignedBitVectorExpression'}, None),
        MemberSpec_('mask', 'unsignedBitVectorExpression', 0, 1, {'minOccurs': '0', 'name': 'mask', 'type': 'unsignedBitVectorExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, resetTypeRef=None, id=None, value=None, mask=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.resetTypeRef = _cast(None, resetTypeRef)
        self.resetTypeRef_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = "ipxact"
        self.mask = mask
        self.mask_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reset.subclass:
            return reset.subclass(*args_, **kwargs_)
        else:
            return reset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_mask(self):
        return self.mask
    def set_mask(self, mask):
        self.mask = mask
    def get_resetTypeRef(self):
        return self.resetTypeRef
    def set_resetTypeRef(self, resetTypeRef):
        self.resetTypeRef = resetTypeRef
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.value is not None or
            self.mask is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='reset', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('reset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'reset':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='reset')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='reset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='reset'):
        if self.resetTypeRef is not None and 'resetTypeRef' not in already_processed:
            already_processed.add('resetTypeRef')
            outfile.write(' resetTypeRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.resetTypeRef), input_name='resetTypeRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='reset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        if self.mask is not None:
            namespaceprefix_ = self.mask_nsprefix_ + ':' if (UseCapturedNS_ and self.mask_nsprefix_) else ''
            self.mask.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mask', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resetTypeRef', node)
        if value is not None and 'resetTypeRef' not in already_processed:
            already_processed.add('resetTypeRef')
            self.resetTypeRef = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'value':
            obj_ = unsignedBitVectorExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'mask':
            obj_ = unsignedBitVectorExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mask = obj_
            obj_.original_tagname_ = 'mask'
# end class reset


class designInstantiationType(GeneratedsSuper):
    """name -- Unique name
    designRef -- References an IP-XACT design document (by VLNV) that provides a design for the component.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('designRef', 'configurableLibraryRefType', 0, 0, {'name': 'designRef', 'type': 'configurableLibraryRefType'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, designRef=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.designRef = designRef
        self.designRef_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, designInstantiationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if designInstantiationType.subclass:
            return designInstantiationType.subclass(*args_, **kwargs_)
        else:
            return designInstantiationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_designRef(self):
        return self.designRef
    def set_designRef(self, designRef):
        self.designRef = designRef
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.designRef is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='designInstantiationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('designInstantiationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'designInstantiationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='designInstantiationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='designInstantiationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='designInstantiationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='designInstantiationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.designRef is not None:
            namespaceprefix_ = self.designRef_nsprefix_ + ':' if (UseCapturedNS_ and self.designRef_nsprefix_) else ''
            self.designRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='designRef', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'designRef':
            obj_ = ConfigurableLibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.designRef = obj_
            obj_.original_tagname_ = 'designRef'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class designInstantiationType


class designConfigurationInstantiationType(GeneratedsSuper):
    """name -- Unique name
    language --  The hardware description language used such as "verilog" or "vhdl". If the attribute "strict" is "true", this value must match the language being generated for the design.
    designConfigurationRef -- References an IP-XACT design configuration document (by VLNV) that provides a configuration for the component's design.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('language', 'languageType', 0, 1, {'minOccurs': '0', 'name': 'language', 'type': 'languageType'}, None),
        MemberSpec_('designConfigurationRef', 'configurableLibraryRefType', 0, 0, {'name': 'designConfigurationRef', 'type': 'configurableLibraryRefType'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, language=None, designConfigurationRef=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.language = language
        self.language_nsprefix_ = "ipxact"
        self.designConfigurationRef = designConfigurationRef
        self.designConfigurationRef_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, designConfigurationInstantiationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if designConfigurationInstantiationType.subclass:
            return designConfigurationInstantiationType.subclass(*args_, **kwargs_)
        else:
            return designConfigurationInstantiationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_designConfigurationRef(self):
        return self.designConfigurationRef
    def set_designConfigurationRef(self, designConfigurationRef):
        self.designConfigurationRef = designConfigurationRef
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.language is not None or
            self.designConfigurationRef is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='designConfigurationInstantiationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('designConfigurationInstantiationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'designConfigurationInstantiationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='designConfigurationInstantiationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='designConfigurationInstantiationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='designConfigurationInstantiationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='designConfigurationInstantiationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            self.language.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
        if self.designConfigurationRef is not None:
            namespaceprefix_ = self.designConfigurationRef_nsprefix_ + ':' if (UseCapturedNS_ and self.designConfigurationRef_nsprefix_) else ''
            self.designConfigurationRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='designConfigurationRef', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'language':
            obj_ = languageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language = obj_
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'designConfigurationRef':
            obj_ = ConfigurableLibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.designConfigurationRef = obj_
            obj_.original_tagname_ = 'designConfigurationRef'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class designConfigurationInstantiationType


class componentInstantiationType(GeneratedsSuper):
    """name -- Unique name
    isVirtual -- When true, indicates that this component should not be netlisted.
    language --  The hardware description language used such as "verilog" or "vhdl". If the attribute "strict" is "true", this value must match the language being generated for the design.
    libraryName -- A string specifying the library name in which the model should be compiled. If the libraryName element is not present then its value defaults to
    
    work
    
    .
    packageName -- A string describing the VHDL package containing the interface of the model. If the packageName element is not present then its value defaults to the component VLNV name concatenated with postfix
    
    _cmp_pkg
    
    which stands for component package.
    moduleName -- A string describing the Verilog, SystemVerilog, or SystemC module name or the VHDL entity name. If the moduleName is not present then its value defaults to the component VLNV name
    architectureName -- A string describing the VHDL architecture name. If the architectureName element is not present then its value defaults to
    
    rtl
    
    .
    configurationName -- A string describing the Verilog, SystemVerilog, or VHDL configuration name. If the configurationName element is not present then its value defaults to the design configuration VLNV name of the design configuration associated with the active hierarchical view or, if there is no active hierarchical view, to the component VLNV name concatenated with postfix
    
    _rtl_cfg
    
    .
    moduleParameters -- Model parameter name value pairs container
    defaultFileBuilder -- Default command and flags used to build derived files from the sourceName files in the referenced file sets.
    whiteboxElementRefs --  Container for white box element references.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isVirtual', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isVirtual', 'type': 'xs:boolean'}, None),
        MemberSpec_('language', 'languageType', 0, 1, {'minOccurs': '0', 'name': 'language', 'type': 'languageType'}, None),
        MemberSpec_('libraryName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'libraryName', 'type': 'xs:string'}, None),
        MemberSpec_('packageName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'packageName', 'type': 'xs:string'}, None),
        MemberSpec_('moduleName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'moduleName', 'type': 'xs:string'}, None),
        MemberSpec_('architectureName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'architectureName', 'type': 'xs:string'}, None),
        MemberSpec_('configurationName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'configurationName', 'type': 'xs:string'}, None),
        MemberSpec_('moduleParameters', 'moduleParametersType', 0, 1, {'minOccurs': '0', 'name': 'moduleParameters', 'type': 'moduleParametersType'}, None),
        MemberSpec_('defaultFileBuilder', 'fileBuilderType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'defaultFileBuilder', 'type': 'fileBuilderType'}, None),
        MemberSpec_('fileSetRef', 'fileSetRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'fileSetRef', 'ref': 'fileSetRef', 'type': 'fileSetRef'}, None),
        MemberSpec_('constraintSetRef', 'constraintSetRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'constraintSetRef', 'ref': 'constraintSetRef', 'type': 'constraintSetRef'}, None),
        MemberSpec_('whiteboxElementRefs', 'whiteboxElementRefsType', 0, 1, {'minOccurs': '0', 'name': 'whiteboxElementRefs', 'type': 'whiteboxElementRefsType'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isVirtual=False, language=None, libraryName=None, packageName=None, moduleName=None, architectureName=None, configurationName=None, moduleParameters=None, defaultFileBuilder=None, fileSetRef=None, constraintSetRef=None, whiteboxElementRefs=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.displayName = displayName
        self.displayName_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.isVirtual = isVirtual
        self.isVirtual_nsprefix_ = "ipxact"
        self.language = language
        self.language_nsprefix_ = "ipxact"
        self.libraryName = libraryName
        self.libraryName_nsprefix_ = "ipxact"
        self.packageName = packageName
        self.packageName_nsprefix_ = "ipxact"
        self.moduleName = moduleName
        self.moduleName_nsprefix_ = "ipxact"
        self.architectureName = architectureName
        self.architectureName_nsprefix_ = "ipxact"
        self.configurationName = configurationName
        self.configurationName_nsprefix_ = "ipxact"
        self.moduleParameters = moduleParameters
        self.moduleParameters_nsprefix_ = "ipxact"
        if defaultFileBuilder is None:
            self.defaultFileBuilder = []
        else:
            self.defaultFileBuilder = defaultFileBuilder
        self.defaultFileBuilder_nsprefix_ = "ipxact"
        if fileSetRef is None:
            self.fileSetRef = []
        else:
            self.fileSetRef = fileSetRef
        self.fileSetRef_nsprefix_ = "ipxact"
        if constraintSetRef is None:
            self.constraintSetRef = []
        else:
            self.constraintSetRef = constraintSetRef
        self.constraintSetRef_nsprefix_ = "ipxact"
        self.whiteboxElementRefs = whiteboxElementRefs
        self.whiteboxElementRefs_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentInstantiationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentInstantiationType.subclass:
            return componentInstantiationType.subclass(*args_, **kwargs_)
        else:
            return componentInstantiationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isVirtual(self):
        return self.isVirtual
    def set_isVirtual(self, isVirtual):
        self.isVirtual = isVirtual
    def get_language(self):
        return self.language
    def set_language(self, language):
        self.language = language
    def get_libraryName(self):
        return self.libraryName
    def set_libraryName(self, libraryName):
        self.libraryName = libraryName
    def get_packageName(self):
        return self.packageName
    def set_packageName(self, packageName):
        self.packageName = packageName
    def get_moduleName(self):
        return self.moduleName
    def set_moduleName(self, moduleName):
        self.moduleName = moduleName
    def get_architectureName(self):
        return self.architectureName
    def set_architectureName(self, architectureName):
        self.architectureName = architectureName
    def get_configurationName(self):
        return self.configurationName
    def set_configurationName(self, configurationName):
        self.configurationName = configurationName
    def get_moduleParameters(self):
        return self.moduleParameters
    def set_moduleParameters(self, moduleParameters):
        self.moduleParameters = moduleParameters
    def get_defaultFileBuilder(self):
        return self.defaultFileBuilder
    def set_defaultFileBuilder(self, defaultFileBuilder):
        self.defaultFileBuilder = defaultFileBuilder
    def add_defaultFileBuilder(self, value):
        self.defaultFileBuilder.append(value)
    def insert_defaultFileBuilder_at(self, index, value):
        self.defaultFileBuilder.insert(index, value)
    def replace_defaultFileBuilder_at(self, index, value):
        self.defaultFileBuilder[index] = value
    def get_fileSetRef(self):
        return self.fileSetRef
    def set_fileSetRef(self, fileSetRef):
        self.fileSetRef = fileSetRef
    def add_fileSetRef(self, value):
        self.fileSetRef.append(value)
    def insert_fileSetRef_at(self, index, value):
        self.fileSetRef.insert(index, value)
    def replace_fileSetRef_at(self, index, value):
        self.fileSetRef[index] = value
    def get_constraintSetRef(self):
        return self.constraintSetRef
    def set_constraintSetRef(self, constraintSetRef):
        self.constraintSetRef = constraintSetRef
    def add_constraintSetRef(self, value):
        self.constraintSetRef.append(value)
    def insert_constraintSetRef_at(self, index, value):
        self.constraintSetRef.insert(index, value)
    def replace_constraintSetRef_at(self, index, value):
        self.constraintSetRef[index] = value
    def get_whiteboxElementRefs(self):
        return self.whiteboxElementRefs
    def set_whiteboxElementRefs(self, whiteboxElementRefs):
        self.whiteboxElementRefs = whiteboxElementRefs
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isVirtual or
            self.language is not None or
            self.libraryName is not None or
            self.packageName is not None or
            self.moduleName is not None or
            self.architectureName is not None or
            self.configurationName is not None or
            self.moduleParameters is not None or
            self.defaultFileBuilder or
            self.fileSetRef or
            self.constraintSetRef or
            self.whiteboxElementRefs is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='componentInstantiationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentInstantiationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'componentInstantiationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='componentInstantiationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='componentInstantiationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='componentInstantiationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='componentInstantiationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isVirtual:
            namespaceprefix_ = self.isVirtual_nsprefix_ + ':' if (UseCapturedNS_ and self.isVirtual_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisVirtual>%s</%sisVirtual>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isVirtual, input_name='isVirtual'), namespaceprefix_ , eol_))
        if self.language is not None:
            namespaceprefix_ = self.language_nsprefix_ + ':' if (UseCapturedNS_ and self.language_nsprefix_) else ''
            self.language.export(outfile, level, namespaceprefix_, namespacedef_='', name_='language', pretty_print=pretty_print)
        if self.libraryName is not None:
            namespaceprefix_ = self.libraryName_nsprefix_ + ':' if (UseCapturedNS_ and self.libraryName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slibraryName>%s</%slibraryName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.libraryName), input_name='libraryName')), namespaceprefix_ , eol_))
        if self.packageName is not None:
            namespaceprefix_ = self.packageName_nsprefix_ + ':' if (UseCapturedNS_ and self.packageName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spackageName>%s</%spackageName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.packageName), input_name='packageName')), namespaceprefix_ , eol_))
        if self.moduleName is not None:
            namespaceprefix_ = self.moduleName_nsprefix_ + ':' if (UseCapturedNS_ and self.moduleName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smoduleName>%s</%smoduleName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.moduleName), input_name='moduleName')), namespaceprefix_ , eol_))
        if self.architectureName is not None:
            namespaceprefix_ = self.architectureName_nsprefix_ + ':' if (UseCapturedNS_ and self.architectureName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sarchitectureName>%s</%sarchitectureName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.architectureName), input_name='architectureName')), namespaceprefix_ , eol_))
        if self.configurationName is not None:
            namespaceprefix_ = self.configurationName_nsprefix_ + ':' if (UseCapturedNS_ and self.configurationName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconfigurationName>%s</%sconfigurationName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.configurationName), input_name='configurationName')), namespaceprefix_ , eol_))
        if self.moduleParameters is not None:
            namespaceprefix_ = self.moduleParameters_nsprefix_ + ':' if (UseCapturedNS_ and self.moduleParameters_nsprefix_) else ''
            self.moduleParameters.export(outfile, level, namespaceprefix_, namespacedef_='', name_='moduleParameters', pretty_print=pretty_print)
        for defaultFileBuilder_ in self.defaultFileBuilder:
            namespaceprefix_ = self.defaultFileBuilder_nsprefix_ + ':' if (UseCapturedNS_ and self.defaultFileBuilder_nsprefix_) else ''
            defaultFileBuilder_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='defaultFileBuilder', pretty_print=pretty_print)
        for fileSetRef_ in self.fileSetRef:
            namespaceprefix_ = self.fileSetRef_nsprefix_ + ':' if (UseCapturedNS_ and self.fileSetRef_nsprefix_) else ''
            fileSetRef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='fileSetRef', pretty_print=pretty_print)
        for constraintSetRef_ in self.constraintSetRef:
            namespaceprefix_ = self.constraintSetRef_nsprefix_ + ':' if (UseCapturedNS_ and self.constraintSetRef_nsprefix_) else ''
            constraintSetRef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='constraintSetRef', pretty_print=pretty_print)
        if self.whiteboxElementRefs is not None:
            namespaceprefix_ = self.whiteboxElementRefs_nsprefix_ + ':' if (UseCapturedNS_ and self.whiteboxElementRefs_nsprefix_) else ''
            self.whiteboxElementRefs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='whiteboxElementRefs', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isVirtual':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isVirtual')
            ival_ = self.gds_validate_boolean(ival_, node, 'isVirtual')
            self.isVirtual = ival_
            self.isVirtual_nsprefix_ = child_.prefix
        elif nodeName_ == 'language':
            obj_ = languageType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.language = obj_
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'libraryName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'libraryName')
            value_ = self.gds_validate_string(value_, node, 'libraryName')
            self.libraryName = value_
            self.libraryName_nsprefix_ = child_.prefix
        elif nodeName_ == 'packageName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'packageName')
            value_ = self.gds_validate_string(value_, node, 'packageName')
            self.packageName = value_
            self.packageName_nsprefix_ = child_.prefix
        elif nodeName_ == 'moduleName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'moduleName')
            value_ = self.gds_validate_string(value_, node, 'moduleName')
            self.moduleName = value_
            self.moduleName_nsprefix_ = child_.prefix
        elif nodeName_ == 'architectureName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'architectureName')
            value_ = self.gds_validate_string(value_, node, 'architectureName')
            self.architectureName = value_
            self.architectureName_nsprefix_ = child_.prefix
        elif nodeName_ == 'configurationName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'configurationName')
            value_ = self.gds_validate_string(value_, node, 'configurationName')
            self.configurationName = value_
            self.configurationName_nsprefix_ = child_.prefix
        elif nodeName_ == 'moduleParameters':
            obj_ = moduleParametersType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.moduleParameters = obj_
            obj_.original_tagname_ = 'moduleParameters'
        elif nodeName_ == 'defaultFileBuilder':
            obj_ = fileBuilderType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.defaultFileBuilder.append(obj_)
            obj_.original_tagname_ = 'defaultFileBuilder'
        elif nodeName_ == 'fileSetRef':
            obj_ = fileSetRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileSetRef.append(obj_)
            obj_.original_tagname_ = 'fileSetRef'
        elif nodeName_ == 'constraintSetRef':
            obj_ = constraintSetRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.constraintSetRef.append(obj_)
            obj_.original_tagname_ = 'constraintSetRef'
        elif nodeName_ == 'whiteboxElementRefs':
            obj_ = whiteboxElementRefsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.whiteboxElementRefs = obj_
            obj_.original_tagname_ = 'whiteboxElementRefs'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class componentInstantiationType


class libraryName(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, libraryName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if libraryName.subclass:
            return libraryName.subclass(*args_, **kwargs_)
        else:
            return libraryName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='libraryName', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('libraryName')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'libraryName':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='libraryName')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='libraryName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='libraryName'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='libraryName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class libraryName


class Model(GeneratedsSuper):
    """views -- Views container
    instantiations -- Instantiations container
    ports -- Port container
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('views', 'viewsType', 0, 1, {'minOccurs': '0', 'name': 'views', 'type': 'viewsType'}, None),
        MemberSpec_('instantiations', 'instantiationsType', 0, 1, {'minOccurs': '0', 'name': 'instantiations', 'type': 'instantiationsType'}, None),
        MemberSpec_('ports', 'portsType71', 0, 1, {'minOccurs': '0', 'name': 'ports', 'type': 'portsType71'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, views=None, instantiations=None, ports=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.views = views
        self.views_nsprefix_ = "ipxact"
        self.instantiations = instantiations
        self.instantiations_nsprefix_ = "ipxact"
        self.ports = ports
        self.ports_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Model)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Model.subclass:
            return Model.subclass(*args_, **kwargs_)
        else:
            return Model(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_views(self):
        return self.views
    def set_views(self, views):
        self.views = views
    def get_instantiations(self):
        return self.instantiations
    def set_instantiations(self, instantiations):
        self.instantiations = instantiations
    def get_ports(self):
        return self.ports
    def set_ports(self, ports):
        self.ports = ports
    def _hasContent(self):
        if (
            self.views is not None or
            self.instantiations is not None or
            self.ports is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='modelType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('modelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'modelType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='modelType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='modelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='modelType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='modelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.views is not None:
            namespaceprefix_ = self.views_nsprefix_ + ':' if (UseCapturedNS_ and self.views_nsprefix_) else ''
            self.views.export(outfile, level, namespaceprefix_, namespacedef_='', name_='views', pretty_print=pretty_print)
        if self.instantiations is not None:
            namespaceprefix_ = self.instantiations_nsprefix_ + ':' if (UseCapturedNS_ and self.instantiations_nsprefix_) else ''
            self.instantiations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='instantiations', pretty_print=pretty_print)
        if self.ports is not None:
            namespaceprefix_ = self.ports_nsprefix_ + ':' if (UseCapturedNS_ and self.ports_nsprefix_) else ''
            self.ports.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ports', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'views':
            obj_ = viewsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.views = obj_
            obj_.original_tagname_ = 'views'
        elif nodeName_ == 'instantiations':
            obj_ = instantiationsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instantiations = obj_
            obj_.original_tagname_ = 'instantiations'
        elif nodeName_ == 'ports':
            obj_ = portsType71.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ports = obj_
            obj_.original_tagname_ = 'ports'
# end class Model


class abstractorModelType(GeneratedsSuper):
    """views -- Views container
    instantiations -- Instantiations container
    ports -- Port container
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('views', 'viewsType72', 0, 1, {'minOccurs': '0', 'name': 'views', 'type': 'viewsType72'}, None),
        MemberSpec_('instantiations', 'instantiationsType75', 0, 1, {'minOccurs': '0', 'name': 'instantiations', 'type': 'instantiationsType75'}, None),
        MemberSpec_('ports', 'portsType76', 0, 1, {'minOccurs': '0', 'name': 'ports', 'type': 'portsType76'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, views=None, instantiations=None, ports=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.views = views
        self.views_nsprefix_ = "ipxact"
        self.instantiations = instantiations
        self.instantiations_nsprefix_ = "ipxact"
        self.ports = ports
        self.ports_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorModelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorModelType.subclass:
            return abstractorModelType.subclass(*args_, **kwargs_)
        else:
            return abstractorModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_views(self):
        return self.views
    def set_views(self, views):
        self.views = views
    def get_instantiations(self):
        return self.instantiations
    def set_instantiations(self, instantiations):
        self.instantiations = instantiations
    def get_ports(self):
        return self.ports
    def set_ports(self, ports):
        self.ports = ports
    def _hasContent(self):
        if (
            self.views is not None or
            self.instantiations is not None or
            self.ports is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorModelType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorModelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractorModelType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractorModelType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractorModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='abstractorModelType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.views is not None:
            namespaceprefix_ = self.views_nsprefix_ + ':' if (UseCapturedNS_ and self.views_nsprefix_) else ''
            self.views.export(outfile, level, namespaceprefix_, namespacedef_='', name_='views', pretty_print=pretty_print)
        if self.instantiations is not None:
            namespaceprefix_ = self.instantiations_nsprefix_ + ':' if (UseCapturedNS_ and self.instantiations_nsprefix_) else ''
            self.instantiations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='instantiations', pretty_print=pretty_print)
        if self.ports is not None:
            namespaceprefix_ = self.ports_nsprefix_ + ':' if (UseCapturedNS_ and self.ports_nsprefix_) else ''
            self.ports.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ports', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'views':
            obj_ = viewsType72.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.views = obj_
            obj_.original_tagname_ = 'views'
        elif nodeName_ == 'instantiations':
            obj_ = instantiationsType75.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.instantiations = obj_
            obj_.original_tagname_ = 'instantiations'
        elif nodeName_ == 'ports':
            obj_ = portsType76.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ports = obj_
            obj_.original_tagname_ = 'ports'
# end class abstractorModelType


class whiteboxElementRefType(GeneratedsSuper):
    """location -- The contents of each location element can be used to specified one location (HDL Path) through the referenced whiteBoxElement is accessible.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'use': 'required', 'name': 'name'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('location', 'slicesType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'location', 'type': 'slicesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, isPresent=None, location=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
        if location is None:
            self.location = []
        else:
            self.location = location
        self.location_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, whiteboxElementRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if whiteboxElementRefType.subclass:
            return whiteboxElementRefType.subclass(*args_, **kwargs_)
        else:
            return whiteboxElementRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def add_location(self, value):
        self.location.append(value)
    def insert_location_at(self, index, value):
        self.location.insert(index, value)
    def replace_location_at(self, index, value):
        self.location[index] = value
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.isPresent is not None or
            self.location
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='whiteboxElementRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('whiteboxElementRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'whiteboxElementRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='whiteboxElementRefType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='whiteboxElementRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='whiteboxElementRefType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='whiteboxElementRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for location_ in self.location:
            namespaceprefix_ = self.location_nsprefix_ + ':' if (UseCapturedNS_ and self.location_nsprefix_) else ''
            location_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='location', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'location':
            obj_ = slicesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.location.append(obj_)
            obj_.original_tagname_ = 'location'
# end class whiteboxElementRefType


class languageType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('strict', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'strict'}),
        MemberSpec_('valueOf_', 'xs:token', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, strict=False, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.strict = _cast(bool, strict)
        self.strict_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, languageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if languageType.subclass:
            return languageType.subclass(*args_, **kwargs_)
        else:
            return languageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_strict(self):
        return self.strict
    def set_strict(self, strict):
        self.strict = strict
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='languageType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('languageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'languageType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='languageType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='languageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='languageType'):
        if self.strict and 'strict' not in already_processed:
            already_processed.add('strict')
            outfile.write(' strict="%s"' % self.gds_format_boolean(self.strict, input_name='strict'))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='languageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('strict', node)
        if value is not None and 'strict' not in already_processed:
            already_processed.add('strict')
            if value in ('true', '1'):
                self.strict = True
            elif value in ('false', '0'):
                self.strict = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class languageType


class design(GeneratedsSuper):
    """vendor -- Name of the vendor who supplies this file.
    library -- Name of the logical library this element belongs to.
    name -- The name of the object.
    version -- Indicates the version of the named element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'name': 'vendor', 'type': 'xs:Name'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'name': 'library', 'type': 'xs:Name'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'name': 'version', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('componentInstances', 'componentInstances', 0, 1, {'minOccurs': '0', 'name': 'componentInstances', 'ref': 'componentInstances', 'type': 'componentInstances'}, None),
        MemberSpec_('interconnections', 'interconnections', 0, 1, {'minOccurs': '0', 'name': 'interconnections', 'ref': 'interconnections', 'type': 'interconnections'}, None),
        MemberSpec_('adHocConnections', 'adHocConnections', 0, 1, {'minOccurs': '0', 'name': 'adHocConnections', 'ref': 'adHocConnections', 'type': 'adHocConnections'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'name': 'assertions', 'ref': 'assertions', 'type': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, componentInstances=None, interconnections=None, adHocConnections=None, description=None, parameters=None, assertions=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.vendor = vendor
        self.vendor_nsprefix_ = "ipxact"
        self.library = library
        self.library_nsprefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.version = version
        self.version_nsprefix_ = "ipxact"
        self.componentInstances = componentInstances
        self.componentInstances_nsprefix_ = "ipxact"
        self.interconnections = interconnections
        self.interconnections_nsprefix_ = "ipxact"
        self.adHocConnections = adHocConnections
        self.adHocConnections_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.assertions = assertions
        self.assertions_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, design)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if design.subclass:
            return design.subclass(*args_, **kwargs_)
        else:
            return design(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_componentInstances(self):
        return self.componentInstances
    def set_componentInstances(self, componentInstances):
        self.componentInstances = componentInstances
    def get_interconnections(self):
        return self.interconnections
    def set_interconnections(self, interconnections):
        self.interconnections = interconnections
    def get_adHocConnections(self):
        return self.adHocConnections
    def set_adHocConnections(self, adHocConnections):
        self.adHocConnections = adHocConnections
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_assertions(self):
        return self.assertions
    def set_assertions(self, assertions):
        self.assertions = assertions
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.componentInstances is not None or
            self.interconnections is not None or
            self.adHocConnections is not None or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='design', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('design')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'design':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='design')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='design', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='design'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='design', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            namespaceprefix_ = self.vendor_nsprefix_ + ':' if (UseCapturedNS_ and self.vendor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), namespaceprefix_ , eol_))
        if self.library is not None:
            namespaceprefix_ = self.library_nsprefix_ + ':' if (UseCapturedNS_ and self.library_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slibrary>%s</%slibrary>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespaceprefix_ , eol_))
        if self.componentInstances is not None:
            namespaceprefix_ = self.componentInstances_nsprefix_ + ':' if (UseCapturedNS_ and self.componentInstances_nsprefix_) else ''
            self.componentInstances.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='componentInstances', pretty_print=pretty_print)
        if self.interconnections is not None:
            namespaceprefix_ = self.interconnections_nsprefix_ + ':' if (UseCapturedNS_ and self.interconnections_nsprefix_) else ''
            self.interconnections.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='interconnections', pretty_print=pretty_print)
        if self.adHocConnections is not None:
            namespaceprefix_ = self.adHocConnections_nsprefix_ + ':' if (UseCapturedNS_ and self.adHocConnections_nsprefix_) else ''
            self.adHocConnections.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='adHocConnections', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            namespaceprefix_ = self.assertions_nsprefix_ + ':' if (UseCapturedNS_ and self.assertions_nsprefix_) else ''
            self.assertions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vendor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vendor')
            value_ = self.gds_validate_string(value_, node, 'vendor')
            self.vendor = value_
            self.vendor_nsprefix_ = child_.prefix
        elif nodeName_ == 'library':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'library')
            value_ = self.gds_validate_string(value_, node, 'library')
            self.library = value_
            self.library_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'version')
            value_ = self.gds_validate_string(value_, node, 'version')
            self.version = value_
            self.version_nsprefix_ = child_.prefix
        elif nodeName_ == 'componentInstances':
            obj_ = componentInstances.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.componentInstances = obj_
            obj_.original_tagname_ = 'componentInstances'
        elif nodeName_ == 'interconnections':
            obj_ = interconnections.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interconnections = obj_
            obj_.original_tagname_ = 'interconnections'
        elif nodeName_ == 'adHocConnections':
            obj_ = adHocConnections.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.adHocConnections = obj_
            obj_.original_tagname_ = 'adHocConnections'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class design


class designConfiguration(GeneratedsSuper):
    """vendor -- Name of the vendor who supplies this file.
    library -- Name of the logical library this element belongs to.
    name -- The name of the object.
    version -- Indicates the version of the named element.
    designRef -- The design to which this configuration applies
    generatorChainConfiguration -- Contains the configurable information associated with a generatorChain and its generators. Note that configurable information for generators associated with components is stored in the design file.
    interconnectionConfiguration -- Contains the information about the abstractors required to cross between two interfaces at with different abstractionDefs.
    viewConfiguration -- Contains the active views for each instance in the design
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'name': 'vendor', 'type': 'xs:Name'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'name': 'library', 'type': 'xs:Name'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'name': 'version', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('designRef', 'libraryRefType', 0, 1, {'minOccurs': '0', 'name': 'designRef', 'type': 'libraryRefType'}, None),
        MemberSpec_('generatorChainConfiguration', 'configurableLibraryRefType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'generatorChainConfiguration', 'type': 'configurableLibraryRefType'}, None),
        MemberSpec_('interconnectionConfiguration', 'interconnectionConfigurationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'interconnectionConfiguration', 'type': 'interconnectionConfigurationType'}, None),
        MemberSpec_('viewConfiguration', 'viewConfigurationType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'viewConfiguration', 'type': 'viewConfigurationType'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'name': 'assertions', 'ref': 'assertions', 'type': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, designRef=None, generatorChainConfiguration=None, interconnectionConfiguration=None, viewConfiguration=None, description=None, parameters=None, assertions=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.vendor = vendor
        self.vendor_nsprefix_ = "ipxact"
        self.library = library
        self.library_nsprefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.version = version
        self.version_nsprefix_ = "ipxact"
        self.designRef = designRef
        self.designRef_nsprefix_ = "ipxact"
        if generatorChainConfiguration is None:
            self.generatorChainConfiguration = []
        else:
            self.generatorChainConfiguration = generatorChainConfiguration
        self.generatorChainConfiguration_nsprefix_ = "ipxact"
        if interconnectionConfiguration is None:
            self.interconnectionConfiguration = []
        else:
            self.interconnectionConfiguration = interconnectionConfiguration
        self.interconnectionConfiguration_nsprefix_ = "ipxact"
        if viewConfiguration is None:
            self.viewConfiguration = []
        else:
            self.viewConfiguration = viewConfiguration
        self.viewConfiguration_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.assertions = assertions
        self.assertions_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, designConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if designConfiguration.subclass:
            return designConfiguration.subclass(*args_, **kwargs_)
        else:
            return designConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_designRef(self):
        return self.designRef
    def set_designRef(self, designRef):
        self.designRef = designRef
    def get_generatorChainConfiguration(self):
        return self.generatorChainConfiguration
    def set_generatorChainConfiguration(self, generatorChainConfiguration):
        self.generatorChainConfiguration = generatorChainConfiguration
    def add_generatorChainConfiguration(self, value):
        self.generatorChainConfiguration.append(value)
    def insert_generatorChainConfiguration_at(self, index, value):
        self.generatorChainConfiguration.insert(index, value)
    def replace_generatorChainConfiguration_at(self, index, value):
        self.generatorChainConfiguration[index] = value
    def get_interconnectionConfiguration(self):
        return self.interconnectionConfiguration
    def set_interconnectionConfiguration(self, interconnectionConfiguration):
        self.interconnectionConfiguration = interconnectionConfiguration
    def add_interconnectionConfiguration(self, value):
        self.interconnectionConfiguration.append(value)
    def insert_interconnectionConfiguration_at(self, index, value):
        self.interconnectionConfiguration.insert(index, value)
    def replace_interconnectionConfiguration_at(self, index, value):
        self.interconnectionConfiguration[index] = value
    def get_viewConfiguration(self):
        return self.viewConfiguration
    def set_viewConfiguration(self, viewConfiguration):
        self.viewConfiguration = viewConfiguration
    def add_viewConfiguration(self, value):
        self.viewConfiguration.append(value)
    def insert_viewConfiguration_at(self, index, value):
        self.viewConfiguration.insert(index, value)
    def replace_viewConfiguration_at(self, index, value):
        self.viewConfiguration[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_assertions(self):
        return self.assertions
    def set_assertions(self, assertions):
        self.assertions = assertions
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.designRef is not None or
            self.generatorChainConfiguration or
            self.interconnectionConfiguration or
            self.viewConfiguration or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='designConfiguration', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('designConfiguration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'designConfiguration':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='designConfiguration')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='designConfiguration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='designConfiguration'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='designConfiguration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            namespaceprefix_ = self.vendor_nsprefix_ + ':' if (UseCapturedNS_ and self.vendor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), namespaceprefix_ , eol_))
        if self.library is not None:
            namespaceprefix_ = self.library_nsprefix_ + ':' if (UseCapturedNS_ and self.library_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slibrary>%s</%slibrary>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespaceprefix_ , eol_))
        if self.designRef is not None:
            namespaceprefix_ = self.designRef_nsprefix_ + ':' if (UseCapturedNS_ and self.designRef_nsprefix_) else ''
            self.designRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='designRef', pretty_print=pretty_print)
        for generatorChainConfiguration_ in self.generatorChainConfiguration:
            namespaceprefix_ = self.generatorChainConfiguration_nsprefix_ + ':' if (UseCapturedNS_ and self.generatorChainConfiguration_nsprefix_) else ''
            generatorChainConfiguration_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generatorChainConfiguration', pretty_print=pretty_print)
        for interconnectionConfiguration_ in self.interconnectionConfiguration:
            namespaceprefix_ = self.interconnectionConfiguration_nsprefix_ + ':' if (UseCapturedNS_ and self.interconnectionConfiguration_nsprefix_) else ''
            interconnectionConfiguration_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interconnectionConfiguration', pretty_print=pretty_print)
        for viewConfiguration_ in self.viewConfiguration:
            namespaceprefix_ = self.viewConfiguration_nsprefix_ + ':' if (UseCapturedNS_ and self.viewConfiguration_nsprefix_) else ''
            viewConfiguration_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='viewConfiguration', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            namespaceprefix_ = self.assertions_nsprefix_ + ':' if (UseCapturedNS_ and self.assertions_nsprefix_) else ''
            self.assertions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vendor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vendor')
            value_ = self.gds_validate_string(value_, node, 'vendor')
            self.vendor = value_
            self.vendor_nsprefix_ = child_.prefix
        elif nodeName_ == 'library':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'library')
            value_ = self.gds_validate_string(value_, node, 'library')
            self.library = value_
            self.library_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'version')
            value_ = self.gds_validate_string(value_, node, 'version')
            self.version = value_
            self.version_nsprefix_ = child_.prefix
        elif nodeName_ == 'designRef':
            obj_ = LibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.designRef = obj_
            obj_.original_tagname_ = 'designRef'
        elif nodeName_ == 'generatorChainConfiguration':
            obj_ = ConfigurableLibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generatorChainConfiguration.append(obj_)
            obj_.original_tagname_ = 'generatorChainConfiguration'
        elif nodeName_ == 'interconnectionConfiguration':
            obj_ = interconnectionConfigurationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interconnectionConfiguration.append(obj_)
            obj_.original_tagname_ = 'interconnectionConfiguration'
        elif nodeName_ == 'viewConfiguration':
            obj_ = viewConfigurationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.viewConfiguration.append(obj_)
            obj_.original_tagname_ = 'viewConfiguration'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class designConfiguration


class ipxactFilesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('ipxactFile', 'ipxactFileType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'ipxactFile', 'type': 'ipxactFileType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ipxactFile=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        if ipxactFile is None:
            self.ipxactFile = []
        else:
            self.ipxactFile = ipxactFile
        self.ipxactFile_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ipxactFilesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ipxactFilesType.subclass:
            return ipxactFilesType.subclass(*args_, **kwargs_)
        else:
            return ipxactFilesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ipxactFile(self):
        return self.ipxactFile
    def set_ipxactFile(self, ipxactFile):
        self.ipxactFile = ipxactFile
    def add_ipxactFile(self, value):
        self.ipxactFile.append(value)
    def insert_ipxactFile_at(self, index, value):
        self.ipxactFile.insert(index, value)
    def replace_ipxactFile_at(self, index, value):
        self.ipxactFile[index] = value
    def _hasContent(self):
        if (
            self.ipxactFile
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='ipxactFilesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ipxactFilesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ipxactFilesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ipxactFilesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ipxactFilesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='ipxactFilesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='ipxactFilesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ipxactFile_ in self.ipxactFile:
            namespaceprefix_ = self.ipxactFile_nsprefix_ + ':' if (UseCapturedNS_ and self.ipxactFile_nsprefix_) else ''
            ipxactFile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ipxactFile', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ipxactFile':
            obj_ = ipxactFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ipxactFile.append(obj_)
            obj_.original_tagname_ = 'ipxactFile'
# end class ipxactFilesType


class catalog(GeneratedsSuper):
    """vendor -- Name of the vendor who supplies this file.
    library -- Name of the logical library this element belongs to.
    name -- The name of the object.
    version -- Indicates the version of the named element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'name': 'vendor', 'type': 'xs:Name'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'name': 'library', 'type': 'xs:Name'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'name': 'version', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('catalogs', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'name': 'catalogs', 'type': 'ipxactFilesType'}, None),
        MemberSpec_('busDefinitions', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'name': 'busDefinitions', 'type': 'ipxactFilesType'}, None),
        MemberSpec_('abstractionDefinitions', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'name': 'abstractionDefinitions', 'type': 'ipxactFilesType'}, None),
        MemberSpec_('components', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'name': 'components', 'type': 'ipxactFilesType'}, None),
        MemberSpec_('abstractors', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'name': 'abstractors', 'type': 'ipxactFilesType'}, None),
        MemberSpec_('designs', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'name': 'designs', 'type': 'ipxactFilesType'}, None),
        MemberSpec_('designConfigurations', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'name': 'designConfigurations', 'type': 'ipxactFilesType'}, None),
        MemberSpec_('generatorChains', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'name': 'generatorChains', 'type': 'ipxactFilesType'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, vendor=None, library=None, name=None, version=None, description=None, catalogs=None, busDefinitions=None, abstractionDefinitions=None, components=None, abstractors=None, designs=None, designConfigurations=None, generatorChains=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.vendor = vendor
        self.vendor_nsprefix_ = "ipxact"
        self.library = library
        self.library_nsprefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.version = version
        self.version_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.catalogs = catalogs
        self.catalogs_nsprefix_ = "ipxact"
        self.busDefinitions = busDefinitions
        self.busDefinitions_nsprefix_ = "ipxact"
        self.abstractionDefinitions = abstractionDefinitions
        self.abstractionDefinitions_nsprefix_ = "ipxact"
        self.components = components
        self.components_nsprefix_ = "ipxact"
        self.abstractors = abstractors
        self.abstractors_nsprefix_ = "ipxact"
        self.designs = designs
        self.designs_nsprefix_ = "ipxact"
        self.designConfigurations = designConfigurations
        self.designConfigurations_nsprefix_ = "ipxact"
        self.generatorChains = generatorChains
        self.generatorChains_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, catalog)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if catalog.subclass:
            return catalog.subclass(*args_, **kwargs_)
        else:
            return catalog(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_catalogs(self):
        return self.catalogs
    def set_catalogs(self, catalogs):
        self.catalogs = catalogs
    def get_busDefinitions(self):
        return self.busDefinitions
    def set_busDefinitions(self, busDefinitions):
        self.busDefinitions = busDefinitions
    def get_abstractionDefinitions(self):
        return self.abstractionDefinitions
    def set_abstractionDefinitions(self, abstractionDefinitions):
        self.abstractionDefinitions = abstractionDefinitions
    def get_components(self):
        return self.components
    def set_components(self, components):
        self.components = components
    def get_abstractors(self):
        return self.abstractors
    def set_abstractors(self, abstractors):
        self.abstractors = abstractors
    def get_designs(self):
        return self.designs
    def set_designs(self, designs):
        self.designs = designs
    def get_designConfigurations(self):
        return self.designConfigurations
    def set_designConfigurations(self, designConfigurations):
        self.designConfigurations = designConfigurations
    def get_generatorChains(self):
        return self.generatorChains
    def set_generatorChains(self, generatorChains):
        self.generatorChains = generatorChains
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def _hasContent(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.description is not None or
            self.catalogs is not None or
            self.busDefinitions is not None or
            self.abstractionDefinitions is not None or
            self.components is not None or
            self.abstractors is not None or
            self.designs is not None or
            self.designConfigurations is not None or
            self.generatorChains is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='catalog', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('catalog')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'catalog':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='catalog')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='catalog', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='catalog'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='catalog', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            namespaceprefix_ = self.vendor_nsprefix_ + ':' if (UseCapturedNS_ and self.vendor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), namespaceprefix_ , eol_))
        if self.library is not None:
            namespaceprefix_ = self.library_nsprefix_ + ':' if (UseCapturedNS_ and self.library_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slibrary>%s</%slibrary>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.catalogs is not None:
            namespaceprefix_ = self.catalogs_nsprefix_ + ':' if (UseCapturedNS_ and self.catalogs_nsprefix_) else ''
            self.catalogs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='catalogs', pretty_print=pretty_print)
        if self.busDefinitions is not None:
            namespaceprefix_ = self.busDefinitions_nsprefix_ + ':' if (UseCapturedNS_ and self.busDefinitions_nsprefix_) else ''
            self.busDefinitions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='busDefinitions', pretty_print=pretty_print)
        if self.abstractionDefinitions is not None:
            namespaceprefix_ = self.abstractionDefinitions_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractionDefinitions_nsprefix_) else ''
            self.abstractionDefinitions.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstractionDefinitions', pretty_print=pretty_print)
        if self.components is not None:
            namespaceprefix_ = self.components_nsprefix_ + ':' if (UseCapturedNS_ and self.components_nsprefix_) else ''
            self.components.export(outfile, level, namespaceprefix_, namespacedef_='', name_='components', pretty_print=pretty_print)
        if self.abstractors is not None:
            namespaceprefix_ = self.abstractors_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractors_nsprefix_) else ''
            self.abstractors.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstractors', pretty_print=pretty_print)
        if self.designs is not None:
            namespaceprefix_ = self.designs_nsprefix_ + ':' if (UseCapturedNS_ and self.designs_nsprefix_) else ''
            self.designs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='designs', pretty_print=pretty_print)
        if self.designConfigurations is not None:
            namespaceprefix_ = self.designConfigurations_nsprefix_ + ':' if (UseCapturedNS_ and self.designConfigurations_nsprefix_) else ''
            self.designConfigurations.export(outfile, level, namespaceprefix_, namespacedef_='', name_='designConfigurations', pretty_print=pretty_print)
        if self.generatorChains is not None:
            namespaceprefix_ = self.generatorChains_nsprefix_ + ':' if (UseCapturedNS_ and self.generatorChains_nsprefix_) else ''
            self.generatorChains.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generatorChains', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vendor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vendor')
            value_ = self.gds_validate_string(value_, node, 'vendor')
            self.vendor = value_
            self.vendor_nsprefix_ = child_.prefix
        elif nodeName_ == 'library':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'library')
            value_ = self.gds_validate_string(value_, node, 'library')
            self.library = value_
            self.library_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'version')
            value_ = self.gds_validate_string(value_, node, 'version')
            self.version = value_
            self.version_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'catalogs':
            obj_ = ipxactFilesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.catalogs = obj_
            obj_.original_tagname_ = 'catalogs'
        elif nodeName_ == 'busDefinitions':
            obj_ = ipxactFilesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.busDefinitions = obj_
            obj_.original_tagname_ = 'busDefinitions'
        elif nodeName_ == 'abstractionDefinitions':
            obj_ = ipxactFilesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractionDefinitions = obj_
            obj_.original_tagname_ = 'abstractionDefinitions'
        elif nodeName_ == 'components':
            obj_ = ipxactFilesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.components = obj_
            obj_.original_tagname_ = 'components'
        elif nodeName_ == 'abstractors':
            obj_ = ipxactFilesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractors = obj_
            obj_.original_tagname_ = 'abstractors'
        elif nodeName_ == 'designs':
            obj_ = ipxactFilesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.designs = obj_
            obj_.original_tagname_ = 'designs'
        elif nodeName_ == 'designConfigurations':
            obj_ = ipxactFilesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.designConfigurations = obj_
            obj_.original_tagname_ = 'designConfigurations'
        elif nodeName_ == 'generatorChains':
            obj_ = ipxactFilesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generatorChains = obj_
            obj_.original_tagname_ = 'generatorChains'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class catalog


class ipxactFileType(GeneratedsSuper):
    """vlnv -- VLNV of the IP-XACT file being cataloged.
    name -- Name of the IP-XACT file being cataloged.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('vlnv', 'libraryRefType', 0, 0, {'name': 'vlnv', 'type': 'libraryRefType'}, None),
        MemberSpec_('name', 'stringURIExpression', 0, 0, {'name': 'name', 'type': 'stringURIExpression'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, vlnv=None, name=None, description=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.vlnv = vlnv
        self.vlnv_nsprefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ipxactFileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ipxactFileType.subclass:
            return ipxactFileType.subclass(*args_, **kwargs_)
        else:
            return ipxactFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vlnv(self):
        return self.vlnv
    def set_vlnv(self, vlnv):
        self.vlnv = vlnv
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def _hasContent(self):
        if (
            self.vlnv is not None or
            self.name is not None or
            self.description is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='ipxactFileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ipxactFileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ipxactFileType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ipxactFileType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ipxactFileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='ipxactFileType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='ipxactFileType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vlnv is not None:
            namespaceprefix_ = self.vlnv_nsprefix_ + ':' if (UseCapturedNS_ and self.vlnv_nsprefix_) else ''
            self.vlnv.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vlnv', pretty_print=pretty_print)
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            self.name.export(outfile, level, namespaceprefix_, namespacedef_='', name_='name', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vlnv':
            obj_ = LibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vlnv = obj_
            obj_.original_tagname_ = 'vlnv'
        elif nodeName_ == 'name':
            obj_ = stringURIExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class ipxactFileType


class abstractorType(GeneratedsSuper):
    """vendor -- Name of the vendor who supplies this file.
    library -- Name of the logical library this element belongs to.
    name -- The name of the object.
    version -- Indicates the version of the named element.
    abstractorMode -- Define the mode for the interfaces on this abstractor.
    For master the first interface connects to the master, the second connects to the mirroredMaster
    For slave the first interface connects to the mirroredSlave the second connects to the slave
    For direct the first interface connects to the master, the second connects to the slave
    For system the first interface connects to the system, the second connects to the mirroredSystem. For system the group attribute is required
    busType -- The bus type of both interfaces. Refers to bus definition using vendor, library, name, version attributes.
    abstractorInterfaces -- The interfaces supported by this abstractor
    model -- Model information.
    abstractorGenerators -- Generator list is tools-specific.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'name': 'vendor', 'type': 'xs:Name'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'name': 'library', 'type': 'xs:Name'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'name': 'version', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('abstractorMode', 'abstractorModeType78', 0, 0, {'name': 'abstractorMode', 'type': 'abstractorModeType78'}, None),
        MemberSpec_('busType', 'libraryRefType', 0, 0, {'name': 'busType', 'type': 'libraryRefType'}, None),
        MemberSpec_('abstractorInterfaces', 'abstractorInterfacesType', 0, 0, {'name': 'abstractorInterfaces', 'type': 'abstractorInterfacesType'}, None),
        MemberSpec_('model', 'modelType', 0, 1, {'minOccurs': '0', 'name': 'model', 'type': 'abstractorModelType'}, None),
        MemberSpec_('abstractorGenerators', 'abstractorGenerators', 0, 1, {'minOccurs': '0', 'name': 'abstractorGenerators', 'ref': 'abstractorGenerators', 'type': 'abstractorGenerators'}, None),
        MemberSpec_('choices', 'choices', 0, 1, {'minOccurs': '0', 'name': 'choices', 'ref': 'choices', 'type': 'choices'}, None),
        MemberSpec_('fileSets', 'fileSets', 0, 1, {'minOccurs': '0', 'name': 'fileSets', 'ref': 'fileSets', 'type': 'fileSets'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'name': 'assertions', 'ref': 'assertions', 'type': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, abstractorMode=None, busType=None, abstractorInterfaces=None, model=None, abstractorGenerators=None, choices=None, fileSets=None, description=None, parameters=None, assertions=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.vendor = vendor
        self.vendor_nsprefix_ = "ipxact"
        self.library = library
        self.library_nsprefix_ = "ipxact"
        self.name = name
        self.name_nsprefix_ = "ipxact"
        self.version = version
        self.version_nsprefix_ = "ipxact"
        self.abstractorMode = abstractorMode
        self.abstractorMode_nsprefix_ = "ipxact"
        self.busType = busType
        self.busType_nsprefix_ = "ipxact"
        self.abstractorInterfaces = abstractorInterfaces
        self.abstractorInterfaces_nsprefix_ = "ipxact"
        self.model = model
        self.model_nsprefix_ = "ipxact"
        self.abstractorGenerators = abstractorGenerators
        self.abstractorGenerators_nsprefix_ = "ipxact"
        self.choices = choices
        self.choices_nsprefix_ = "ipxact"
        self.fileSets = fileSets
        self.fileSets_nsprefix_ = "ipxact"
        self.description = description
        self.description_nsprefix_ = "ipxact"
        self.parameters = parameters
        self.parameters_nsprefix_ = "ipxact"
        self.assertions = assertions
        self.assertions_nsprefix_ = "ipxact"
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorType.subclass:
            return abstractorType.subclass(*args_, **kwargs_)
        else:
            return abstractorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_vendor(self):
        return self.vendor
    def set_vendor(self, vendor):
        self.vendor = vendor
    def get_library(self):
        return self.library
    def set_library(self, library):
        self.library = library
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_abstractorMode(self):
        return self.abstractorMode
    def set_abstractorMode(self, abstractorMode):
        self.abstractorMode = abstractorMode
    def get_busType(self):
        return self.busType
    def set_busType(self, busType):
        self.busType = busType
    def get_abstractorInterfaces(self):
        return self.abstractorInterfaces
    def set_abstractorInterfaces(self, abstractorInterfaces):
        self.abstractorInterfaces = abstractorInterfaces
    def get_model(self):
        return self.model
    def set_model(self, model):
        self.model = model
    def get_abstractorGenerators(self):
        return self.abstractorGenerators
    def set_abstractorGenerators(self, abstractorGenerators):
        self.abstractorGenerators = abstractorGenerators
    def get_choices(self):
        return self.choices
    def set_choices(self, choices):
        self.choices = choices
    def get_fileSets(self):
        return self.fileSets
    def set_fileSets(self, fileSets):
        self.fileSets = fileSets
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_assertions(self):
        return self.assertions
    def set_assertions(self, assertions):
        self.assertions = assertions
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.abstractorMode is not None or
            self.busType is not None or
            self.abstractorInterfaces is not None or
            self.model is not None or
            self.abstractorGenerators is not None or
            self.choices is not None or
            self.fileSets is not None or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='abstractorType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            namespaceprefix_ = self.vendor_nsprefix_ + ':' if (UseCapturedNS_ and self.vendor_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svendor>%s</%svendor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), namespaceprefix_ , eol_))
        if self.library is not None:
            namespaceprefix_ = self.library_nsprefix_ + ':' if (UseCapturedNS_ and self.library_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slibrary>%s</%slibrary>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), namespaceprefix_ , eol_))
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), namespaceprefix_ , eol_))
        if self.abstractorMode is not None:
            namespaceprefix_ = self.abstractorMode_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractorMode_nsprefix_) else ''
            self.abstractorMode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstractorMode', pretty_print=pretty_print)
        if self.busType is not None:
            namespaceprefix_ = self.busType_nsprefix_ + ':' if (UseCapturedNS_ and self.busType_nsprefix_) else ''
            self.busType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='busType', pretty_print=pretty_print)
        if self.abstractorInterfaces is not None:
            namespaceprefix_ = self.abstractorInterfaces_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractorInterfaces_nsprefix_) else ''
            self.abstractorInterfaces.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstractorInterfaces', pretty_print=pretty_print)
        if self.model is not None:
            namespaceprefix_ = self.model_nsprefix_ + ':' if (UseCapturedNS_ and self.model_nsprefix_) else ''
            self.model.export(outfile, level, namespaceprefix_, namespacedef_='', name_='model', pretty_print=pretty_print)
        if self.abstractorGenerators is not None:
            namespaceprefix_ = self.abstractorGenerators_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractorGenerators_nsprefix_) else ''
            self.abstractorGenerators.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='abstractorGenerators', pretty_print=pretty_print)
        if self.choices is not None:
            namespaceprefix_ = self.choices_nsprefix_ + ':' if (UseCapturedNS_ and self.choices_nsprefix_) else ''
            self.choices.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='choices', pretty_print=pretty_print)
        if self.fileSets is not None:
            namespaceprefix_ = self.fileSets_nsprefix_ + ':' if (UseCapturedNS_ and self.fileSets_nsprefix_) else ''
            self.fileSets.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='fileSets', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            namespaceprefix_ = self.assertions_nsprefix_ + ':' if (UseCapturedNS_ and self.assertions_nsprefix_) else ''
            self.assertions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'vendor':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'vendor')
            value_ = self.gds_validate_string(value_, node, 'vendor')
            self.vendor = value_
            self.vendor_nsprefix_ = child_.prefix
        elif nodeName_ == 'library':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'library')
            value_ = self.gds_validate_string(value_, node, 'library')
            self.library = value_
            self.library_nsprefix_ = child_.prefix
        elif nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'version':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'version')
            value_ = self.gds_validate_string(value_, node, 'version')
            self.version = value_
            self.version_nsprefix_ = child_.prefix
        elif nodeName_ == 'abstractorMode':
            obj_ = abstractorModeType78.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractorMode = obj_
            obj_.original_tagname_ = 'abstractorMode'
        elif nodeName_ == 'busType':
            obj_ = LibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.busType = obj_
            obj_.original_tagname_ = 'busType'
        elif nodeName_ == 'abstractorInterfaces':
            obj_ = abstractorInterfacesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractorInterfaces = obj_
            obj_.original_tagname_ = 'abstractorInterfaces'
        elif nodeName_ == 'model':
            obj_ = abstractorModelType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.model = obj_
            obj_.original_tagname_ = 'model'
        elif nodeName_ == 'abstractorGenerators':
            obj_ = abstractorGenerators.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractorGenerators = obj_
            obj_.original_tagname_ = 'abstractorGenerators'
        elif nodeName_ == 'choices':
            obj_ = choices.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.choices = obj_
            obj_.original_tagname_ = 'choices'
        elif nodeName_ == 'fileSets':
            obj_ = fileSets.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileSets = obj_
            obj_.original_tagname_ = 'fileSets'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class abstractorType


class initiativeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', ['initiativeType_impl', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, initiativeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if initiativeType.subclass:
            return initiativeType.subclass(*args_, **kwargs_)
        else:
            return initiativeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_initiativeType_impl(self, value):
        result = True
        # Validate type initiativeType_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['requires', 'provides', 'both', 'phantom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on initiativeType_impl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='initiativeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('initiativeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'initiativeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='initiativeType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='initiativeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='initiativeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='initiativeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class initiativeType


class simplePortAccessType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', ['simplePortAccessType_impl', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, simplePortAccessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if simplePortAccessType.subclass:
            return simplePortAccessType.subclass(*args_, **kwargs_)
        else:
            return simplePortAccessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_simplePortAccessType_impl(self, value):
        result = True
        # Validate type simplePortAccessType_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ref', 'ptr']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on simplePortAccessType_impl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='simplePortAccessType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('simplePortAccessType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'simplePortAccessType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='simplePortAccessType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='simplePortAccessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='simplePortAccessType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='simplePortAccessType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class simplePortAccessType


class presenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', ['presenceType_impl', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, presenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if presenceType.subclass:
            return presenceType.subclass(*args_, **kwargs_)
        else:
            return presenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_presenceType_impl(self, value):
        result = True
        # Validate type presenceType_impl, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['required', 'illegal', 'optional']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on presenceType_impl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='presenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('presenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'presenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='presenceType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='presenceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='presenceType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='presenceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class presenceType


class accessType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', ['accessType_impl', 'xs:token'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessType.subclass:
            return accessType.subclass(*args_, **kwargs_)
        else:
            return accessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_accessType_impl(self, value):
        result = True
        # Validate type accessType_impl, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on accessType_impl' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class accessType


class systemGroupNamesType(GeneratedsSuper):
    """systemGroupName -- Indicates the name of a system group defined for this bus definition.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('systemGroupName', 'systemGroupNameType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'systemGroupName', 'type': 'systemGroupNameType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, systemGroupName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if systemGroupName is None:
            self.systemGroupName = []
        else:
            self.systemGroupName = systemGroupName
        self.systemGroupName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, systemGroupNamesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if systemGroupNamesType.subclass:
            return systemGroupNamesType.subclass(*args_, **kwargs_)
        else:
            return systemGroupNamesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_systemGroupName(self):
        return self.systemGroupName
    def set_systemGroupName(self, systemGroupName):
        self.systemGroupName = systemGroupName
    def add_systemGroupName(self, value):
        self.systemGroupName.append(value)
    def insert_systemGroupName_at(self, index, value):
        self.systemGroupName.insert(index, value)
    def replace_systemGroupName_at(self, index, value):
        self.systemGroupName[index] = value
    def _hasContent(self):
        if (
            self.systemGroupName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='systemGroupNamesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('systemGroupNamesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'systemGroupNamesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='systemGroupNamesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='systemGroupNamesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='systemGroupNamesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='systemGroupNamesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for systemGroupName_ in self.systemGroupName:
            namespaceprefix_ = self.systemGroupName_nsprefix_ + ':' if (UseCapturedNS_ and self.systemGroupName_nsprefix_) else ''
            systemGroupName_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='systemGroupName', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'systemGroupName':
            obj_ = systemGroupNameType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.systemGroupName.append(obj_)
            obj_.original_tagname_ = 'systemGroupName'
# end class systemGroupNamesType


class systemGroupNameType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, systemGroupNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if systemGroupNameType.subclass:
            return systemGroupNameType.subclass(*args_, **kwargs_)
        else:
            return systemGroupNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='systemGroupNameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('systemGroupNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'systemGroupNameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='systemGroupNameType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='systemGroupNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='systemGroupNameType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='systemGroupNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class systemGroupNameType


class choiceType(GeneratedsSuper):
    """name -- Choice key, available for reference by the ipxact:choiceRef attribute.
    enumeration -- One possible value of ipxact:choice
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('enumeration', 'enumerationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'enumeration', 'type': 'enumerationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, enumeration=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        if enumeration is None:
            self.enumeration = []
        else:
            self.enumeration = enumeration
        self.enumeration_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, choiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if choiceType.subclass:
            return choiceType.subclass(*args_, **kwargs_)
        else:
            return choiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_enumeration(self):
        return self.enumeration
    def set_enumeration(self, enumeration):
        self.enumeration = enumeration
    def add_enumeration(self, value):
        self.enumeration.append(value)
    def insert_enumeration_at(self, index, value):
        self.enumeration.insert(index, value)
    def replace_enumeration_at(self, index, value):
        self.enumeration[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.enumeration
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='choiceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('choiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'choiceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='choiceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='choiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='choiceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='choiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        for enumeration_ in self.enumeration:
            namespaceprefix_ = self.enumeration_nsprefix_ + ':' if (UseCapturedNS_ and self.enumeration_nsprefix_) else ''
            enumeration_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enumeration', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'enumeration':
            obj_ = enumerationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.enumeration.append(obj_)
            obj_.original_tagname_ = 'enumeration'
# end class choiceType


class enumerationType(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('text', 'xs:string', 0, 1, {'use': 'optional', 'name': 'text'}),
        MemberSpec_('help', 'xs:string', 0, 1, {'use': 'optional', 'name': 'help'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, text=None, help=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("enumerationType"), self).__init__(valueOf_,  **kwargs_)
        self.text = _cast(None, text)
        self.text_nsprefix_ = None
        self.help = _cast(None, help)
        self.help_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, enumerationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if enumerationType.subclass:
            return enumerationType.subclass(*args_, **kwargs_)
        else:
            return enumerationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_text(self):
        return self.text
    def set_text(self, text):
        self.text = text
    def get_help(self):
        return self.help
    def set_help(self, help):
        self.help = help
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(enumerationType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='enumerationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('enumerationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'enumerationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='enumerationType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='enumerationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='enumerationType'):
        super(enumerationType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='enumerationType')
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.help is not None and 'help' not in already_processed:
            already_processed.add('help')
            outfile.write(' help=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.help), input_name='help')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='enumerationType', fromsubclass_=False, pretty_print=True):
        super(enumerationType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
        value = find_attr_value_('help', node)
        if value is not None and 'help' not in already_processed:
            already_processed.add('help')
            self.help = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(enumerationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class enumerationType


class portReferencesType(GeneratedsSuper):
    """internalPortReference -- Defines a reference to a port on a component contained within the design.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('internalPortReference', 'internalPortReferenceType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'internalPortReference', 'type': 'internalPortReferenceType'}, 26),
        MemberSpec_('externalPortReference', 'externalPortReference', 1, 0, {'maxOccurs': 'unbounded', 'name': 'externalPortReference', 'ref': 'externalPortReference', 'type': 'externalPortReference'}, 26),
    ]
    subclass = None
    superclass = None
    def __init__(self, internalPortReference=None, externalPortReference=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if internalPortReference is None:
            self.internalPortReference = []
        else:
            self.internalPortReference = internalPortReference
        self.internalPortReference_nsprefix_ = None
        if externalPortReference is None:
            self.externalPortReference = []
        else:
            self.externalPortReference = externalPortReference
        self.externalPortReference_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portReferencesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portReferencesType.subclass:
            return portReferencesType.subclass(*args_, **kwargs_)
        else:
            return portReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_internalPortReference(self):
        return self.internalPortReference
    def set_internalPortReference(self, internalPortReference):
        self.internalPortReference = internalPortReference
    def add_internalPortReference(self, value):
        self.internalPortReference.append(value)
    def insert_internalPortReference_at(self, index, value):
        self.internalPortReference.insert(index, value)
    def replace_internalPortReference_at(self, index, value):
        self.internalPortReference[index] = value
    def get_externalPortReference(self):
        return self.externalPortReference
    def set_externalPortReference(self, externalPortReference):
        self.externalPortReference = externalPortReference
    def add_externalPortReference(self, value):
        self.externalPortReference.append(value)
    def insert_externalPortReference_at(self, index, value):
        self.externalPortReference.insert(index, value)
    def replace_externalPortReference_at(self, index, value):
        self.externalPortReference[index] = value
    def _hasContent(self):
        if (
            self.internalPortReference or
            self.externalPortReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portReferencesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portReferencesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'portReferencesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='portReferencesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='portReferencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='portReferencesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portReferencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for internalPortReference_ in self.internalPortReference:
            namespaceprefix_ = self.internalPortReference_nsprefix_ + ':' if (UseCapturedNS_ and self.internalPortReference_nsprefix_) else ''
            internalPortReference_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='internalPortReference', pretty_print=pretty_print)
        for externalPortReference_ in self.externalPortReference:
            namespaceprefix_ = self.externalPortReference_nsprefix_ + ':' if (UseCapturedNS_ and self.externalPortReference_nsprefix_) else ''
            externalPortReference_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='externalPortReference', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'internalPortReference':
            obj_ = internalPortReferenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.internalPortReference.append(obj_)
            obj_.original_tagname_ = 'internalPortReference'
        elif nodeName_ == 'externalPortReference':
            obj_ = externalPortReference.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.externalPortReference.append(obj_)
            obj_.original_tagname_ = 'externalPortReference'
# end class portReferencesType


class internalPortReferenceType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('componentRef', 'xs:Name', 0, 0, {'use': 'required', 'name': 'componentRef'}),
        MemberSpec_('portRef', 'ipxact:portName', 0, 0, {'use': 'required', 'name': 'portRef'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('PartSelect', 'partSelect', 0, 1, {'minOccurs': '0', 'name': 'partSelect', 'ref': 'partSelect', 'type': 'partSelect'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentRef=None, portRef=None, id=None, isPresent=None, PartSelect=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.componentRef = _cast(None, componentRef)
        self.componentRef_nsprefix_ = None
        self.portRef = _cast(None, portRef)
        self.portRef_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        self.PartSelect = PartSelect
        self.PartSelect_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, internalPortReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if internalPortReferenceType.subclass:
            return internalPortReferenceType.subclass(*args_, **kwargs_)
        else:
            return internalPortReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_partSelect(self):
        return self.PartSelect
    def set_partSelect(self, PartSelect):
        self.PartSelect = PartSelect
    def get_componentRef(self):
        return self.componentRef
    def set_componentRef(self, componentRef):
        self.componentRef = componentRef
    def get_portRef(self):
        return self.portRef
    def set_portRef(self, portRef):
        self.portRef = portRef
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_portName(self, value):
        # Validate type ipxact:portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_portName_patterns_, ))
    validate_portName_patterns_ = [['^([A-Za-z0-9\\.\\-:_]*)$']]
    def _hasContent(self):
        if (
            self.isPresent is not None or
            self.PartSelect is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='internalPortReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('internalPortReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'internalPortReferenceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='internalPortReferenceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='internalPortReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='internalPortReferenceType'):
        if self.componentRef is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            outfile.write(' componentRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.componentRef), input_name='componentRef')), ))
        if self.portRef is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            outfile.write(' portRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.portRef), input_name='portRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='internalPortReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.PartSelect is not None:
            namespaceprefix_ = self.PartSelect_nsprefix_ + ':' if (UseCapturedNS_ and self.PartSelect_nsprefix_) else ''
            self.PartSelect.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='partSelect', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('componentRef', node)
        if value is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            self.componentRef = value
        value = find_attr_value_('portRef', node)
        if value is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            self.portRef = value
            self.validate_portName(self.portRef)    # validate type portName
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'partSelect':
            obj_ = PartSelect.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PartSelect = obj_
            obj_.original_tagname_ = 'partSelect'
# end class internalPortReferenceType


class monitorInterfaceType1(monitorInterfaceType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
    ]
    subclass = None
    superclass = monitorInterfaceType
    def __init__(self, componentRef=None, busRef=None, id=None, path=None, description=None, vendorExtensions=None, isPresent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("monitorInterfaceType1"), self).__init__(componentRef, busRef, id, path, description, vendorExtensions,  **kwargs_)
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monitorInterfaceType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monitorInterfaceType1.subclass:
            return monitorInterfaceType1.subclass(*args_, **kwargs_)
        else:
            return monitorInterfaceType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def _hasContent(self):
        if (
            self.isPresent is not None or
            super(monitorInterfaceType1, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='monitorInterfaceType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monitorInterfaceType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'monitorInterfaceType1':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='monitorInterfaceType1')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='monitorInterfaceType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='monitorInterfaceType1'):
        super(monitorInterfaceType1, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='monitorInterfaceType1')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='monitorInterfaceType1', fromsubclass_=False, pretty_print=True):
        super(monitorInterfaceType1, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(monitorInterfaceType1, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        super(monitorInterfaceType1, self)._buildChildren(child_, node, nodeName_, True)
# end class monitorInterfaceType1


class excludePortsType(GeneratedsSuper):
    """excludePort -- The name of a physical port to be excluded from the interface based connection.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('excludePort', 'excludePortType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'excludePort', 'type': 'excludePortType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, excludePort=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if excludePort is None:
            self.excludePort = []
        else:
            self.excludePort = excludePort
        self.excludePort_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, excludePortsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if excludePortsType.subclass:
            return excludePortsType.subclass(*args_, **kwargs_)
        else:
            return excludePortsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_excludePort(self):
        return self.excludePort
    def set_excludePort(self, excludePort):
        self.excludePort = excludePort
    def add_excludePort(self, value):
        self.excludePort.append(value)
    def insert_excludePort_at(self, index, value):
        self.excludePort.insert(index, value)
    def replace_excludePort_at(self, index, value):
        self.excludePort[index] = value
    def _hasContent(self):
        if (
            self.excludePort
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='excludePortsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('excludePortsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'excludePortsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='excludePortsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='excludePortsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='excludePortsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='excludePortsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for excludePort_ in self.excludePort:
            namespaceprefix_ = self.excludePort_nsprefix_ + ':' if (UseCapturedNS_ and self.excludePort_nsprefix_) else ''
            excludePort_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='excludePort', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'excludePort':
            obj_ = excludePortType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.excludePort.append(obj_)
            obj_.original_tagname_ = 'excludePort'
# end class excludePortsType


class excludePortType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', ['portName', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, excludePortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if excludePortType.subclass:
            return excludePortType.subclass(*args_, **kwargs_)
        else:
            return excludePortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_portName(self, value):
        result = True
        # Validate type portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_portName_patterns_, ))
                result = False
        return result
    validate_portName_patterns_ = [['^([A-Za-z0-9\\.\\-:_]*)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='excludePortType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('excludePortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'excludePortType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='excludePortType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='excludePortType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='excludePortType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='excludePortType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class excludePortType


class viewRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType.subclass:
            return viewRefType.subclass(*args_, **kwargs_)
        else:
            return viewRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewRefType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewRefType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class viewRefType


class indicesType2(GeneratedsSuper):
    """index -- An index into the IP-XACT object.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('index', 'unsignedIntExpression', 1, 0, {'maxOccurs': 'unbounded', 'name': 'index', 'type': 'unsignedIntExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, index=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if index is None:
            self.index = []
        else:
            self.index = index
        self.index_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indicesType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indicesType2.subclass:
            return indicesType2.subclass(*args_, **kwargs_)
        else:
            return indicesType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def add_index(self, value):
        self.index.append(value)
    def insert_index_at(self, index, value):
        self.index.insert(index, value)
    def replace_index_at(self, index, value):
        self.index[index] = value
    def _hasContent(self):
        if (
            self.index
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indicesType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indicesType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'indicesType2':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='indicesType2')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='indicesType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='indicesType2'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indicesType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for index_ in self.index:
            namespaceprefix_ = self.index_nsprefix_ + ':' if (UseCapturedNS_ and self.index_nsprefix_) else ''
            index_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='index', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'index':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.index.append(obj_)
            obj_.original_tagname_ = 'index'
# end class indicesType2


class viewRefType3(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType3.subclass:
            return viewRefType3.subclass(*args_, **kwargs_)
        else:
            return viewRefType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewRefType3':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewRefType3')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewRefType3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewRefType3'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType3', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class viewRefType3


class viewRefType4(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType4.subclass:
            return viewRefType4.subclass(*args_, **kwargs_)
        else:
            return viewRefType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewRefType4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewRefType4')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewRefType4', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewRefType4'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType4', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class viewRefType4


class indicesType5(GeneratedsSuper):
    """index -- An index into the IP-XACT object.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('index', 'unsignedIntExpression', 1, 0, {'maxOccurs': 'unbounded', 'name': 'index', 'type': 'unsignedIntExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, index=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if index is None:
            self.index = []
        else:
            self.index = index
        self.index_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indicesType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indicesType5.subclass:
            return indicesType5.subclass(*args_, **kwargs_)
        else:
            return indicesType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_index(self):
        return self.index
    def set_index(self, index):
        self.index = index
    def add_index(self, value):
        self.index.append(value)
    def insert_index_at(self, index, value):
        self.index.insert(index, value)
    def replace_index_at(self, index, value):
        self.index[index] = value
    def _hasContent(self):
        if (
            self.index
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indicesType5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indicesType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'indicesType5':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='indicesType5')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='indicesType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='indicesType5'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='indicesType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for index_ in self.index:
            namespaceprefix_ = self.index_nsprefix_ + ':' if (UseCapturedNS_ and self.index_nsprefix_) else ''
            index_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='index', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'index':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.index.append(obj_)
            obj_.original_tagname_ = 'index'
# end class indicesType5


class pathSegmentsType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('pathSegment', 'pathSegmentType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'pathSegment', 'type': 'pathSegmentType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, pathSegment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if pathSegment is None:
            self.pathSegment = []
        else:
            self.pathSegment = pathSegment
        self.pathSegment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathSegmentsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathSegmentsType.subclass:
            return pathSegmentsType.subclass(*args_, **kwargs_)
        else:
            return pathSegmentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pathSegment(self):
        return self.pathSegment
    def set_pathSegment(self, pathSegment):
        self.pathSegment = pathSegment
    def add_pathSegment(self, value):
        self.pathSegment.append(value)
    def insert_pathSegment_at(self, index, value):
        self.pathSegment.insert(index, value)
    def replace_pathSegment_at(self, index, value):
        self.pathSegment[index] = value
    def _hasContent(self):
        if (
            self.pathSegment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='pathSegmentsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pathSegmentsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'pathSegmentsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pathSegmentsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='pathSegmentsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pathSegmentsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='pathSegmentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pathSegment_ in self.pathSegment:
            namespaceprefix_ = self.pathSegment_nsprefix_ + ':' if (UseCapturedNS_ and self.pathSegment_nsprefix_) else ''
            pathSegment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pathSegment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pathSegment':
            obj_ = pathSegmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pathSegment.append(obj_)
            obj_.original_tagname_ = 'pathSegment'
# end class pathSegmentsType


class viewRefType6(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType6.subclass:
            return viewRefType6.subclass(*args_, **kwargs_)
        else:
            return viewRefType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType6', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewRefType6':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewRefType6')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewRefType6', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewRefType6'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType6', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class viewRefType6


class pathSegmentsType7(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('pathSegment', 'pathSegmentType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'pathSegment', 'type': 'pathSegmentType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, pathSegment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if pathSegment is None:
            self.pathSegment = []
        else:
            self.pathSegment = pathSegment
        self.pathSegment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathSegmentsType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathSegmentsType7.subclass:
            return pathSegmentsType7.subclass(*args_, **kwargs_)
        else:
            return pathSegmentsType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pathSegment(self):
        return self.pathSegment
    def set_pathSegment(self, pathSegment):
        self.pathSegment = pathSegment
    def add_pathSegment(self, value):
        self.pathSegment.append(value)
    def insert_pathSegment_at(self, index, value):
        self.pathSegment.insert(index, value)
    def replace_pathSegment_at(self, index, value):
        self.pathSegment[index] = value
    def _hasContent(self):
        if (
            self.pathSegment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='pathSegmentsType7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pathSegmentsType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'pathSegmentsType7':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pathSegmentsType7')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='pathSegmentsType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pathSegmentsType7'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='pathSegmentsType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pathSegment_ in self.pathSegment:
            namespaceprefix_ = self.pathSegment_nsprefix_ + ':' if (UseCapturedNS_ and self.pathSegment_nsprefix_) else ''
            pathSegment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pathSegment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pathSegment':
            obj_ = pathSegmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pathSegment.append(obj_)
            obj_.original_tagname_ = 'pathSegment'
# end class pathSegmentsType7


class pathSegmentsType8(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('pathSegment', 'pathSegmentType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'pathSegment', 'type': 'pathSegmentType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, pathSegment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if pathSegment is None:
            self.pathSegment = []
        else:
            self.pathSegment = pathSegment
        self.pathSegment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathSegmentsType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathSegmentsType8.subclass:
            return pathSegmentsType8.subclass(*args_, **kwargs_)
        else:
            return pathSegmentsType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pathSegment(self):
        return self.pathSegment
    def set_pathSegment(self, pathSegment):
        self.pathSegment = pathSegment
    def add_pathSegment(self, value):
        self.pathSegment.append(value)
    def insert_pathSegment_at(self, index, value):
        self.pathSegment.insert(index, value)
    def replace_pathSegment_at(self, index, value):
        self.pathSegment[index] = value
    def _hasContent(self):
        if (
            self.pathSegment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='pathSegmentsType8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pathSegmentsType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'pathSegmentsType8':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pathSegmentsType8')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='pathSegmentsType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pathSegmentsType8'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='pathSegmentsType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pathSegment_ in self.pathSegment:
            namespaceprefix_ = self.pathSegment_nsprefix_ + ':' if (UseCapturedNS_ and self.pathSegment_nsprefix_) else ''
            pathSegment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pathSegment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'pathSegment':
            obj_ = pathSegmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pathSegment.append(obj_)
            obj_.original_tagname_ = 'pathSegment'
# end class pathSegmentsType8


class arrayType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('left', 'unsignedIntExpression', 0, 0, {'name': 'left', 'ref': 'left', 'type': 'left'}, None),
        MemberSpec_('right', 'unsignedIntExpression', 0, 0, {'name': 'right', 'ref': 'right', 'type': 'right'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, left=None, right=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.left = left
        self.left_nsprefix_ = None
        self.right = right
        self.right_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, arrayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if arrayType.subclass:
            return arrayType.subclass(*args_, **kwargs_)
        else:
            return arrayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_left(self):
        return self.left
    def set_left(self, left):
        self.left = left
    def get_right(self):
        return self.right
    def set_right(self, right):
        self.right = right
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.left is not None or
            self.right is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='arrayType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('arrayType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'arrayType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='arrayType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='arrayType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='arrayType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='arrayType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left is not None:
            namespaceprefix_ = self.left_nsprefix_ + ':' if (UseCapturedNS_ and self.left_nsprefix_) else ''
            self.left.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='left', pretty_print=pretty_print)
        if self.right is not None:
            namespaceprefix_ = self.right_nsprefix_ + ':' if (UseCapturedNS_ and self.right_nsprefix_) else ''
            self.right.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='right', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'left':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.left = obj_
            obj_.original_tagname_ = 'left'
        elif nodeName_ == 'right':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.right = obj_
            obj_.original_tagname_ = 'right'
# end class arrayType


class protocolTypeType9(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('custom', 'xs:string', 0, 1, {'use': 'optional', 'name': 'custom'}),
        MemberSpec_('valueOf_', ['protocolTypeType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, custom=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.custom = _cast(None, custom)
        self.custom_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolTypeType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolTypeType9.subclass:
            return protocolTypeType9.subclass(*args_, **kwargs_)
        else:
            return protocolTypeType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_custom(self):
        return self.custom
    def set_custom(self, custom):
        self.custom = custom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_protocolTypeType(self, value):
        result = True
        # Validate type protocolTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['tlm', 'custom']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on protocolTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='protocolTypeType9', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('protocolTypeType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'protocolTypeType9':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='protocolTypeType9')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='protocolTypeType9', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='protocolTypeType9'):
        if self.custom is not None and 'custom' not in already_processed:
            already_processed.add('custom')
            outfile.write(' custom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.custom), input_name='custom')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='protocolTypeType9', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('custom', node)
        if value is not None and 'custom' not in already_processed:
            already_processed.add('custom')
            self.custom = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class protocolTypeType9


class extensionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('mandatory', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'mandatory'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, mandatory=False, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.mandatory = _cast(bool, mandatory)
        self.mandatory_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extensionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extensionType.subclass:
            return extensionType.subclass(*args_, **kwargs_)
        else:
            return extensionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mandatory(self):
        return self.mandatory
    def set_mandatory(self, mandatory):
        self.mandatory = mandatory
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='extensionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extensionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'extensionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='extensionType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='extensionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='extensionType'):
        if self.mandatory and 'mandatory' not in already_processed:
            already_processed.add('mandatory')
            outfile.write(' mandatory="%s"' % self.gds_format_boolean(self.mandatory, input_name='mandatory'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='extensionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mandatory', node)
        if value is not None and 'mandatory' not in already_processed:
            already_processed.add('mandatory')
            if value in ('true', '1'):
                self.mandatory = True
            elif value in ('false', '0'):
                self.mandatory = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class extensionType


class typeNameType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('exact', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'exact'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, exact=True, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.exact = _cast(bool, exact)
        self.exact_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeNameType.subclass:
            return typeNameType.subclass(*args_, **kwargs_)
        else:
            return typeNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_exact(self):
        return self.exact
    def set_exact(self, exact):
        self.exact = exact
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeNameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'typeNameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeNameType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeNameType'):
        if not self.exact and 'exact' not in already_processed:
            already_processed.add('exact')
            outfile.write(' exact="%s"' % self.gds_format_boolean(self.exact, input_name='exact'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exact', node)
        if value is not None and 'exact' not in already_processed:
            already_processed.add('exact')
            if value in ('true', '1'):
                self.exact = True
            elif value in ('false', '0'):
                self.exact = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class typeNameType


class typeDefinitionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeDefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeDefinitionType.subclass:
            return typeDefinitionType.subclass(*args_, **kwargs_)
        else:
            return typeDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeDefinitionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeDefinitionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'typeDefinitionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeDefinitionType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeDefinitionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeDefinitionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeDefinitionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class typeDefinitionType


class viewRefType10(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:NMTOKEN', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType10.subclass:
            return viewRefType10.subclass(*args_, **kwargs_)
        else:
            return viewRefType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewRefType10':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewRefType10')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewRefType10', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewRefType10'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType10', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class viewRefType10


class typeNameType11(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('implicit', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'implicit'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, implicit=False, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.implicit = _cast(bool, implicit)
        self.implicit_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeNameType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeNameType11.subclass:
            return typeNameType11.subclass(*args_, **kwargs_)
        else:
            return typeNameType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_implicit(self):
        return self.implicit
    def set_implicit(self, implicit):
        self.implicit = implicit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeNameType11', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeNameType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'typeNameType11':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeNameType11')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeNameType11', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeNameType11'):
        if self.implicit and 'implicit' not in already_processed:
            already_processed.add('implicit')
            outfile.write(' implicit="%s"' % self.gds_format_boolean(self.implicit, input_name='implicit'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeNameType11', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('implicit', node)
        if value is not None and 'implicit' not in already_processed:
            already_processed.add('implicit')
            if value in ('true', '1'):
                self.implicit = True
            elif value in ('false', '0'):
                self.implicit = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class typeNameType11


class typeDefinitionType12(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeDefinitionType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeDefinitionType12.subclass:
            return typeDefinitionType12.subclass(*args_, **kwargs_)
        else:
            return typeDefinitionType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeDefinitionType12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeDefinitionType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'typeDefinitionType12':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeDefinitionType12')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeDefinitionType12', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeDefinitionType12'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeDefinitionType12', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class typeDefinitionType12


class typeNameType13(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('constrained', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'constrained'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, constrained=False, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.constrained = _cast(bool, constrained)
        self.constrained_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeNameType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeNameType13.subclass:
            return typeNameType13.subclass(*args_, **kwargs_)
        else:
            return typeNameType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_constrained(self):
        return self.constrained
    def set_constrained(self, constrained):
        self.constrained = constrained
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeNameType13', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeNameType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'typeNameType13':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeNameType13')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeNameType13', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeNameType13'):
        if self.constrained and 'constrained' not in already_processed:
            already_processed.add('constrained')
            outfile.write(' constrained="%s"' % self.gds_format_boolean(self.constrained, input_name='constrained'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeNameType13', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('constrained', node)
        if value is not None and 'constrained' not in already_processed:
            already_processed.add('constrained')
            if value in ('true', '1'):
                self.constrained = True
            elif value in ('false', '0'):
                self.constrained = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class typeNameType13


class typeDefinitionType14(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeDefinitionType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeDefinitionType14.subclass:
            return typeDefinitionType14.subclass(*args_, **kwargs_)
        else:
            return typeDefinitionType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeDefinitionType14', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeDefinitionType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'typeDefinitionType14':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='typeDefinitionType14')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='typeDefinitionType14', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='typeDefinitionType14'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='typeDefinitionType14', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class typeDefinitionType14


class viewRefType15(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:NMTOKEN', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType15.subclass:
            return viewRefType15.subclass(*args_, **kwargs_)
        else:
            return viewRefType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType15', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewRefType15':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewRefType15')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewRefType15', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewRefType15'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewRefType15', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class viewRefType15


class connectionType(GeneratedsSuper):
    """maxConnections -- Indicates the maximum number of connections this port supports. If this element is not present or set to 0 it implies an unbounded number of allowed connections.
    minConnections -- Indicates the minimum number of connections this port supports. If this element is not present, the minimum number of allowed connections is 1.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('maxConnections', 'unsignedIntExpression', 0, 1, {'default': '0', 'minOccurs': '0', 'name': 'maxConnections', 'type': 'unsignedIntExpression'}, None),
        MemberSpec_('minConnections', 'unsignedIntExpression', 0, 1, {'default': '1', 'minOccurs': '0', 'name': 'minConnections', 'type': 'unsignedIntExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, maxConnections=None, minConnections=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if maxConnections is None:
            self.maxConnections = globals()['unsignedIntExpression']('0')
        else:
            self.maxConnections = maxConnections
        self.maxConnections_nsprefix_ = None
        if minConnections is None:
            self.minConnections = globals()['unsignedIntExpression']('1')
        else:
            self.minConnections = minConnections
        self.minConnections_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, connectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if connectionType.subclass:
            return connectionType.subclass(*args_, **kwargs_)
        else:
            return connectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_maxConnections(self):
        return self.maxConnections
    def set_maxConnections(self, maxConnections):
        self.maxConnections = maxConnections
    def get_minConnections(self):
        return self.minConnections
    def set_minConnections(self, minConnections):
        self.minConnections = minConnections
    def _hasContent(self):
        if (
            self.maxConnections is not None or
            self.minConnections is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='connectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('connectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'connectionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='connectionType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='connectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='connectionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='connectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.maxConnections is not None:
            namespaceprefix_ = self.maxConnections_nsprefix_ + ':' if (UseCapturedNS_ and self.maxConnections_nsprefix_) else ''
            self.maxConnections.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maxConnections', pretty_print=pretty_print)
        if self.minConnections is not None:
            namespaceprefix_ = self.minConnections_nsprefix_ + ':' if (UseCapturedNS_ and self.minConnections_nsprefix_) else ''
            self.minConnections.export(outfile, level, namespaceprefix_, namespacedef_='', name_='minConnections', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'maxConnections':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maxConnections = obj_
            obj_.original_tagname_ = 'maxConnections'
        elif nodeName_ == 'minConnections':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.minConnections = obj_
            obj_.original_tagname_ = 'minConnections'
# end class connectionType


class accessHandlesType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'leafAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'name': 'accessHandle', 'type': 'leafAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType.subclass:
            return accessHandlesType.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = leafAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType


class cellFunctionType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('other', 'xs:token', 0, 1, {'use': 'optional', 'name': 'other'}),
        MemberSpec_('valueOf_', ['cellFunctionValueType', 'xs:token'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, other=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.other = _cast(None, other)
        self.other_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cellFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cellFunctionType.subclass:
            return cellFunctionType.subclass(*args_, **kwargs_)
        else:
            return cellFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_other(self):
        return self.other
    def set_other(self, other):
        self.other = other
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_cellFunctionValueType(self, value):
        result = True
        # Validate type cellFunctionValueType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['nand2', 'buf', 'inv', 'mux21', 'dff', 'latch', 'xor2', 'other']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on cellFunctionValueType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='cellFunctionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cellFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cellFunctionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cellFunctionType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cellFunctionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cellFunctionType'):
        if self.other is not None and 'other' not in already_processed:
            already_processed.add('other')
            outfile.write(' other=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.other), input_name='other')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='cellFunctionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('other', node)
        if value is not None and 'other' not in already_processed:
            already_processed.add('other')
            self.other = value
            self.other = ' '.join(self.other.split())
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class cellFunctionType


class vectorType(GeneratedsSuper):
    """left -- The optional elements left and right can be used to select a bit-slice of a vector.
    right -- The optional elements left and right can be used to select a bit-slice of a vector.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('left', 'unsignedIntExpression', 0, 0, {'name': 'left', 'type': 'unsignedIntExpression'}, None),
        MemberSpec_('right', 'unsignedIntExpression', 0, 0, {'name': 'right', 'type': 'unsignedIntExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, left=None, right=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.left = left
        self.left_nsprefix_ = None
        self.right = right
        self.right_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vectorType.subclass:
            return vectorType.subclass(*args_, **kwargs_)
        else:
            return vectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_left(self):
        return self.left
    def set_left(self, left):
        self.left = left
    def get_right(self):
        return self.right
    def set_right(self, right):
        self.right = right
    def _hasContent(self):
        if (
            self.left is not None or
            self.right is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='vectorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'vectorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='vectorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='vectorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='vectorType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='vectorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left is not None:
            namespaceprefix_ = self.left_nsprefix_ + ':' if (UseCapturedNS_ and self.left_nsprefix_) else ''
            self.left.export(outfile, level, namespaceprefix_, namespacedef_='', name_='left', pretty_print=pretty_print)
        if self.right is not None:
            namespaceprefix_ = self.right_nsprefix_ + ':' if (UseCapturedNS_ and self.right_nsprefix_) else ''
            self.right.export(outfile, level, namespaceprefix_, namespacedef_='', name_='right', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'left':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.left = obj_
            obj_.original_tagname_ = 'left'
        elif nodeName_ == 'right':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.right = obj_
            obj_.original_tagname_ = 'right'
# end class vectorType


class isIncludeFileType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('externalDeclarations', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'externalDeclarations'}),
        MemberSpec_('valueOf_', 'xs:boolean', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, externalDeclarations=False, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.externalDeclarations = _cast(bool, externalDeclarations)
        self.externalDeclarations_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, isIncludeFileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if isIncludeFileType.subclass:
            return isIncludeFileType.subclass(*args_, **kwargs_)
        else:
            return isIncludeFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_externalDeclarations(self):
        return self.externalDeclarations
    def set_externalDeclarations(self, externalDeclarations):
        self.externalDeclarations = externalDeclarations
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='isIncludeFileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('isIncludeFileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'isIncludeFileType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='isIncludeFileType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='isIncludeFileType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='isIncludeFileType'):
        if self.externalDeclarations and 'externalDeclarations' not in already_processed:
            already_processed.add('externalDeclarations')
            outfile.write(' externalDeclarations="%s"' % self.gds_format_boolean(self.externalDeclarations, input_name='externalDeclarations'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='isIncludeFileType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('externalDeclarations', node)
        if value is not None and 'externalDeclarations' not in already_processed:
            already_processed.add('externalDeclarations')
            if value in ('true', '1'):
                self.externalDeclarations = True
            elif value in ('false', '0'):
                self.externalDeclarations = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class isIncludeFileType


class logicalNameType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('default', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'default'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, default=False, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.default = _cast(bool, default)
        self.default_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, logicalNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if logicalNameType.subclass:
            return logicalNameType.subclass(*args_, **kwargs_)
        else:
            return logicalNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_default(self):
        return self.default
    def set_default(self, default):
        self.default = default
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='logicalNameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('logicalNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'logicalNameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='logicalNameType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='logicalNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='logicalNameType'):
        if self.default and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_boolean(self.default, input_name='default'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='logicalNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            if value in ('true', '1'):
                self.default = True
            elif value in ('false', '0'):
                self.default = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class logicalNameType


class exportedNameType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exportedNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exportedNameType.subclass:
            return exportedNameType.subclass(*args_, **kwargs_)
        else:
            return exportedNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='exportedNameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exportedNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'exportedNameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='exportedNameType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='exportedNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='exportedNameType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='exportedNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class exportedNameType


class buildCommandType(GeneratedsSuper):
    """command -- Command used to build this file.
    flags -- Flags given to the build command when building this file. If the optional attribute "append" is "true", this string will be appended to any existing flags, otherwise these flags will replace any existing default flags.
    replaceDefaultFlags -- If true, the value of the sibling element "flags" should replace any default flags specified at a more global level. If this is true and the sibling element "flags" is empty or missing, this has the effect of clearing any default flags.
    targetName -- Pathname to the file that is derived (built) from the source file.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('command', 'stringExpression', 0, 1, {'minOccurs': '0', 'name': 'command', 'type': 'stringExpression'}, None),
        MemberSpec_('flags', 'flagsType', 0, 1, {'minOccurs': '0', 'name': 'flags', 'type': 'flagsType'}, None),
        MemberSpec_('replaceDefaultFlags', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'replaceDefaultFlags', 'type': 'unsignedBitExpression'}, None),
        MemberSpec_('targetName', 'stringURIExpression', 0, 1, {'minOccurs': '0', 'name': 'targetName', 'type': 'stringURIExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, command=None, flags=None, replaceDefaultFlags=None, targetName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.command = command
        self.command_nsprefix_ = None
        self.flags = flags
        self.flags_nsprefix_ = None
        self.replaceDefaultFlags = replaceDefaultFlags
        self.replaceDefaultFlags_nsprefix_ = None
        self.targetName = targetName
        self.targetName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, buildCommandType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if buildCommandType.subclass:
            return buildCommandType.subclass(*args_, **kwargs_)
        else:
            return buildCommandType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_command(self):
        return self.command
    def set_command(self, command):
        self.command = command
    def get_flags(self):
        return self.flags
    def set_flags(self, flags):
        self.flags = flags
    def get_replaceDefaultFlags(self):
        return self.replaceDefaultFlags
    def set_replaceDefaultFlags(self, replaceDefaultFlags):
        self.replaceDefaultFlags = replaceDefaultFlags
    def get_targetName(self):
        return self.targetName
    def set_targetName(self, targetName):
        self.targetName = targetName
    def _hasContent(self):
        if (
            self.command is not None or
            self.flags is not None or
            self.replaceDefaultFlags is not None or
            self.targetName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='buildCommandType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('buildCommandType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'buildCommandType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='buildCommandType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='buildCommandType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='buildCommandType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='buildCommandType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.command is not None:
            namespaceprefix_ = self.command_nsprefix_ + ':' if (UseCapturedNS_ and self.command_nsprefix_) else ''
            self.command.export(outfile, level, namespaceprefix_, namespacedef_='', name_='command', pretty_print=pretty_print)
        if self.flags is not None:
            namespaceprefix_ = self.flags_nsprefix_ + ':' if (UseCapturedNS_ and self.flags_nsprefix_) else ''
            self.flags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flags', pretty_print=pretty_print)
        if self.replaceDefaultFlags is not None:
            namespaceprefix_ = self.replaceDefaultFlags_nsprefix_ + ':' if (UseCapturedNS_ and self.replaceDefaultFlags_nsprefix_) else ''
            self.replaceDefaultFlags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='replaceDefaultFlags', pretty_print=pretty_print)
        if self.targetName is not None:
            namespaceprefix_ = self.targetName_nsprefix_ + ':' if (UseCapturedNS_ and self.targetName_nsprefix_) else ''
            self.targetName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetName', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'command':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.command = obj_
            obj_.original_tagname_ = 'command'
        elif nodeName_ == 'flags':
            obj_ = flagsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flags = obj_
            obj_.original_tagname_ = 'flags'
        elif nodeName_ == 'replaceDefaultFlags':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.replaceDefaultFlags = obj_
            obj_.original_tagname_ = 'replaceDefaultFlags'
        elif nodeName_ == 'targetName':
            obj_ = stringURIExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetName = obj_
            obj_.original_tagname_ = 'targetName'
# end class buildCommandType


class imageTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, imageTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if imageTypeType.subclass:
            return imageTypeType.subclass(*args_, **kwargs_)
        else:
            return imageTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='imageTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('imageTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'imageTypeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='imageTypeType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='imageTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='imageTypeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='imageTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class imageTypeType


class languageToolsType(GeneratedsSuper):
    """fileBuilder -- A generic placeholder for any file builder like compilers and assemblers.  It contains the file types to which the command should be applied, and the flags to be used with that command.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('fileBuilder', 'fileBuilderType16', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'fileBuilder', 'type': 'fileBuilderType16'}, None),
        MemberSpec_('linker', 'stringExpression', 0, 0, {'minOccurs': '1', 'name': 'linker', 'type': 'stringExpression'}, None),
        MemberSpec_('linkerFlags', 'stringExpression', 0, 0, {'minOccurs': '1', 'name': 'linkerFlags', 'type': 'stringExpression'}, 27),
        MemberSpec_('linkerCommandFile', 'linkerCommandFile', 0, 0, {'minOccurs': '1', 'name': 'linkerCommandFile', 'ref': 'linkerCommandFile', 'type': 'linkerCommandFile'}, 27),
    ]
    subclass = None
    superclass = None
    def __init__(self, fileBuilder=None, linker=None, linkerFlags=None, linkerCommandFile=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if fileBuilder is None:
            self.fileBuilder = []
        else:
            self.fileBuilder = fileBuilder
        self.fileBuilder_nsprefix_ = None
        self.linker = linker
        self.linker_nsprefix_ = None
        self.linkerFlags = linkerFlags
        self.linkerFlags_nsprefix_ = None
        self.linkerCommandFile = linkerCommandFile
        self.linkerCommandFile_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, languageToolsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if languageToolsType.subclass:
            return languageToolsType.subclass(*args_, **kwargs_)
        else:
            return languageToolsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fileBuilder(self):
        return self.fileBuilder
    def set_fileBuilder(self, fileBuilder):
        self.fileBuilder = fileBuilder
    def add_fileBuilder(self, value):
        self.fileBuilder.append(value)
    def insert_fileBuilder_at(self, index, value):
        self.fileBuilder.insert(index, value)
    def replace_fileBuilder_at(self, index, value):
        self.fileBuilder[index] = value
    def get_linker(self):
        return self.linker
    def set_linker(self, linker):
        self.linker = linker
    def get_linkerFlags(self):
        return self.linkerFlags
    def set_linkerFlags(self, linkerFlags):
        self.linkerFlags = linkerFlags
    def get_linkerCommandFile(self):
        return self.linkerCommandFile
    def set_linkerCommandFile(self, linkerCommandFile):
        self.linkerCommandFile = linkerCommandFile
    def _hasContent(self):
        if (
            self.fileBuilder or
            self.linker is not None or
            self.linkerFlags is not None or
            self.linkerCommandFile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='languageToolsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('languageToolsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'languageToolsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='languageToolsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='languageToolsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='languageToolsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='languageToolsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fileBuilder_ in self.fileBuilder:
            namespaceprefix_ = self.fileBuilder_nsprefix_ + ':' if (UseCapturedNS_ and self.fileBuilder_nsprefix_) else ''
            fileBuilder_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fileBuilder', pretty_print=pretty_print)
        if self.linker is not None:
            namespaceprefix_ = self.linker_nsprefix_ + ':' if (UseCapturedNS_ and self.linker_nsprefix_) else ''
            self.linker.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linker', pretty_print=pretty_print)
        if self.linkerFlags is not None:
            namespaceprefix_ = self.linkerFlags_nsprefix_ + ':' if (UseCapturedNS_ and self.linkerFlags_nsprefix_) else ''
            self.linkerFlags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='linkerFlags', pretty_print=pretty_print)
        if self.linkerCommandFile is not None:
            namespaceprefix_ = self.linkerCommandFile_nsprefix_ + ':' if (UseCapturedNS_ and self.linkerCommandFile_nsprefix_) else ''
            self.linkerCommandFile.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='linkerCommandFile', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fileBuilder':
            obj_ = fileBuilderType16.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileBuilder.append(obj_)
            obj_.original_tagname_ = 'fileBuilder'
        elif nodeName_ == 'linker':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.linker = obj_
            obj_.original_tagname_ = 'linker'
        elif nodeName_ == 'linkerFlags':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.linkerFlags = obj_
            obj_.original_tagname_ = 'linkerFlags'
        elif nodeName_ == 'linkerCommandFile':
            obj_ = linkerCommandFile.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.linkerCommandFile = obj_
            obj_.original_tagname_ = 'linkerCommandFile'
# end class languageToolsType


class fileBuilderType16(GeneratedsSuper):
    """command -- Default command used to build files of the specified fileType.
    flags -- Flags given to the build command when building files of this type.
    replaceDefaultFlags -- If true, replace any default flags value with the value in the sibling flags element. Otherwise, append the contents of the sibling flags element to any default flags value.
    If the value is true and the "flags" element is empty or missing, this will have the result of clearing any default flags value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('fileType', 'fileType', 0, 0, {'name': 'fileType', 'ref': 'fileType', 'type': 'fileType'}, None),
        MemberSpec_('command', 'stringExpression', 0, 0, {'name': 'command', 'type': 'stringExpression'}, None),
        MemberSpec_('flags', 'stringExpression', 0, 1, {'minOccurs': '0', 'name': 'flags', 'type': 'stringExpression'}, None),
        MemberSpec_('replaceDefaultFlags', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'replaceDefaultFlags', 'type': 'unsignedBitExpression'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, fileType=None, command=None, flags=None, replaceDefaultFlags=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.fileType = fileType
        self.fileType_nsprefix_ = None
        self.command = command
        self.command_nsprefix_ = None
        self.flags = flags
        self.flags_nsprefix_ = None
        self.replaceDefaultFlags = replaceDefaultFlags
        self.replaceDefaultFlags_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileBuilderType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileBuilderType16.subclass:
            return fileBuilderType16.subclass(*args_, **kwargs_)
        else:
            return fileBuilderType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fileType(self):
        return self.fileType
    def set_fileType(self, fileType):
        self.fileType = fileType
    def get_command(self):
        return self.command
    def set_command(self, command):
        self.command = command
    def get_flags(self):
        return self.flags
    def set_flags(self, flags):
        self.flags = flags
    def get_replaceDefaultFlags(self):
        return self.replaceDefaultFlags
    def set_replaceDefaultFlags(self, replaceDefaultFlags):
        self.replaceDefaultFlags = replaceDefaultFlags
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.fileType is not None or
            self.command is not None or
            self.flags is not None or
            self.replaceDefaultFlags is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileBuilderType16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileBuilderType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fileBuilderType16':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileBuilderType16')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fileBuilderType16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fileBuilderType16'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileBuilderType16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fileType is not None:
            namespaceprefix_ = self.fileType_nsprefix_ + ':' if (UseCapturedNS_ and self.fileType_nsprefix_) else ''
            self.fileType.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='fileType', pretty_print=pretty_print)
        if self.command is not None:
            namespaceprefix_ = self.command_nsprefix_ + ':' if (UseCapturedNS_ and self.command_nsprefix_) else ''
            self.command.export(outfile, level, namespaceprefix_, namespacedef_='', name_='command', pretty_print=pretty_print)
        if self.flags is not None:
            namespaceprefix_ = self.flags_nsprefix_ + ':' if (UseCapturedNS_ and self.flags_nsprefix_) else ''
            self.flags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flags', pretty_print=pretty_print)
        if self.replaceDefaultFlags is not None:
            namespaceprefix_ = self.replaceDefaultFlags_nsprefix_ + ':' if (UseCapturedNS_ and self.replaceDefaultFlags_nsprefix_) else ''
            self.replaceDefaultFlags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='replaceDefaultFlags', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fileType':
            obj_ = fileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileType = obj_
            obj_.original_tagname_ = 'fileType'
        elif nodeName_ == 'command':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.command = obj_
            obj_.original_tagname_ = 'command'
        elif nodeName_ == 'flags':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flags = obj_
            obj_.original_tagname_ = 'flags'
        elif nodeName_ == 'replaceDefaultFlags':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.replaceDefaultFlags = obj_
            obj_.original_tagname_ = 'replaceDefaultFlags'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class fileBuilderType16


class fileSetRefGroupType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('fileSetRef', 'fileSetRef', 1, 0, {'maxOccurs': 'unbounded', 'name': 'fileSetRef', 'ref': 'fileSetRef', 'type': 'fileSetRef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, fileSetRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if fileSetRef is None:
            self.fileSetRef = []
        else:
            self.fileSetRef = fileSetRef
        self.fileSetRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSetRefGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSetRefGroupType.subclass:
            return fileSetRefGroupType.subclass(*args_, **kwargs_)
        else:
            return fileSetRefGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_fileSetRef(self):
        return self.fileSetRef
    def set_fileSetRef(self, fileSetRef):
        self.fileSetRef = fileSetRef
    def add_fileSetRef(self, value):
        self.fileSetRef.append(value)
    def insert_fileSetRef_at(self, index, value):
        self.fileSetRef.insert(index, value)
    def replace_fileSetRef_at(self, index, value):
        self.fileSetRef[index] = value
    def _hasContent(self):
        if (
            self.fileSetRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSetRefGroupType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSetRefGroupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fileSetRefGroupType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileSetRefGroupType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fileSetRefGroupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fileSetRefGroupType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSetRefGroupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fileSetRef_ in self.fileSetRef:
            namespaceprefix_ = self.fileSetRef_nsprefix_ + ':' if (UseCapturedNS_ and self.fileSetRef_nsprefix_) else ''
            fileSetRef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='fileSetRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'fileSetRef':
            obj_ = fileSetRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileSetRef.append(obj_)
            obj_.original_tagname_ = 'fileSetRef'
# end class fileSetRefGroupType


class groupType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupType.subclass:
            return groupType.subclass(*args_, **kwargs_)
        else:
            return groupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='groupType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('groupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'groupType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='groupType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='groupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='groupType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='groupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class groupType


class functionType(GeneratedsSuper):
    """entryPoint -- Optional name for the function.
    fileRef -- A reference to the file that contains the entry point function.
    returnType -- Function return type. Possible values are void and int.
    argument -- Arguments passed in when the function is called. Arguments are passed in order.
    This is an extension of the name-value pair which includes the data type in the ipxact:dataType attribute.  The argument name is in the ipxact:name element and its value is in the ipxact:value element.
    disabled -- Specifies if the SW function is enabled. If not present the function is always enabled.
    sourceFile -- Location information for the source file of this function.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('replicate', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'replicate'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('entryPoint', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'entryPoint', 'type': 'xs:Name'}, None),
        MemberSpec_('fileRef', 'xs:token', 0, 0, {'name': 'fileRef', 'type': 'xs:token'}, None),
        MemberSpec_('returnType', ['returnTypeType', 'xs:string'], 0, 1, {'minOccurs': '0', 'name': 'returnType', 'type': 'xs:string'}, None),
        MemberSpec_('argument', 'argumentType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'argument', 'type': 'argumentType'}, None),
        MemberSpec_('disabled', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'disabled', 'type': 'unsignedBitExpression'}, None),
        MemberSpec_('sourceFile', 'sourceFileType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'sourceFile', 'type': 'sourceFileType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, replicate=False, id=None, entryPoint=None, fileRef=None, returnType=None, argument=None, disabled=None, sourceFile=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.replicate = _cast(bool, replicate)
        self.replicate_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.entryPoint = entryPoint
        self.entryPoint_nsprefix_ = None
        self.fileRef = fileRef
        self.fileRef_nsprefix_ = None
        self.returnType = returnType
        self.validate_returnTypeType(self.returnType)
        self.returnType_nsprefix_ = None
        if argument is None:
            self.argument = []
        else:
            self.argument = argument
        self.argument_nsprefix_ = None
        self.disabled = disabled
        self.disabled_nsprefix_ = None
        if sourceFile is None:
            self.sourceFile = []
        else:
            self.sourceFile = sourceFile
        self.sourceFile_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, functionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if functionType.subclass:
            return functionType.subclass(*args_, **kwargs_)
        else:
            return functionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_entryPoint(self):
        return self.entryPoint
    def set_entryPoint(self, entryPoint):
        self.entryPoint = entryPoint
    def get_fileRef(self):
        return self.fileRef
    def set_fileRef(self, fileRef):
        self.fileRef = fileRef
    def get_returnType(self):
        return self.returnType
    def set_returnType(self, returnType):
        self.returnType = returnType
    def get_argument(self):
        return self.argument
    def set_argument(self, argument):
        self.argument = argument
    def add_argument(self, value):
        self.argument.append(value)
    def insert_argument_at(self, index, value):
        self.argument.insert(index, value)
    def replace_argument_at(self, index, value):
        self.argument[index] = value
    def get_disabled(self):
        return self.disabled
    def set_disabled(self, disabled):
        self.disabled = disabled
    def get_sourceFile(self):
        return self.sourceFile
    def set_sourceFile(self, sourceFile):
        self.sourceFile = sourceFile
    def add_sourceFile(self, value):
        self.sourceFile.append(value)
    def insert_sourceFile_at(self, index, value):
        self.sourceFile.insert(index, value)
    def replace_sourceFile_at(self, index, value):
        self.sourceFile[index] = value
    def get_replicate(self):
        return self.replicate
    def set_replicate(self, replicate):
        self.replicate = replicate
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_returnTypeType(self, value):
        result = True
        # Validate type returnTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['void', 'int']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on returnTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.entryPoint is not None or
            self.fileRef is not None or
            self.returnType is not None or
            self.argument or
            self.disabled is not None or
            self.sourceFile
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='functionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('functionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'functionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='functionType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='functionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='functionType'):
        if self.replicate and 'replicate' not in already_processed:
            already_processed.add('replicate')
            outfile.write(' replicate="%s"' % self.gds_format_boolean(self.replicate, input_name='replicate'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='functionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entryPoint is not None:
            namespaceprefix_ = self.entryPoint_nsprefix_ + ':' if (UseCapturedNS_ and self.entryPoint_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sentryPoint>%s</%sentryPoint>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.entryPoint), input_name='entryPoint')), namespaceprefix_ , eol_))
        if self.fileRef is not None:
            namespaceprefix_ = self.fileRef_nsprefix_ + ':' if (UseCapturedNS_ and self.fileRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfileRef>%s</%sfileRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fileRef), input_name='fileRef')), namespaceprefix_ , eol_))
        if self.returnType is not None:
            namespaceprefix_ = self.returnType_nsprefix_ + ':' if (UseCapturedNS_ and self.returnType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreturnType>%s</%sreturnType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.returnType), input_name='returnType')), namespaceprefix_ , eol_))
        for argument_ in self.argument:
            namespaceprefix_ = self.argument_nsprefix_ + ':' if (UseCapturedNS_ and self.argument_nsprefix_) else ''
            argument_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='argument', pretty_print=pretty_print)
        if self.disabled is not None:
            namespaceprefix_ = self.disabled_nsprefix_ + ':' if (UseCapturedNS_ and self.disabled_nsprefix_) else ''
            self.disabled.export(outfile, level, namespaceprefix_, namespacedef_='', name_='disabled', pretty_print=pretty_print)
        for sourceFile_ in self.sourceFile:
            namespaceprefix_ = self.sourceFile_nsprefix_ + ':' if (UseCapturedNS_ and self.sourceFile_nsprefix_) else ''
            sourceFile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sourceFile', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('replicate', node)
        if value is not None and 'replicate' not in already_processed:
            already_processed.add('replicate')
            if value in ('true', '1'):
                self.replicate = True
            elif value in ('false', '0'):
                self.replicate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'entryPoint':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'entryPoint')
            value_ = self.gds_validate_string(value_, node, 'entryPoint')
            self.entryPoint = value_
            self.entryPoint_nsprefix_ = child_.prefix
        elif nodeName_ == 'fileRef':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'fileRef')
            value_ = self.gds_validate_string(value_, node, 'fileRef')
            self.fileRef = value_
            self.fileRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'returnType':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'returnType')
            value_ = self.gds_validate_string(value_, node, 'returnType')
            self.returnType = value_
            self.returnType_nsprefix_ = child_.prefix
            # validate type returnTypeType
            self.validate_returnTypeType(self.returnType)
        elif nodeName_ == 'argument':
            obj_ = argumentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.argument.append(obj_)
            obj_.original_tagname_ = 'argument'
        elif nodeName_ == 'disabled':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.disabled = obj_
            obj_.original_tagname_ = 'disabled'
        elif nodeName_ == 'sourceFile':
            obj_ = sourceFileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sourceFile.append(obj_)
            obj_.original_tagname_ = 'sourceFile'
# end class functionType


class argumentType(nameValuePairType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('dataType', 'ipxact:dataTypeType', 0, 0, {'use': 'required', 'name': 'dataType'}),
    ]
    subclass = None
    superclass = nameValuePairType
    def __init__(self, id=None, name=None, displayName=None, description=None, value=None, vendorExtensions=None, dataType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("argumentType"), self).__init__(id, name, displayName, description, value, vendorExtensions,  **kwargs_)
        self.dataType = _cast(None, dataType)
        self.dataType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, argumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if argumentType.subclass:
            return argumentType.subclass(*args_, **kwargs_)
        else:
            return argumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dataType(self):
        return self.dataType
    def set_dataType(self, dataType):
        self.dataType = dataType
    def validate_dataTypeType(self, value):
        # Validate type ipxact:dataTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['int', 'unsigned int', 'long', 'unsigned long', 'float', 'double', 'char *', 'void *']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on dataTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            super(argumentType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='argumentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('argumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'argumentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='argumentType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='argumentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='argumentType'):
        super(argumentType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='argumentType')
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='argumentType', fromsubclass_=False, pretty_print=True):
        super(argumentType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
            self.validate_dataTypeType(self.dataType)    # validate type dataTypeType
        super(argumentType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(argumentType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class argumentType


class sourceFileType(GeneratedsSuper):
    """sourceName -- Source file for the boot load.  Relative names are searched for in the project directory and the source of the component directory.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('sourceName', 'ipxactURI', 0, 0, {'name': 'sourceName', 'type': 'ipxactURI'}, None),
        MemberSpec_('fileType', 'fileType', 0, 0, {'name': 'fileType', 'ref': 'fileType', 'type': 'fileType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, sourceName=None, fileType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.sourceName = sourceName
        self.sourceName_nsprefix_ = None
        self.fileType = fileType
        self.fileType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sourceFileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sourceFileType.subclass:
            return sourceFileType.subclass(*args_, **kwargs_)
        else:
            return sourceFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sourceName(self):
        return self.sourceName
    def set_sourceName(self, sourceName):
        self.sourceName = sourceName
    def get_fileType(self):
        return self.fileType
    def set_fileType(self, fileType):
        self.fileType = fileType
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.sourceName is not None or
            self.fileType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='sourceFileType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sourceFileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'sourceFileType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='sourceFileType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='sourceFileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='sourceFileType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='sourceFileType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sourceName is not None:
            namespaceprefix_ = self.sourceName_nsprefix_ + ':' if (UseCapturedNS_ and self.sourceName_nsprefix_) else ''
            self.sourceName.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sourceName', pretty_print=pretty_print)
        if self.fileType is not None:
            namespaceprefix_ = self.fileType_nsprefix_ + ':' if (UseCapturedNS_ and self.fileType_nsprefix_) else ''
            self.fileType.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='fileType', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sourceName':
            class_obj_ = self.get_class_obj_(child_, ipxactURI)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sourceName = obj_
            obj_.original_tagname_ = 'sourceName'
        elif nodeName_ == 'fileType':
            obj_ = fileType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileType = obj_
            obj_.original_tagname_ = 'fileType'
# end class sourceFileType


class generatorChainSelectorType(GeneratedsSuper):
    """generatorChainRef -- Select another generator chain using the unique identifier of this generator chain.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('unique', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'unique'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('groupSelector', 'groupSelector', 0, 0, {'name': 'groupSelector', 'ref': 'groupSelector', 'type': 'groupSelector'}, 28),
        MemberSpec_('generatorChainRef', 'configurableLibraryRefType', 0, 0, {'name': 'generatorChainRef', 'type': 'configurableLibraryRefType'}, 28),
    ]
    subclass = None
    superclass = None
    def __init__(self, unique=False, id=None, groupSelector=None, generatorChainRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.unique = _cast(bool, unique)
        self.unique_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.groupSelector = groupSelector
        self.groupSelector_nsprefix_ = None
        self.generatorChainRef = generatorChainRef
        self.generatorChainRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generatorChainSelectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generatorChainSelectorType.subclass:
            return generatorChainSelectorType.subclass(*args_, **kwargs_)
        else:
            return generatorChainSelectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_groupSelector(self):
        return self.groupSelector
    def set_groupSelector(self, groupSelector):
        self.groupSelector = groupSelector
    def get_generatorChainRef(self):
        return self.generatorChainRef
    def set_generatorChainRef(self, generatorChainRef):
        self.generatorChainRef = generatorChainRef
    def get_unique(self):
        return self.unique
    def set_unique(self, unique):
        self.unique = unique
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.groupSelector is not None or
            self.generatorChainRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generatorChainSelectorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generatorChainSelectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'generatorChainSelectorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='generatorChainSelectorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='generatorChainSelectorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='generatorChainSelectorType'):
        if self.unique and 'unique' not in already_processed:
            already_processed.add('unique')
            outfile.write(' unique="%s"' % self.gds_format_boolean(self.unique, input_name='unique'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generatorChainSelectorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.groupSelector is not None:
            namespaceprefix_ = self.groupSelector_nsprefix_ + ':' if (UseCapturedNS_ and self.groupSelector_nsprefix_) else ''
            self.groupSelector.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='groupSelector', pretty_print=pretty_print)
        if self.generatorChainRef is not None:
            namespaceprefix_ = self.generatorChainRef_nsprefix_ + ':' if (UseCapturedNS_ and self.generatorChainRef_nsprefix_) else ''
            self.generatorChainRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='generatorChainRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unique', node)
        if value is not None and 'unique' not in already_processed:
            already_processed.add('unique')
            if value in ('true', '1'):
                self.unique = True
            elif value in ('false', '0'):
                self.unique = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'groupSelector':
            obj_ = groupSelector.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groupSelector = obj_
            obj_.original_tagname_ = 'groupSelector'
        elif nodeName_ == 'generatorChainRef':
            obj_ = ConfigurableLibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.generatorChainRef = obj_
            obj_.original_tagname_ = 'generatorChainRef'
# end class generatorChainSelectorType


class chainGroupType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, chainGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if chainGroupType.subclass:
            return chainGroupType.subclass(*args_, **kwargs_)
        else:
            return chainGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='chainGroupType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('chainGroupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'chainGroupType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='chainGroupType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='chainGroupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='chainGroupType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='chainGroupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class chainGroupType


class nameType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nameType.subclass:
            return nameType.subclass(*args_, **kwargs_)
        else:
            return nameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='nameType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'nameType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='nameType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='nameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='nameType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='nameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class nameType


class groupType17(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupType17.subclass:
            return groupType17.subclass(*args_, **kwargs_)
        else:
            return groupType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='groupType17', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('groupType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'groupType17':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='groupType17')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='groupType17', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='groupType17'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='groupType17', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class groupType17


class apiTypeType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', ['apiType', 'xs:token'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, apiTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if apiTypeType.subclass:
            return apiTypeType.subclass(*args_, **kwargs_)
        else:
            return apiTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_apiType(self, value):
        result = True
        # Validate type apiType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['TGI_2009', 'TGI_2014_BASE', 'TGI_2014_EXTENDED', 'none']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on apiType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='apiTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('apiTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'apiTypeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='apiTypeType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='apiTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='apiTypeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='apiTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class apiTypeType


class transportMethodsType(GeneratedsSuper):
    """transportMethod -- Defines a SOAP transport protocol other than HTTP which is supported by this generator. The only other currently supported protocol is 'file'.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('transportMethod', 'transportMethodType18', 0, 0, {'name': 'transportMethod', 'type': 'transportMethodType18'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, transportMethod=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.transportMethod = transportMethod
        self.transportMethod_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transportMethodsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transportMethodsType.subclass:
            return transportMethodsType.subclass(*args_, **kwargs_)
        else:
            return transportMethodsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_transportMethod(self):
        return self.transportMethod
    def set_transportMethod(self, transportMethod):
        self.transportMethod = transportMethod
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.transportMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transportMethodsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transportMethodsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'transportMethodsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transportMethodsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='transportMethodsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='transportMethodsType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transportMethodsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.transportMethod is not None:
            namespaceprefix_ = self.transportMethod_nsprefix_ + ':' if (UseCapturedNS_ and self.transportMethod_nsprefix_) else ''
            self.transportMethod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transportMethod', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'transportMethod':
            obj_ = transportMethodType18.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transportMethod = obj_
            obj_.original_tagname_ = 'transportMethod'
# end class transportMethodsType


class transportMethodType18(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', ['transportMethodType', 'xs:token'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transportMethodType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transportMethodType18.subclass:
            return transportMethodType18.subclass(*args_, **kwargs_)
        else:
            return transportMethodType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_transportMethodType(self, value):
        result = True
        # Validate type transportMethodType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['file']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on transportMethodType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transportMethodType18', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transportMethodType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'transportMethodType18':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transportMethodType18')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='transportMethodType18', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='transportMethodType18'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transportMethodType18', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class transportMethodType18


class whiteboxElementsType(GeneratedsSuper):
    """whiteboxElement -- A whiteboxElement is a useful way to identify elements of a component that can not be identified through other means such as internal signals and non-software accessible registers.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('whiteboxElement', 'whiteboxElementType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'whiteboxElement', 'type': 'whiteboxElementType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, whiteboxElement=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if whiteboxElement is None:
            self.whiteboxElement = []
        else:
            self.whiteboxElement = whiteboxElement
        self.whiteboxElement_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, whiteboxElementsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if whiteboxElementsType.subclass:
            return whiteboxElementsType.subclass(*args_, **kwargs_)
        else:
            return whiteboxElementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_whiteboxElement(self):
        return self.whiteboxElement
    def set_whiteboxElement(self, whiteboxElement):
        self.whiteboxElement = whiteboxElement
    def add_whiteboxElement(self, value):
        self.whiteboxElement.append(value)
    def insert_whiteboxElement_at(self, index, value):
        self.whiteboxElement.insert(index, value)
    def replace_whiteboxElement_at(self, index, value):
        self.whiteboxElement[index] = value
    def _hasContent(self):
        if (
            self.whiteboxElement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='whiteboxElementsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('whiteboxElementsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'whiteboxElementsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='whiteboxElementsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='whiteboxElementsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='whiteboxElementsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='whiteboxElementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for whiteboxElement_ in self.whiteboxElement:
            namespaceprefix_ = self.whiteboxElement_nsprefix_ + ':' if (UseCapturedNS_ and self.whiteboxElement_nsprefix_) else ''
            whiteboxElement_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='whiteboxElement', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'whiteboxElement':
            obj_ = whiteboxElementType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.whiteboxElement.append(obj_)
            obj_.original_tagname_ = 'whiteboxElement'
# end class whiteboxElementsType


class cpusType(GeneratedsSuper):
    """cpu -- Describes a processor in this component.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('cpu', 'cpuType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'cpu', 'type': 'cpuType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cpu=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if cpu is None:
            self.cpu = []
        else:
            self.cpu = cpu
        self.cpu_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cpusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cpusType.subclass:
            return cpusType.subclass(*args_, **kwargs_)
        else:
            return cpusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_cpu(self):
        return self.cpu
    def set_cpu(self, cpu):
        self.cpu = cpu
    def add_cpu(self, value):
        self.cpu.append(value)
    def insert_cpu_at(self, index, value):
        self.cpu.insert(index, value)
    def replace_cpu_at(self, index, value):
        self.cpu[index] = value
    def _hasContent(self):
        if (
            self.cpu
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='cpusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cpusType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cpusType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cpusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cpusType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='cpusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cpu_ in self.cpu:
            namespaceprefix_ = self.cpu_nsprefix_ + ':' if (UseCapturedNS_ and self.cpu_nsprefix_) else ''
            cpu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cpu', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'cpu':
            obj_ = cpuType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.cpu.append(obj_)
            obj_.original_tagname_ = 'cpu'
# end class cpusType


class cpuType(GeneratedsSuper):
    """name -- Unique name
    addressSpaceRef -- Indicates which address space maps into this cpu.
    parameters -- Data specific to the cpu.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('addressSpaceRef', 'addrSpaceRefType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'addressSpaceRef', 'ref': 'addressSpaceRef', 'type': 'addressSpaceRef'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, addressSpaceRef=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        if addressSpaceRef is None:
            self.addressSpaceRef = []
        else:
            self.addressSpaceRef = addressSpaceRef
        self.addressSpaceRef_nsprefix_ = None
        self.parameters = parameters
        self.parameters_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cpuType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cpuType.subclass:
            return cpuType.subclass(*args_, **kwargs_)
        else:
            return cpuType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_addressSpaceRef(self):
        return self.addressSpaceRef
    def set_addressSpaceRef(self, addressSpaceRef):
        self.addressSpaceRef = addressSpaceRef
    def add_addressSpaceRef(self, value):
        self.addressSpaceRef.append(value)
    def insert_addressSpaceRef_at(self, index, value):
        self.addressSpaceRef.insert(index, value)
    def replace_addressSpaceRef_at(self, index, value):
        self.addressSpaceRef[index] = value
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.addressSpaceRef or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='cpuType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpuType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'cpuType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cpuType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cpuType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cpuType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='cpuType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for addressSpaceRef_ in self.addressSpaceRef:
            namespaceprefix_ = self.addressSpaceRef_nsprefix_ + ':' if (UseCapturedNS_ and self.addressSpaceRef_nsprefix_) else ''
            addressSpaceRef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='addressSpaceRef', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressSpaceRef':
            class_obj_ = self.get_class_obj_(child_, addrSpaceRefType)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressSpaceRef.append(obj_)
            obj_.original_tagname_ = 'addressSpaceRef'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class cpuType


class resetTypesType(GeneratedsSuper):
    """resetType -- A user defined reset policy
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('resetType', 'resetTypeType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'resetType', 'type': 'resetTypeType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, resetType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if resetType is None:
            self.resetType = []
        else:
            self.resetType = resetType
        self.resetType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resetTypesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resetTypesType.subclass:
            return resetTypesType.subclass(*args_, **kwargs_)
        else:
            return resetTypesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_resetType(self):
        return self.resetType
    def set_resetType(self, resetType):
        self.resetType = resetType
    def add_resetType(self, value):
        self.resetType.append(value)
    def insert_resetType_at(self, index, value):
        self.resetType.insert(index, value)
    def replace_resetType_at(self, index, value):
        self.resetType[index] = value
    def _hasContent(self):
        if (
            self.resetType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='resetTypesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resetTypesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resetTypesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resetTypesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='resetTypesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='resetTypesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='resetTypesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for resetType_ in self.resetType:
            namespaceprefix_ = self.resetType_nsprefix_ + ':' if (UseCapturedNS_ and self.resetType_nsprefix_) else ''
            resetType_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='resetType', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'resetType':
            obj_ = resetTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.resetType.append(obj_)
            obj_.original_tagname_ = 'resetType'
# end class resetTypesType


class resetTypeType(GeneratedsSuper):
    """name -- Unique name
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resetTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resetTypeType.subclass:
            return resetTypeType.subclass(*args_, **kwargs_)
        else:
            return resetTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='resetTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resetTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resetTypeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resetTypeType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='resetTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='resetTypeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='resetTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class resetTypeType


class Master(GeneratedsSuper):
    """addressSpaceRef -- If this master connects to an addressable bus, this element references the address space it maps to.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('addressSpaceRef', 'addrSpaceRefType', 0, 1, {'minOccurs': '0', 'name': 'addressSpaceRef', 'type': 'addressSpaceRefType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, addressSpaceRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.addressSpaceRef = addressSpaceRef
        self.addressSpaceRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Master)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Master.subclass:
            return Master.subclass(*args_, **kwargs_)
        else:
            return Master(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_addressSpaceRef(self):
        return self.addressSpaceRef
    def set_addressSpaceRef(self, addressSpaceRef):
        self.addressSpaceRef = addressSpaceRef
    def _hasContent(self):
        if (
            self.addressSpaceRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='masterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('masterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'masterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='masterType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='masterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='masterType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='masterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.addressSpaceRef is not None:
            namespaceprefix_ = self.addressSpaceRef_nsprefix_ + ':' if (UseCapturedNS_ and self.addressSpaceRef_nsprefix_) else ''
            self.addressSpaceRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressSpaceRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'addressSpaceRef':
            obj_ = addressSpaceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressSpaceRef = obj_
            obj_.original_tagname_ = 'addressSpaceRef'
# end class Master


class addressSpaceRefType(addrSpaceRefType):
    """baseAddress -- Base of an address space.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 1, {'minOccurs': '0', 'name': 'baseAddress', 'type': 'signedLongintExpression'}, None),
    ]
    subclass = None
    superclass = addrSpaceRefType
    def __init__(self, addressSpaceRef=None, id=None, isPresent=None, baseAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("addressSpaceRefType"), self).__init__(addressSpaceRef, id, isPresent,  **kwargs_)
        self.baseAddress = baseAddress
        self.baseAddress_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressSpaceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressSpaceRefType.subclass:
            return addressSpaceRefType.subclass(*args_, **kwargs_)
        else:
            return addressSpaceRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_baseAddress(self):
        return self.baseAddress
    def set_baseAddress(self, baseAddress):
        self.baseAddress = baseAddress
    def _hasContent(self):
        if (
            self.baseAddress is not None or
            super(addressSpaceRefType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressSpaceRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressSpaceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'addressSpaceRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addressSpaceRefType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addressSpaceRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addressSpaceRefType'):
        super(addressSpaceRefType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addressSpaceRefType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressSpaceRefType', fromsubclass_=False, pretty_print=True):
        super(addressSpaceRefType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.baseAddress is not None:
            namespaceprefix_ = self.baseAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.baseAddress_nsprefix_) else ''
            self.baseAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='baseAddress', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(addressSpaceRefType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'baseAddress':
            obj_ = signedLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        super(addressSpaceRefType, self)._buildChildren(child_, node, nodeName_, True)
# end class addressSpaceRefType


class Slave(GeneratedsSuper):
    """fileSetRefGroup -- This reference is used to point the filesets that are associated with this slave port.
    Depending on the slave port function, there may be completely different software drivers associated with the different ports.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('memoryMapRef', 'memoryMapRefType', 0, 1, {'name': 'memoryMapRef', 'ref': 'memoryMapRef', 'type': 'memoryMapRef'}, 29),
        MemberSpec_('transparentBridge', 'transparentBridge', 1, 1, {'maxOccurs': 'unbounded', 'name': 'transparentBridge', 'ref': 'transparentBridge', 'type': 'transparentBridge'}, 29),
        MemberSpec_('fileSetRefGroup', 'fileSetRefGroupType19', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'fileSetRefGroup', 'type': 'fileSetRefGroupType19'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, memoryMapRef=None, transparentBridge=None, fileSetRefGroup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.memoryMapRef = memoryMapRef
        self.memoryMapRef_nsprefix_ = None
        if transparentBridge is None:
            self.transparentBridge = []
        else:
            self.transparentBridge = transparentBridge
        self.transparentBridge_nsprefix_ = None
        if fileSetRefGroup is None:
            self.fileSetRefGroup = []
        else:
            self.fileSetRefGroup = fileSetRefGroup
        self.fileSetRefGroup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Slave)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Slave.subclass:
            return Slave.subclass(*args_, **kwargs_)
        else:
            return Slave(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_memoryMapRef(self):
        return self.memoryMapRef
    def set_memoryMapRef(self, memoryMapRef):
        self.memoryMapRef = memoryMapRef
    def get_transparentBridge(self):
        return self.transparentBridge
    def set_transparentBridge(self, transparentBridge):
        self.transparentBridge = transparentBridge
    def add_transparentBridge(self, value):
        self.transparentBridge.append(value)
    def insert_transparentBridge_at(self, index, value):
        self.transparentBridge.insert(index, value)
    def replace_transparentBridge_at(self, index, value):
        self.transparentBridge[index] = value
    def get_fileSetRefGroup(self):
        return self.fileSetRefGroup
    def set_fileSetRefGroup(self, fileSetRefGroup):
        self.fileSetRefGroup = fileSetRefGroup
    def add_fileSetRefGroup(self, value):
        self.fileSetRefGroup.append(value)
    def insert_fileSetRefGroup_at(self, index, value):
        self.fileSetRefGroup.insert(index, value)
    def replace_fileSetRefGroup_at(self, index, value):
        self.fileSetRefGroup[index] = value
    def _hasContent(self):
        if (
            self.memoryMapRef is not None or
            self.transparentBridge or
            self.fileSetRefGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='slaveType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('slaveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'slaveType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='slaveType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='slaveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='slaveType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='slaveType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.memoryMapRef is not None:
            namespaceprefix_ = self.memoryMapRef_nsprefix_ + ':' if (UseCapturedNS_ and self.memoryMapRef_nsprefix_) else ''
            self.memoryMapRef.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='memoryMapRef', pretty_print=pretty_print)
        for transparentBridge_ in self.transparentBridge:
            namespaceprefix_ = self.transparentBridge_nsprefix_ + ':' if (UseCapturedNS_ and self.transparentBridge_nsprefix_) else ''
            transparentBridge_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='transparentBridge', pretty_print=pretty_print)
        for fileSetRefGroup_ in self.fileSetRefGroup:
            namespaceprefix_ = self.fileSetRefGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.fileSetRefGroup_nsprefix_) else ''
            fileSetRefGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fileSetRefGroup', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'memoryMapRef':
            obj_ = memoryMapRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.memoryMapRef = obj_
            obj_.original_tagname_ = 'memoryMapRef'
        elif nodeName_ == 'transparentBridge':
            obj_ = transparentBridge.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transparentBridge.append(obj_)
            obj_.original_tagname_ = 'transparentBridge'
        elif nodeName_ == 'fileSetRefGroup':
            obj_ = fileSetRefGroupType19.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileSetRefGroup.append(obj_)
            obj_.original_tagname_ = 'fileSetRefGroup'
# end class Slave


class fileSetRefGroupType19(GeneratedsSuper):
    """group -- Abritray name assigned to the collections of fileSets.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('group', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'group', 'type': 'xs:Name'}, None),
        MemberSpec_('fileSetRef', 'fileSetRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'fileSetRef', 'ref': 'fileSetRef', 'type': 'fileSetRef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, group=None, fileSetRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.group = group
        self.group_nsprefix_ = None
        if fileSetRef is None:
            self.fileSetRef = []
        else:
            self.fileSetRef = fileSetRef
        self.fileSetRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSetRefGroupType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSetRefGroupType19.subclass:
            return fileSetRefGroupType19.subclass(*args_, **kwargs_)
        else:
            return fileSetRefGroupType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def get_fileSetRef(self):
        return self.fileSetRef
    def set_fileSetRef(self, fileSetRef):
        self.fileSetRef = fileSetRef
    def add_fileSetRef(self, value):
        self.fileSetRef.append(value)
    def insert_fileSetRef_at(self, index, value):
        self.fileSetRef.insert(index, value)
    def replace_fileSetRef_at(self, index, value):
        self.fileSetRef[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.group is not None or
            self.fileSetRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSetRefGroupType19', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSetRefGroupType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fileSetRefGroupType19':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileSetRefGroupType19')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fileSetRefGroupType19', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fileSetRefGroupType19'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSetRefGroupType19', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
        for fileSetRef_ in self.fileSetRef:
            namespaceprefix_ = self.fileSetRef_nsprefix_ + ':' if (UseCapturedNS_ and self.fileSetRef_nsprefix_) else ''
            fileSetRef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='fileSetRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
        elif nodeName_ == 'fileSetRef':
            obj_ = fileSetRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileSetRef.append(obj_)
            obj_.original_tagname_ = 'fileSetRef'
# end class fileSetRefGroupType19


class systemType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'name': 'group', 'ref': 'group', 'type': 'xs:Name'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.group = group
        self.group_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, systemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if systemType.subclass:
            return systemType.subclass(*args_, **kwargs_)
        else:
            return systemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def _hasContent(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='systemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('systemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'systemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='systemType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='systemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='systemType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='systemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
# end class systemType


class mirroredSlaveType(GeneratedsSuper):
    """baseAddresses -- Represents a set of remap base addresses.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('baseAddresses', 'baseAddressesType', 0, 1, {'minOccurs': '0', 'name': 'baseAddresses', 'type': 'baseAddressesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, baseAddresses=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.baseAddresses = baseAddresses
        self.baseAddresses_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredSlaveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredSlaveType.subclass:
            return mirroredSlaveType.subclass(*args_, **kwargs_)
        else:
            return mirroredSlaveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_baseAddresses(self):
        return self.baseAddresses
    def set_baseAddresses(self, baseAddresses):
        self.baseAddresses = baseAddresses
    def _hasContent(self):
        if (
            self.baseAddresses is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredSlaveType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredSlaveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'mirroredSlaveType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mirroredSlaveType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='mirroredSlaveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mirroredSlaveType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredSlaveType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.baseAddresses is not None:
            namespaceprefix_ = self.baseAddresses_nsprefix_ + ':' if (UseCapturedNS_ and self.baseAddresses_nsprefix_) else ''
            self.baseAddresses.export(outfile, level, namespaceprefix_, namespacedef_='', name_='baseAddresses', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'baseAddresses':
            obj_ = baseAddressesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.baseAddresses = obj_
            obj_.original_tagname_ = 'baseAddresses'
# end class mirroredSlaveType


class baseAddressesType(GeneratedsSuper):
    """remapAddress -- Base of an address block, expressed as the number of bitsInLAU from the containing busInterface. The state attribute indicates the name of the remap state for which this address is valid.
    range -- The address range of mirrored slave, expressed as the number of bitsInLAU from the containing busInterface.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('remapAddress', 'remapAddressType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'remapAddress', 'type': 'remapAddressType'}, None),
        MemberSpec_('Range', 'unsignedPositiveLongintExpression', 0, 0, {'name': 'range', 'type': 'unsignedPositiveLongintExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, remapAddress=None, Range=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if remapAddress is None:
            self.remapAddress = []
        else:
            self.remapAddress = remapAddress
        self.remapAddress_nsprefix_ = None
        self.Range = Range
        self.Range_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseAddressesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseAddressesType.subclass:
            return baseAddressesType.subclass(*args_, **kwargs_)
        else:
            return baseAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_remapAddress(self):
        return self.remapAddress
    def set_remapAddress(self, remapAddress):
        self.remapAddress = remapAddress
    def add_remapAddress(self, value):
        self.remapAddress.append(value)
    def insert_remapAddress_at(self, index, value):
        self.remapAddress.insert(index, value)
    def replace_remapAddress_at(self, index, value):
        self.remapAddress[index] = value
    def get_range(self):
        return self.Range
    def set_range(self, Range):
        self.Range = Range
    def _hasContent(self):
        if (
            self.remapAddress or
            self.Range is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='baseAddressesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('baseAddressesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'baseAddressesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='baseAddressesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='baseAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='baseAddressesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='baseAddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remapAddress_ in self.remapAddress:
            namespaceprefix_ = self.remapAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.remapAddress_nsprefix_) else ''
            remapAddress_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='remapAddress', pretty_print=pretty_print)
        if self.Range is not None:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            self.Range.export(outfile, level, namespaceprefix_, namespacedef_='', name_='range', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'remapAddress':
            obj_ = remapAddressType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remapAddress.append(obj_)
            obj_.original_tagname_ = 'remapAddress'
        elif nodeName_ == 'range':
            obj_ = unsignedPositiveLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
# end class baseAddressesType


class mirroredMasterType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredMasterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredMasterType.subclass:
            return mirroredMasterType.subclass(*args_, **kwargs_)
        else:
            return mirroredMasterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredMasterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredMasterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'mirroredMasterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mirroredMasterType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='mirroredMasterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mirroredMasterType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredMasterType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class mirroredMasterType


class mirroredSystemType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'name': 'group', 'ref': 'group', 'type': 'xs:Name'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.group = group
        self.group_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredSystemType.subclass:
            return mirroredSystemType.subclass(*args_, **kwargs_)
        else:
            return mirroredSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def _hasContent(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredSystemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredSystemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'mirroredSystemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mirroredSystemType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='mirroredSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mirroredSystemType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
# end class mirroredSystemType


class monitorType(GeneratedsSuper):
    """group -- Indicates which system interface is being monitored. Name must match a group name present on one or more ports in the corresonding bus definition.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('interfaceMode', 'interfaceModeType', 0, 0, {'use': 'required', 'name': 'interfaceMode'}),
        MemberSpec_('group', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'group', 'ref': 'group', 'type': 'xs:Name'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, interfaceMode=None, group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.interfaceMode = _cast(None, interfaceMode)
        self.interfaceMode_nsprefix_ = None
        self.group = group
        self.group_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monitorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monitorType.subclass:
            return monitorType.subclass(*args_, **kwargs_)
        else:
            return monitorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def get_interfaceMode(self):
        return self.interfaceMode
    def set_interfaceMode(self, interfaceMode):
        self.interfaceMode = interfaceMode
    def validate_interfaceModeType(self, value):
        # Validate type interfaceModeType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['master', 'slave', 'system', 'mirroredMaster', 'mirroredSlave', 'mirroredSystem']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on interfaceModeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='monitorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monitorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'monitorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='monitorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='monitorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='monitorType'):
        if self.interfaceMode is not None and 'interfaceMode' not in already_processed:
            already_processed.add('interfaceMode')
            outfile.write(' interfaceMode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.interfaceMode), input_name='interfaceMode')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='monitorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interfaceMode', node)
        if value is not None and 'interfaceMode' not in already_processed:
            already_processed.add('interfaceMode')
            self.interfaceMode = value
            self.interfaceMode = ' '.join(self.interfaceMode.split())
            self.validate_interfaceModeType(self.interfaceMode)    # validate type interfaceModeType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
# end class monitorType


class channelType(GeneratedsSuper):
    """name -- Unique name
    busInterfaceRef -- Contains the name of one of the bus interfaces that is part of this channel. The ordering of the references may be important to the design environment.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('busInterfaceRef', 'busInterfaceRefType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '2', 'name': 'busInterfaceRef', 'type': 'busInterfaceRefType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, busInterfaceRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        if busInterfaceRef is None:
            self.busInterfaceRef = []
        else:
            self.busInterfaceRef = busInterfaceRef
        self.busInterfaceRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, channelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if channelType.subclass:
            return channelType.subclass(*args_, **kwargs_)
        else:
            return channelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_busInterfaceRef(self):
        return self.busInterfaceRef
    def set_busInterfaceRef(self, busInterfaceRef):
        self.busInterfaceRef = busInterfaceRef
    def add_busInterfaceRef(self, value):
        self.busInterfaceRef.append(value)
    def insert_busInterfaceRef_at(self, index, value):
        self.busInterfaceRef.insert(index, value)
    def replace_busInterfaceRef_at(self, index, value):
        self.busInterfaceRef[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.busInterfaceRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='channelType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('channelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'channelType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='channelType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='channelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='channelType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='channelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for busInterfaceRef_ in self.busInterfaceRef:
            namespaceprefix_ = self.busInterfaceRef_nsprefix_ + ':' if (UseCapturedNS_ and self.busInterfaceRef_nsprefix_) else ''
            busInterfaceRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='busInterfaceRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'busInterfaceRef':
            obj_ = busInterfaceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.busInterfaceRef.append(obj_)
            obj_.original_tagname_ = 'busInterfaceRef'
# end class channelType


class busInterfaceRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('localName', 'xs:Name', 0, 0, {'name': 'localName', 'type': 'xs:Name'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, localName=None, isPresent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.localName = localName
        self.localName_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, busInterfaceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if busInterfaceRefType.subclass:
            return busInterfaceRefType.subclass(*args_, **kwargs_)
        else:
            return busInterfaceRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_localName(self):
        return self.localName
    def set_localName(self, localName):
        self.localName = localName
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.localName is not None or
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='busInterfaceRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('busInterfaceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'busInterfaceRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='busInterfaceRefType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='busInterfaceRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='busInterfaceRefType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='busInterfaceRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.localName is not None:
            namespaceprefix_ = self.localName_nsprefix_ + ':' if (UseCapturedNS_ and self.localName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocalName>%s</%slocalName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.localName), input_name='localName')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'localName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'localName')
            value_ = self.gds_validate_string(value_, node, 'localName')
            self.localName = value_
            self.localName_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class busInterfaceRefType


class remapStateType(GeneratedsSuper):
    """name -- Unique name
    remapPorts -- List of ports and their values that shall invoke this remap state.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('remapPorts', 'remapPortsType', 0, 1, {'minOccurs': '0', 'name': 'remapPorts', 'type': 'remapPortsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, remapPorts=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.remapPorts = remapPorts
        self.remapPorts_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapStateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapStateType.subclass:
            return remapStateType.subclass(*args_, **kwargs_)
        else:
            return remapStateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_remapPorts(self):
        return self.remapPorts
    def set_remapPorts(self, remapPorts):
        self.remapPorts = remapPorts
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.remapPorts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapStateType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapStateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'remapStateType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='remapStateType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='remapStateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='remapStateType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapStateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.remapPorts is not None:
            namespaceprefix_ = self.remapPorts_nsprefix_ + ':' if (UseCapturedNS_ and self.remapPorts_nsprefix_) else ''
            self.remapPorts.export(outfile, level, namespaceprefix_, namespacedef_='', name_='remapPorts', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'remapPorts':
            obj_ = remapPortsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remapPorts = obj_
            obj_.original_tagname_ = 'remapPorts'
# end class remapStateType


class remapPortsType(GeneratedsSuper):
    """remapPort -- Contains the name and value of a port on the component, the value indicates the logic value which this port must take to effect the remapping. The portMapRef attribute stores the name of the port which takes that value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('remapPort', 'remapPortType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'remapPort', 'type': 'remapPortType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, remapPort=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if remapPort is None:
            self.remapPort = []
        else:
            self.remapPort = remapPort
        self.remapPort_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapPortsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapPortsType.subclass:
            return remapPortsType.subclass(*args_, **kwargs_)
        else:
            return remapPortsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_remapPort(self):
        return self.remapPort
    def set_remapPort(self, remapPort):
        self.remapPort = remapPort
    def add_remapPort(self, value):
        self.remapPort.append(value)
    def insert_remapPort_at(self, index, value):
        self.remapPort.insert(index, value)
    def replace_remapPort_at(self, index, value):
        self.remapPort[index] = value
    def _hasContent(self):
        if (
            self.remapPort
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapPortsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapPortsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'remapPortsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='remapPortsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='remapPortsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='remapPortsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapPortsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remapPort_ in self.remapPort:
            namespaceprefix_ = self.remapPort_nsprefix_ + ':' if (UseCapturedNS_ and self.remapPort_nsprefix_) else ''
            remapPort_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='remapPort', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'remapPort':
            obj_ = remapPortType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remapPort.append(obj_)
            obj_.original_tagname_ = 'remapPort'
# end class remapPortsType


class remapPortType(GeneratedsSuper):
    """portIndex -- Index for a vectored type port. Must be a number between left and right for the port.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('portRef', 'ipxact:portName', 0, 0, {'use': 'required', 'name': 'portRef'}),
        MemberSpec_('portIndex', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'name': 'portIndex', 'type': 'unsignedIntExpression'}, None),
        MemberSpec_('value', 'stringExpression', 0, 0, {'name': 'value', 'type': 'unsignedIntExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, portRef=None, portIndex=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.portRef = _cast(None, portRef)
        self.portRef_nsprefix_ = None
        self.portIndex = portIndex
        self.portIndex_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapPortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapPortType.subclass:
            return remapPortType.subclass(*args_, **kwargs_)
        else:
            return remapPortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_portIndex(self):
        return self.portIndex
    def set_portIndex(self, portIndex):
        self.portIndex = portIndex
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_portRef(self):
        return self.portRef
    def set_portRef(self, portRef):
        self.portRef = portRef
    def validate_portName(self, value):
        # Validate type ipxact:portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_portName_patterns_, ))
    validate_portName_patterns_ = [['^([A-Za-z0-9\\.\\-:_]*)$']]
    def _hasContent(self):
        if (
            self.portIndex is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapPortType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapPortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'remapPortType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='remapPortType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='remapPortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='remapPortType'):
        if self.portRef is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            outfile.write(' portRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.portRef), input_name='portRef')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapPortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.portIndex is not None:
            namespaceprefix_ = self.portIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.portIndex_nsprefix_) else ''
            self.portIndex.export(outfile, level, namespaceprefix_, namespacedef_='', name_='portIndex', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('portRef', node)
        if value is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            self.portRef = value
            self.validate_portName(self.portRef)    # validate type portName
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'portIndex':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.portIndex = obj_
            obj_.original_tagname_ = 'portIndex'
        elif nodeName_ == 'value':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class remapPortType


class masterType20(GeneratedsSuper):
    """addressSpaceRef -- If this master connects to an addressable bus, this element references the address space it maps to.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('addressSpaceRef', 'addrSpaceRefType', 0, 1, {'minOccurs': '0', 'name': 'addressSpaceRef', 'type': 'addressSpaceRefType21'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, addressSpaceRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.addressSpaceRef = addressSpaceRef
        self.addressSpaceRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, masterType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if masterType20.subclass:
            return masterType20.subclass(*args_, **kwargs_)
        else:
            return masterType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_addressSpaceRef(self):
        return self.addressSpaceRef
    def set_addressSpaceRef(self, addressSpaceRef):
        self.addressSpaceRef = addressSpaceRef
    def _hasContent(self):
        if (
            self.addressSpaceRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='masterType20', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('masterType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'masterType20':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='masterType20')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='masterType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='masterType20'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='masterType20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.addressSpaceRef is not None:
            namespaceprefix_ = self.addressSpaceRef_nsprefix_ + ':' if (UseCapturedNS_ and self.addressSpaceRef_nsprefix_) else ''
            self.addressSpaceRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressSpaceRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'addressSpaceRef':
            obj_ = addressSpaceRefType21.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressSpaceRef = obj_
            obj_.original_tagname_ = 'addressSpaceRef'
# end class masterType20


class addressSpaceRefType21(addrSpaceRefType):
    """baseAddress -- Base of an address space.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 1, {'minOccurs': '0', 'name': 'baseAddress', 'type': 'signedLongintExpression'}, None),
    ]
    subclass = None
    superclass = addrSpaceRefType
    def __init__(self, addressSpaceRef=None, id=None, isPresent=None, baseAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("addressSpaceRefType21"), self).__init__(addressSpaceRef, id, isPresent,  **kwargs_)
        self.baseAddress = baseAddress
        self.baseAddress_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressSpaceRefType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressSpaceRefType21.subclass:
            return addressSpaceRefType21.subclass(*args_, **kwargs_)
        else:
            return addressSpaceRefType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_baseAddress(self):
        return self.baseAddress
    def set_baseAddress(self, baseAddress):
        self.baseAddress = baseAddress
    def _hasContent(self):
        if (
            self.baseAddress is not None or
            super(addressSpaceRefType21, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressSpaceRefType21', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressSpaceRefType21')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'addressSpaceRefType21':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addressSpaceRefType21')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addressSpaceRefType21', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addressSpaceRefType21'):
        super(addressSpaceRefType21, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addressSpaceRefType21')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressSpaceRefType21', fromsubclass_=False, pretty_print=True):
        super(addressSpaceRefType21, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.baseAddress is not None:
            namespaceprefix_ = self.baseAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.baseAddress_nsprefix_) else ''
            self.baseAddress.export(outfile, level, namespaceprefix_, namespacedef_='', name_='baseAddress', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(addressSpaceRefType21, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'baseAddress':
            obj_ = signedLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        super(addressSpaceRefType21, self)._buildChildren(child_, node, nodeName_, True)
# end class addressSpaceRefType21


class slaveType22(GeneratedsSuper):
    """fileSetRefGroup -- This reference is used to point the filesets that are associated with this slave port.
    Depending on the slave port function, there may be completely different software drivers associated with the different ports.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('memoryMapRef', 'memoryMapRefType', 0, 1, {'name': 'memoryMapRef', 'ref': 'memoryMapRef', 'type': 'memoryMapRef'}, 30),
        MemberSpec_('transparentBridge', 'transparentBridge', 1, 1, {'maxOccurs': 'unbounded', 'name': 'transparentBridge', 'ref': 'transparentBridge', 'type': 'transparentBridge'}, 30),
        MemberSpec_('fileSetRefGroup', 'fileSetRefGroupType23', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'fileSetRefGroup', 'type': 'fileSetRefGroupType23'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, memoryMapRef=None, transparentBridge=None, fileSetRefGroup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.memoryMapRef = memoryMapRef
        self.memoryMapRef_nsprefix_ = None
        if transparentBridge is None:
            self.transparentBridge = []
        else:
            self.transparentBridge = transparentBridge
        self.transparentBridge_nsprefix_ = None
        if fileSetRefGroup is None:
            self.fileSetRefGroup = []
        else:
            self.fileSetRefGroup = fileSetRefGroup
        self.fileSetRefGroup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, slaveType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if slaveType22.subclass:
            return slaveType22.subclass(*args_, **kwargs_)
        else:
            return slaveType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_memoryMapRef(self):
        return self.memoryMapRef
    def set_memoryMapRef(self, memoryMapRef):
        self.memoryMapRef = memoryMapRef
    def get_transparentBridge(self):
        return self.transparentBridge
    def set_transparentBridge(self, transparentBridge):
        self.transparentBridge = transparentBridge
    def add_transparentBridge(self, value):
        self.transparentBridge.append(value)
    def insert_transparentBridge_at(self, index, value):
        self.transparentBridge.insert(index, value)
    def replace_transparentBridge_at(self, index, value):
        self.transparentBridge[index] = value
    def get_fileSetRefGroup(self):
        return self.fileSetRefGroup
    def set_fileSetRefGroup(self, fileSetRefGroup):
        self.fileSetRefGroup = fileSetRefGroup
    def add_fileSetRefGroup(self, value):
        self.fileSetRefGroup.append(value)
    def insert_fileSetRefGroup_at(self, index, value):
        self.fileSetRefGroup.insert(index, value)
    def replace_fileSetRefGroup_at(self, index, value):
        self.fileSetRefGroup[index] = value
    def _hasContent(self):
        if (
            self.memoryMapRef is not None or
            self.transparentBridge or
            self.fileSetRefGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='slaveType22', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('slaveType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'slaveType22':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='slaveType22')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='slaveType22', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='slaveType22'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='slaveType22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.memoryMapRef is not None:
            namespaceprefix_ = self.memoryMapRef_nsprefix_ + ':' if (UseCapturedNS_ and self.memoryMapRef_nsprefix_) else ''
            self.memoryMapRef.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='memoryMapRef', pretty_print=pretty_print)
        for transparentBridge_ in self.transparentBridge:
            namespaceprefix_ = self.transparentBridge_nsprefix_ + ':' if (UseCapturedNS_ and self.transparentBridge_nsprefix_) else ''
            transparentBridge_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='transparentBridge', pretty_print=pretty_print)
        for fileSetRefGroup_ in self.fileSetRefGroup:
            namespaceprefix_ = self.fileSetRefGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.fileSetRefGroup_nsprefix_) else ''
            fileSetRefGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fileSetRefGroup', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'memoryMapRef':
            obj_ = memoryMapRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.memoryMapRef = obj_
            obj_.original_tagname_ = 'memoryMapRef'
        elif nodeName_ == 'transparentBridge':
            obj_ = transparentBridge.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transparentBridge.append(obj_)
            obj_.original_tagname_ = 'transparentBridge'
        elif nodeName_ == 'fileSetRefGroup':
            obj_ = fileSetRefGroupType23.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileSetRefGroup.append(obj_)
            obj_.original_tagname_ = 'fileSetRefGroup'
# end class slaveType22


class fileSetRefGroupType23(GeneratedsSuper):
    """group -- Abritray name assigned to the collections of fileSets.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('group', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'group', 'type': 'xs:Name'}, None),
        MemberSpec_('fileSetRef', 'fileSetRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'fileSetRef', 'ref': 'fileSetRef', 'type': 'fileSetRef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, group=None, fileSetRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.group = group
        self.group_nsprefix_ = None
        if fileSetRef is None:
            self.fileSetRef = []
        else:
            self.fileSetRef = fileSetRef
        self.fileSetRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSetRefGroupType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSetRefGroupType23.subclass:
            return fileSetRefGroupType23.subclass(*args_, **kwargs_)
        else:
            return fileSetRefGroupType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def get_fileSetRef(self):
        return self.fileSetRef
    def set_fileSetRef(self, fileSetRef):
        self.fileSetRef = fileSetRef
    def add_fileSetRef(self, value):
        self.fileSetRef.append(value)
    def insert_fileSetRef_at(self, index, value):
        self.fileSetRef.insert(index, value)
    def replace_fileSetRef_at(self, index, value):
        self.fileSetRef[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.group is not None or
            self.fileSetRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSetRefGroupType23', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSetRefGroupType23')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'fileSetRefGroupType23':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fileSetRefGroupType23')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fileSetRefGroupType23', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fileSetRefGroupType23'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='fileSetRefGroupType23', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
        for fileSetRef_ in self.fileSetRef:
            namespaceprefix_ = self.fileSetRef_nsprefix_ + ':' if (UseCapturedNS_ and self.fileSetRef_nsprefix_) else ''
            fileSetRef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='fileSetRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
        elif nodeName_ == 'fileSetRef':
            obj_ = fileSetRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.fileSetRef.append(obj_)
            obj_.original_tagname_ = 'fileSetRef'
# end class fileSetRefGroupType23


class systemType24(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'name': 'group', 'ref': 'group', 'type': 'xs:Name'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.group = group
        self.group_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, systemType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if systemType24.subclass:
            return systemType24.subclass(*args_, **kwargs_)
        else:
            return systemType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def _hasContent(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='systemType24', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('systemType24')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'systemType24':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='systemType24')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='systemType24', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='systemType24'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='systemType24', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
# end class systemType24


class mirroredSlaveType25(GeneratedsSuper):
    """baseAddresses -- Represents a set of remap base addresses.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('baseAddresses', 'baseAddressesType26', 0, 1, {'minOccurs': '0', 'name': 'baseAddresses', 'type': 'baseAddressesType26'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, baseAddresses=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.baseAddresses = baseAddresses
        self.baseAddresses_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredSlaveType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredSlaveType25.subclass:
            return mirroredSlaveType25.subclass(*args_, **kwargs_)
        else:
            return mirroredSlaveType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_baseAddresses(self):
        return self.baseAddresses
    def set_baseAddresses(self, baseAddresses):
        self.baseAddresses = baseAddresses
    def _hasContent(self):
        if (
            self.baseAddresses is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredSlaveType25', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredSlaveType25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'mirroredSlaveType25':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mirroredSlaveType25')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='mirroredSlaveType25', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mirroredSlaveType25'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredSlaveType25', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.baseAddresses is not None:
            namespaceprefix_ = self.baseAddresses_nsprefix_ + ':' if (UseCapturedNS_ and self.baseAddresses_nsprefix_) else ''
            self.baseAddresses.export(outfile, level, namespaceprefix_, namespacedef_='', name_='baseAddresses', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'baseAddresses':
            obj_ = baseAddressesType26.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.baseAddresses = obj_
            obj_.original_tagname_ = 'baseAddresses'
# end class mirroredSlaveType25


class baseAddressesType26(GeneratedsSuper):
    """remapAddress -- Base of an address block, expressed as the number of bitsInLAU from the containing busInterface. The state attribute indicates the name of the remap state for which this address is valid.
    range -- The address range of mirrored slave, expressed as the number of bitsInLAU from the containing busInterface.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('remapAddress', 'remapAddressType27', 1, 0, {'maxOccurs': 'unbounded', 'name': 'remapAddress', 'type': 'remapAddressType27'}, None),
        MemberSpec_('Range', 'unsignedPositiveLongintExpression', 0, 0, {'name': 'range', 'type': 'unsignedPositiveLongintExpression'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, remapAddress=None, Range=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if remapAddress is None:
            self.remapAddress = []
        else:
            self.remapAddress = remapAddress
        self.remapAddress_nsprefix_ = None
        self.Range = Range
        self.Range_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseAddressesType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseAddressesType26.subclass:
            return baseAddressesType26.subclass(*args_, **kwargs_)
        else:
            return baseAddressesType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_remapAddress(self):
        return self.remapAddress
    def set_remapAddress(self, remapAddress):
        self.remapAddress = remapAddress
    def add_remapAddress(self, value):
        self.remapAddress.append(value)
    def insert_remapAddress_at(self, index, value):
        self.remapAddress.insert(index, value)
    def replace_remapAddress_at(self, index, value):
        self.remapAddress[index] = value
    def get_range(self):
        return self.Range
    def set_range(self, Range):
        self.Range = Range
    def _hasContent(self):
        if (
            self.remapAddress or
            self.Range is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='baseAddressesType26', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('baseAddressesType26')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'baseAddressesType26':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='baseAddressesType26')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='baseAddressesType26', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='baseAddressesType26'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='baseAddressesType26', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remapAddress_ in self.remapAddress:
            namespaceprefix_ = self.remapAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.remapAddress_nsprefix_) else ''
            remapAddress_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='remapAddress', pretty_print=pretty_print)
        if self.Range is not None:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            self.Range.export(outfile, level, namespaceprefix_, namespacedef_='', name_='range', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'remapAddress':
            obj_ = remapAddressType27.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.remapAddress.append(obj_)
            obj_.original_tagname_ = 'remapAddress'
        elif nodeName_ == 'range':
            obj_ = unsignedPositiveLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
# end class baseAddressesType26


class mirroredMasterType28(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredMasterType28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredMasterType28.subclass:
            return mirroredMasterType28.subclass(*args_, **kwargs_)
        else:
            return mirroredMasterType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredMasterType28', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredMasterType28')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'mirroredMasterType28':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mirroredMasterType28')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='mirroredMasterType28', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mirroredMasterType28'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredMasterType28', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class mirroredMasterType28


class mirroredSystemType29(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'name': 'group', 'ref': 'group', 'type': 'xs:Name'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.group = group
        self.group_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredSystemType29)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredSystemType29.subclass:
            return mirroredSystemType29.subclass(*args_, **kwargs_)
        else:
            return mirroredSystemType29(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def _hasContent(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredSystemType29', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredSystemType29')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'mirroredSystemType29':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mirroredSystemType29')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='mirroredSystemType29', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mirroredSystemType29'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredSystemType29', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
# end class mirroredSystemType29


class monitorType30(GeneratedsSuper):
    """group -- Indicates which system interface is being monitored. Name must match a group name present on one or more ports in the corresonding bus definition.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('interfaceMode', 'interfaceModeType31', 0, 0, {'use': 'required', 'name': 'interfaceMode'}),
        MemberSpec_('group', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'group', 'ref': 'group', 'type': 'xs:Name'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, interfaceMode=None, group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.interfaceMode = _cast(None, interfaceMode)
        self.interfaceMode_nsprefix_ = None
        self.group = group
        self.group_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monitorType30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monitorType30.subclass:
            return monitorType30.subclass(*args_, **kwargs_)
        else:
            return monitorType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def get_interfaceMode(self):
        return self.interfaceMode
    def set_interfaceMode(self, interfaceMode):
        self.interfaceMode = interfaceMode
    def validate_interfaceModeType31(self, value):
        # Validate type interfaceModeType31, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['master', 'slave', 'system', 'mirroredMaster', 'mirroredSlave', 'mirroredSystem']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on interfaceModeType31' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='monitorType30', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monitorType30')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'monitorType30':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='monitorType30')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='monitorType30', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='monitorType30'):
        if self.interfaceMode is not None and 'interfaceMode' not in already_processed:
            already_processed.add('interfaceMode')
            outfile.write(' interfaceMode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.interfaceMode), input_name='interfaceMode')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='monitorType30', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interfaceMode', node)
        if value is not None and 'interfaceMode' not in already_processed:
            already_processed.add('interfaceMode')
            self.interfaceMode = value
            self.interfaceMode = ' '.join(self.interfaceMode.split())
            self.validate_interfaceModeType31(self.interfaceMode)    # validate type interfaceModeType31
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
# end class monitorType30


class systemType32(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'name': 'group', 'ref': 'group', 'type': 'xs:Name'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.group = group
        self.group_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, systemType32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if systemType32.subclass:
            return systemType32.subclass(*args_, **kwargs_)
        else:
            return systemType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def _hasContent(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='systemType32', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('systemType32')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'systemType32':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='systemType32')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='systemType32', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='systemType32'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='systemType32', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
# end class systemType32


class mirroredSystemType33(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'name': 'group', 'ref': 'group', 'type': 'xs:Name'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.group = group
        self.group_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredSystemType33)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredSystemType33.subclass:
            return mirroredSystemType33.subclass(*args_, **kwargs_)
        else:
            return mirroredSystemType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def _hasContent(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredSystemType33', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredSystemType33')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'mirroredSystemType33':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mirroredSystemType33')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='mirroredSystemType33', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mirroredSystemType33'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='mirroredSystemType33', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
# end class mirroredSystemType33


class AbstractionType(GeneratedsSuper):
    """viewRef -- A reference to a view name in the file for which this type applies.
    abstractionRef -- Provides the VLNV of the abstraction type.
    portMaps -- Listing of maps between component ports and bus ports.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'viewRef', 'ref': 'viewRef', 'type': 'viewRef'}, None),
        MemberSpec_('abstractionRef', 'configurableLibraryRefType', 0, 0, {'name': 'abstractionRef', 'type': 'configurableLibraryRefType'}, None),
        MemberSpec_('portMaps', 'portMapsType', 0, 1, {'minOccurs': '0', 'name': 'portMaps', 'type': 'portMapsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, viewRef=None, abstractionRef=None, portMaps=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.viewRef_nsprefix_ = None
        self.abstractionRef = abstractionRef
        self.abstractionRef_nsprefix_ = None
        self.portMaps = portMaps
        self.portMaps_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractionType.subclass:
            return AbstractionType.subclass(*args_, **kwargs_)
        else:
            return AbstractionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_viewRef(self):
        return self.viewRef
    def set_viewRef(self, viewRef):
        self.viewRef = viewRef
    def add_viewRef(self, value):
        self.viewRef.append(value)
    def insert_viewRef_at(self, index, value):
        self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value):
        self.viewRef[index] = value
    def get_abstractionRef(self):
        return self.abstractionRef
    def set_abstractionRef(self, abstractionRef):
        self.abstractionRef = abstractionRef
    def get_portMaps(self):
        return self.portMaps
    def set_portMaps(self, portMaps):
        self.portMaps = portMaps
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.viewRef or
            self.abstractionRef is not None or
            self.portMaps is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractionTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractionTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractionTypeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractionTypeType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractionTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='abstractionTypeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractionTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for viewRef_ in self.viewRef:
            namespaceprefix_ = self.viewRef_nsprefix_ + ':' if (UseCapturedNS_ and self.viewRef_nsprefix_) else ''
            viewRef_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='viewRef', pretty_print=pretty_print)
        if self.abstractionRef is not None:
            namespaceprefix_ = self.abstractionRef_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractionRef_nsprefix_) else ''
            self.abstractionRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstractionRef', pretty_print=pretty_print)
        if self.portMaps is not None:
            namespaceprefix_ = self.portMaps_nsprefix_ + ':' if (UseCapturedNS_ and self.portMaps_nsprefix_) else ''
            self.portMaps.export(outfile, level, namespaceprefix_, namespacedef_='', name_='portMaps', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'viewRef':
            obj_ = viewRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
        elif nodeName_ == 'abstractionRef':
            obj_ = ConfigurableLibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractionRef = obj_
            obj_.original_tagname_ = 'abstractionRef'
        elif nodeName_ == 'portMaps':
            obj_ = PortMaps.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.portMaps = obj_
            obj_.original_tagname_ = 'portMaps'
# end class AbstractionType


class PortMaps(GeneratedsSuper):
    """portMap -- Maps a component's port to a port in a bus description. This is the logical to physical mapping. The logical pin comes from the bus interface and the physical pin from the component.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('portMap', 'portMapType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'portMap', 'type': 'portMapType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, portMap=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if portMap is None:
            self.portMap = []
        else:
            self.portMap = portMap
        self.portMap_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortMaps)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortMaps.subclass:
            return PortMaps.subclass(*args_, **kwargs_)
        else:
            return PortMaps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_portMap(self):
        return self.portMap
    def set_portMap(self, portMap):
        self.portMap = portMap
    def add_portMap(self, value):
        self.portMap.append(value)
    def insert_portMap_at(self, index, value):
        self.portMap.insert(index, value)
    def replace_portMap_at(self, index, value):
        self.portMap[index] = value
    def _hasContent(self):
        if (
            self.portMap
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portMapsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portMapsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'portMapsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='portMapsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='portMapsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='portMapsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portMapsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for portMap_ in self.portMap:
            namespaceprefix_ = self.portMap_nsprefix_ + ':' if (UseCapturedNS_ and self.portMap_nsprefix_) else ''
            portMap_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='portMap', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'portMap':
            obj_ = PortMap.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.portMap.append(obj_)
            obj_.original_tagname_ = 'portMap'
# end class PortMaps


class PortMap(GeneratedsSuper):
    """logicalPort -- Logical port from abstraction definition
    physicalPort -- Physical port from this component
    logicalTieOff -- Identifies a value to tie this logical port to.
    isInformative -- When true, indicates that this portMap element is for information purpose only.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('invert', 'xs:string', 0, 1, {'use': 'optional', 'name': 'invert'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('logicalPort', 'logicalPortType', 0, 0, {'name': 'logicalPort', 'type': 'logicalPortType'}, None),
        MemberSpec_('physicalPort', 'physicalPortType', 0, 0, {'name': 'physicalPort', 'type': 'physicalPortType'}, 31),
        MemberSpec_('logicalTieOff', 'unsignedPositiveIntExpression', 0, 0, {'name': 'logicalTieOff', 'type': 'unsignedPositiveIntExpression'}, 31),
        MemberSpec_('isInformative', 'xs:boolean', 0, 1, {'default': 'false', 'minOccurs': '0', 'name': 'isInformative', 'type': 'xs:boolean'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, invert='false', id=None, isPresent=None, logicalPort=None, physicalPort=None, logicalTieOff=None, isInformative=False, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.invert = _cast(None, invert)
        self.invert_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        self.logicalPort = logicalPort
        self.logicalPort_nsprefix_ = None
        self.physicalPort = physicalPort
        self.physicalPort_nsprefix_ = None
        self.logicalTieOff = logicalTieOff
        self.logicalTieOff_nsprefix_ = None
        self.isInformative = isInformative
        self.isInformative_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortMap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortMap.subclass:
            return PortMap.subclass(*args_, **kwargs_)
        else:
            return PortMap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_logicalPort(self):
        return self.logicalPort
    def set_logicalPort(self, logicalPort):
        self.logicalPort = logicalPort
    def get_physicalPort(self):
        return self.physicalPort
    def set_physicalPort(self, physicalPort):
        self.physicalPort = physicalPort
    def get_logicalTieOff(self):
        return self.logicalTieOff
    def set_logicalTieOff(self, logicalTieOff):
        self.logicalTieOff = logicalTieOff
    def get_isInformative(self):
        return self.isInformative
    def set_isInformative(self, isInformative):
        self.isInformative = isInformative
    def get_invert(self):
        return self.invert
    def set_invert(self, invert):
        self.invert = invert
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.isPresent is not None or
            self.logicalPort is not None or
            self.physicalPort is not None or
            self.logicalTieOff is not None or
            self.isInformative
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portMapType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portMapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'portMapType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='portMapType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='portMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='portMapType'):
        if self.invert != "false" and 'invert' not in already_processed:
            already_processed.add('invert')
            outfile.write(' invert=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.invert), input_name='invert')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.logicalPort is not None:
            namespaceprefix_ = self.logicalPort_nsprefix_ + ':' if (UseCapturedNS_ and self.logicalPort_nsprefix_) else ''
            self.logicalPort.export(outfile, level, namespaceprefix_, namespacedef_='', name_='logicalPort', pretty_print=pretty_print)
        if self.physicalPort is not None:
            namespaceprefix_ = self.physicalPort_nsprefix_ + ':' if (UseCapturedNS_ and self.physicalPort_nsprefix_) else ''
            self.physicalPort.export(outfile, level, namespaceprefix_, namespacedef_='', name_='physicalPort', pretty_print=pretty_print)
        if self.logicalTieOff is not None:
            namespaceprefix_ = self.logicalTieOff_nsprefix_ + ':' if (UseCapturedNS_ and self.logicalTieOff_nsprefix_) else ''
            self.logicalTieOff.export(outfile, level, namespaceprefix_, namespacedef_='', name_='logicalTieOff', pretty_print=pretty_print)
        if self.isInformative:
            namespaceprefix_ = self.isInformative_nsprefix_ + ':' if (UseCapturedNS_ and self.isInformative_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisInformative>%s</%sisInformative>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isInformative, input_name='isInformative'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('invert', node)
        if value is not None and 'invert' not in already_processed:
            already_processed.add('invert')
            self.invert = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'logicalPort':
            obj_ = LogicalPort.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.logicalPort = obj_
            obj_.original_tagname_ = 'logicalPort'
        elif nodeName_ == 'physicalPort':
            obj_ = PhysicalPort.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.physicalPort = obj_
            obj_.original_tagname_ = 'physicalPort'
        elif nodeName_ == 'logicalTieOff':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.logicalTieOff = obj_
            obj_.original_tagname_ = 'logicalTieOff'
        elif nodeName_ == 'isInformative':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isInformative')
            ival_ = self.gds_validate_boolean(ival_, node, 'isInformative')
            self.isInformative = ival_
            self.isInformative_nsprefix_ = child_.prefix
# end class PortMap


class LogicalPort(GeneratedsSuper):
    """name -- Bus port name as specified inside the abstraction definition
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('Range', 'range', 0, 1, {'minOccurs': '0', 'name': 'range', 'ref': 'range', 'type': 'range'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, Range=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.Range = Range
        self.Range_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalPort.subclass:
            return LogicalPort.subclass(*args_, **kwargs_)
        else:
            return LogicalPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_range(self):
        return self.Range
    def set_range(self, Range):
        self.Range = Range
    def _hasContent(self):
        if (
            self.name is not None or
            self.Range is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='logicalPortType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('logicalPortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'logicalPortType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='logicalPortType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='logicalPortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='logicalPortType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='logicalPortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.Range is not None:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            self.Range.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='range', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'range':
            obj_ = Range.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
# end class LogicalPort


class PhysicalPort(GeneratedsSuper):
    """name -- Component port name as specified inside the model port section
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', ['portName', 'xs:string'], 0, 0, {'name': 'name', 'type': 'xs:string'}, None),
        MemberSpec_('PartSelect', 'partSelect', 0, 1, {'minOccurs': '0', 'name': 'partSelect', 'ref': 'partSelect', 'type': 'partSelect'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, PartSelect=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.validate_portName(self.name)
        self.name_nsprefix_ = None
        self.PartSelect = PartSelect
        self.PartSelect_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalPort.subclass:
            return PhysicalPort.subclass(*args_, **kwargs_)
        else:
            return PhysicalPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_partSelect(self):
        return self.PartSelect
    def set_partSelect(self, PartSelect):
        self.PartSelect = PartSelect
    def validate_portName(self, value):
        result = True
        # Validate type portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_portName_patterns_, ))
                result = False
        return result
    validate_portName_patterns_ = [['^([A-Za-z0-9\\.\\-:_]*)$']]
    def _hasContent(self):
        if (
            self.name is not None or
            self.PartSelect is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='physicalPortType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('physicalPortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'physicalPortType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='physicalPortType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='physicalPortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='physicalPortType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='physicalPortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.PartSelect is not None:
            namespaceprefix_ = self.PartSelect_nsprefix_ + ':' if (UseCapturedNS_ and self.PartSelect_nsprefix_) else ''
            self.PartSelect.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='partSelect', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
            # validate type portName
            self.validate_portName(self.name)
        elif nodeName_ == 'partSelect':
            obj_ = PartSelect.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PartSelect = obj_
            obj_.original_tagname_ = 'partSelect'
# end class PhysicalPort


class Ports(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('port', 'portType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'port', 'type': 'portType35'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, port=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if port is None:
            self.port = []
        else:
            self.port = port
        self.port_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Ports)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Ports.subclass:
            return Ports.subclass(*args_, **kwargs_)
        else:
            return Ports(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    def add_port(self, value):
        self.port.append(value)
    def insert_port_at(self, index, value):
        self.port.insert(index, value)
    def replace_port_at(self, index, value):
        self.port[index] = value
    def _hasContent(self):
        if (
            self.port
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'portsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='portsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='portsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='portsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for port_ in self.port:
            namespaceprefix_ = self.port_nsprefix_ + ':' if (UseCapturedNS_ and self.port_nsprefix_) else ''
            port_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='port', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'port':
            obj_ = portType35.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.port.append(obj_)
            obj_.original_tagname_ = 'port'
# end class Ports


class portType35(GeneratedsSuper):
    """logicalName -- The assigned name of this port in bus specifications.
    wire -- A port that carries logic or an array of logic values
    transactional -- A port that carries complex information modeled at a high level of abstraction.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('logicalName', 'xs:Name', 0, 0, {'name': 'logicalName', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('wire', 'wireType', 0, 0, {'name': 'wire', 'type': 'wireType'}, 32),
        MemberSpec_('transactional', 'transactionalType', 0, 0, {'name': 'transactional', 'type': 'transactionalType'}, 32),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, isPresent=None, logicalName=None, displayName=None, description=None, wire=None, transactional=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        self.logicalName = logicalName
        self.logicalName_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.wire = wire
        self.wire_nsprefix_ = None
        self.transactional = transactional
        self.transactional_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portType35)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portType35.subclass:
            return portType35.subclass(*args_, **kwargs_)
        else:
            return portType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_logicalName(self):
        return self.logicalName
    def set_logicalName(self, logicalName):
        self.logicalName = logicalName
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_wire(self):
        return self.wire
    def set_wire(self, wire):
        self.wire = wire
    def get_transactional(self):
        return self.transactional
    def set_transactional(self, transactional):
        self.transactional = transactional
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.isPresent is not None or
            self.logicalName is not None or
            self.displayName is not None or
            self.description is not None or
            self.wire is not None or
            self.transactional is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portType35', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portType35')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'portType35':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='portType35')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='portType35', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='portType35'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portType35', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.logicalName is not None:
            namespaceprefix_ = self.logicalName_nsprefix_ + ':' if (UseCapturedNS_ and self.logicalName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogicalName>%s</%slogicalName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.logicalName), input_name='logicalName')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.wire is not None:
            namespaceprefix_ = self.wire_nsprefix_ + ':' if (UseCapturedNS_ and self.wire_nsprefix_) else ''
            self.wire.export(outfile, level, namespaceprefix_, namespacedef_='', name_='wire', pretty_print=pretty_print)
        if self.transactional is not None:
            namespaceprefix_ = self.transactional_nsprefix_ + ':' if (UseCapturedNS_ and self.transactional_nsprefix_) else ''
            self.transactional.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transactional', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'logicalName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'logicalName')
            value_ = self.gds_validate_string(value_, node, 'logicalName')
            self.logicalName = value_
            self.logicalName_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'wire':
            obj_ = wireType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.wire = obj_
            obj_.original_tagname_ = 'wire'
        elif nodeName_ == 'transactional':
            obj_ = transactionalType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.transactional = obj_
            obj_.original_tagname_ = 'transactional'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class portType35


class wireType(GeneratedsSuper):
    """qualifier -- The type of information this port carries A wire port can carry both address and data, but may not mix this with a clock or reset
    onSystem -- Defines constraints for this port when present in a system bus interface with a matching group name.
    onMaster -- Defines constraints for this port when present in a master bus interface.
    onSlave -- Defines constraints for this port when present in a slave bus interface.
    defaultValue -- Indicates the default value for this wire port.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('qualifier', 'qualifierType', 0, 1, {'minOccurs': '0', 'name': 'qualifier', 'type': 'qualifierType'}, None),
        MemberSpec_('onSystem', 'onSystemType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'onSystem', 'type': 'onSystemType'}, None),
        MemberSpec_('onMaster', 'onMasterType', 0, 1, {'minOccurs': '0', 'name': 'onMaster', 'type': 'onMasterType'}, None),
        MemberSpec_('onSlave', 'onSlaveType', 0, 1, {'minOccurs': '0', 'name': 'onSlave', 'type': 'onSlaveType'}, None),
        MemberSpec_('defaultValue', 'unsignedBitVectorExpression', 0, 1, {'name': 'defaultValue', 'type': 'unsignedBitVectorExpression'}, 33),
        MemberSpec_('requiresDriver', 'requiresDriver', 0, 1, {'name': 'requiresDriver', 'ref': 'requiresDriver', 'type': 'requiresDriver'}, 33),
    ]
    subclass = None
    superclass = None
    def __init__(self, qualifier=None, onSystem=None, onMaster=None, onSlave=None, defaultValue=None, requiresDriver=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        if onSystem is None:
            self.onSystem = []
        else:
            self.onSystem = onSystem
        self.onSystem_nsprefix_ = None
        self.onMaster = onMaster
        self.onMaster_nsprefix_ = None
        self.onSlave = onSlave
        self.onSlave_nsprefix_ = None
        self.defaultValue = defaultValue
        self.defaultValue_nsprefix_ = None
        self.requiresDriver = requiresDriver
        self.requiresDriver_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, wireType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if wireType.subclass:
            return wireType.subclass(*args_, **kwargs_)
        else:
            return wireType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def get_onSystem(self):
        return self.onSystem
    def set_onSystem(self, onSystem):
        self.onSystem = onSystem
    def add_onSystem(self, value):
        self.onSystem.append(value)
    def insert_onSystem_at(self, index, value):
        self.onSystem.insert(index, value)
    def replace_onSystem_at(self, index, value):
        self.onSystem[index] = value
    def get_onMaster(self):
        return self.onMaster
    def set_onMaster(self, onMaster):
        self.onMaster = onMaster
    def get_onSlave(self):
        return self.onSlave
    def set_onSlave(self, onSlave):
        self.onSlave = onSlave
    def get_defaultValue(self):
        return self.defaultValue
    def set_defaultValue(self, defaultValue):
        self.defaultValue = defaultValue
    def get_requiresDriver(self):
        return self.requiresDriver
    def set_requiresDriver(self, requiresDriver):
        self.requiresDriver = requiresDriver
    def _hasContent(self):
        if (
            self.qualifier is not None or
            self.onSystem or
            self.onMaster is not None or
            self.onSlave is not None or
            self.defaultValue is not None or
            self.requiresDriver is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='wireType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('wireType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'wireType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='wireType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='wireType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='wireType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='wireType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qualifier is not None:
            namespaceprefix_ = self.qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.qualifier_nsprefix_) else ''
            self.qualifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='qualifier', pretty_print=pretty_print)
        for onSystem_ in self.onSystem:
            namespaceprefix_ = self.onSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.onSystem_nsprefix_) else ''
            onSystem_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='onSystem', pretty_print=pretty_print)
        if self.onMaster is not None:
            namespaceprefix_ = self.onMaster_nsprefix_ + ':' if (UseCapturedNS_ and self.onMaster_nsprefix_) else ''
            self.onMaster.export(outfile, level, namespaceprefix_, namespacedef_='', name_='onMaster', pretty_print=pretty_print)
        if self.onSlave is not None:
            namespaceprefix_ = self.onSlave_nsprefix_ + ':' if (UseCapturedNS_ and self.onSlave_nsprefix_) else ''
            self.onSlave.export(outfile, level, namespaceprefix_, namespacedef_='', name_='onSlave', pretty_print=pretty_print)
        if self.defaultValue is not None:
            namespaceprefix_ = self.defaultValue_nsprefix_ + ':' if (UseCapturedNS_ and self.defaultValue_nsprefix_) else ''
            self.defaultValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='defaultValue', pretty_print=pretty_print)
        if self.requiresDriver is not None:
            namespaceprefix_ = self.requiresDriver_nsprefix_ + ':' if (UseCapturedNS_ and self.requiresDriver_nsprefix_) else ''
            self.requiresDriver.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='requiresDriver', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'qualifier':
            obj_ = qualifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.qualifier = obj_
            obj_.original_tagname_ = 'qualifier'
        elif nodeName_ == 'onSystem':
            obj_ = onSystemType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.onSystem.append(obj_)
            obj_.original_tagname_ = 'onSystem'
        elif nodeName_ == 'onMaster':
            obj_ = onMasterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.onMaster = obj_
            obj_.original_tagname_ = 'onMaster'
        elif nodeName_ == 'onSlave':
            obj_ = onSlaveType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.onSlave = obj_
            obj_.original_tagname_ = 'onSlave'
        elif nodeName_ == 'defaultValue':
            obj_ = unsignedBitVectorExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.defaultValue = obj_
            obj_.original_tagname_ = 'defaultValue'
        elif nodeName_ == 'requiresDriver':
            obj_ = requiresDriver.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.requiresDriver = obj_
            obj_.original_tagname_ = 'requiresDriver'
# end class wireType


class qualifierType(GeneratedsSuper):
    """isAddress -- If this element is present, the port contains address information.
    isData -- If this element is present, the port contains data information.
    isClock -- If this element is present, the port contains only clock information.
    isReset -- Is this element is present, the port contains only reset information.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('isAddress', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isAddress', 'type': 'xs:boolean'}, 34),
        MemberSpec_('isData', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isData', 'type': 'xs:boolean'}, 34),
        MemberSpec_('isClock', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isClock', 'type': 'xs:boolean'}, 34),
        MemberSpec_('isReset', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isReset', 'type': 'xs:boolean'}, 34),
    ]
    subclass = None
    superclass = None
    def __init__(self, isAddress=None, isData=None, isClock=None, isReset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.isAddress = isAddress
        self.isAddress_nsprefix_ = None
        self.isData = isData
        self.isData_nsprefix_ = None
        self.isClock = isClock
        self.isClock_nsprefix_ = None
        self.isReset = isReset
        self.isReset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qualifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qualifierType.subclass:
            return qualifierType.subclass(*args_, **kwargs_)
        else:
            return qualifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isAddress(self):
        return self.isAddress
    def set_isAddress(self, isAddress):
        self.isAddress = isAddress
    def get_isData(self):
        return self.isData
    def set_isData(self, isData):
        self.isData = isData
    def get_isClock(self):
        return self.isClock
    def set_isClock(self, isClock):
        self.isClock = isClock
    def get_isReset(self):
        return self.isReset
    def set_isReset(self, isReset):
        self.isReset = isReset
    def _hasContent(self):
        if (
            self.isAddress is not None or
            self.isData is not None or
            self.isClock is not None or
            self.isReset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='qualifierType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qualifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'qualifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='qualifierType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='qualifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='qualifierType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='qualifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isAddress is not None:
            namespaceprefix_ = self.isAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.isAddress_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisAddress>%s</%sisAddress>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isAddress, input_name='isAddress'), namespaceprefix_ , eol_))
        if self.isData is not None:
            namespaceprefix_ = self.isData_nsprefix_ + ':' if (UseCapturedNS_ and self.isData_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisData>%s</%sisData>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isData, input_name='isData'), namespaceprefix_ , eol_))
        if self.isClock is not None:
            namespaceprefix_ = self.isClock_nsprefix_ + ':' if (UseCapturedNS_ and self.isClock_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisClock>%s</%sisClock>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isClock, input_name='isClock'), namespaceprefix_ , eol_))
        if self.isReset is not None:
            namespaceprefix_ = self.isReset_nsprefix_ + ':' if (UseCapturedNS_ and self.isReset_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisReset>%s</%sisReset>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isReset, input_name='isReset'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isAddress':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isAddress')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAddress')
            self.isAddress = ival_
            self.isAddress_nsprefix_ = child_.prefix
        elif nodeName_ == 'isData':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isData')
            ival_ = self.gds_validate_boolean(ival_, node, 'isData')
            self.isData = ival_
            self.isData_nsprefix_ = child_.prefix
        elif nodeName_ == 'isClock':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isClock')
            ival_ = self.gds_validate_boolean(ival_, node, 'isClock')
            self.isClock = ival_
            self.isClock_nsprefix_ = child_.prefix
        elif nodeName_ == 'isReset':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isReset')
            ival_ = self.gds_validate_boolean(ival_, node, 'isReset')
            self.isReset = ival_
            self.isReset_nsprefix_ = child_.prefix
# end class qualifierType


class onSystemType(GeneratedsSuper):
    """group -- Used to group system ports into different groups within a common bus.
    width -- Number of bits required to represent this port. Absence of this element indicates unconstrained number of bits, i.e. the component will define the number of bits in this port. The logical numbering of the port starts at 0 to width-1.
    direction -- If this element is present, the direction of this port is restricted to the specified value. The direction is relative to the non-mirrored interface.
    modeConstraints -- Specifies default constraints for the enclosing wire type port. If the mirroredModeConstraints element is not defined, then these constraints applied to this port when it appears in a 'mode' bus interface or a mirrored-'mode' bus interface. Otherwise they only apply when the port appears in a 'mode' bus interface.
    mirroredModeConstraints -- Specifies default constraints for the enclosing wire type port when it appears in a mirrored-'mode' bus interface.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('group', 'xs:Name', 0, 0, {'name': 'group', 'type': 'xs:Name'}, None),
        MemberSpec_('presence', 'presenceType', 0, 1, {'minOccurs': '0', 'name': 'presence', 'ref': 'presence', 'type': 'presence'}, None),
        MemberSpec_('width', 'unsignedPositiveIntExpression', 0, 1, {'minOccurs': '0', 'name': 'width', 'type': 'unsignedPositiveIntExpression'}, None),
        MemberSpec_('direction', ['direction', 'xs:token'], 0, 1, {'default': 'out', 'minOccurs': '0', 'name': 'direction', 'type': 'xs:token'}, None),
        MemberSpec_('modeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'name': 'modeConstraints', 'type': 'abstractionDefPortConstraintsType'}, None),
        MemberSpec_('mirroredModeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'name': 'mirroredModeConstraints', 'type': 'abstractionDefPortConstraintsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, group=None, presence=None, width=None, direction='out', modeConstraints=None, mirroredModeConstraints=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.group = group
        self.group_nsprefix_ = None
        self.presence = presence
        self.presence_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.direction = direction
        self.validate_direction(self.direction)
        self.direction_nsprefix_ = None
        self.modeConstraints = modeConstraints
        self.modeConstraints_nsprefix_ = None
        self.mirroredModeConstraints = mirroredModeConstraints
        self.mirroredModeConstraints_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onSystemType.subclass:
            return onSystemType.subclass(*args_, **kwargs_)
        else:
            return onSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def get_presence(self):
        return self.presence
    def set_presence(self, presence):
        self.presence = presence
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_modeConstraints(self):
        return self.modeConstraints
    def set_modeConstraints(self, modeConstraints):
        self.modeConstraints = modeConstraints
    def get_mirroredModeConstraints(self):
        return self.mirroredModeConstraints
    def set_mirroredModeConstraints(self, mirroredModeConstraints):
        self.mirroredModeConstraints = mirroredModeConstraints
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_direction(self, value):
        result = True
        # Validate type direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['in', 'out', 'inout']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.group is not None or
            self.presence is not None or
            self.width is not None or
            self.direction != "out" or
            self.modeConstraints is not None or
            self.mirroredModeConstraints is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onSystemType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onSystemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'onSystemType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='onSystemType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='onSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='onSystemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
        if self.presence is not None:
            namespaceprefix_ = self.presence_nsprefix_ + ':' if (UseCapturedNS_ and self.presence_nsprefix_) else ''
            self.presence.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='presence', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.direction != "out":
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), namespaceprefix_ , eol_))
        if self.modeConstraints is not None:
            namespaceprefix_ = self.modeConstraints_nsprefix_ + ':' if (UseCapturedNS_ and self.modeConstraints_nsprefix_) else ''
            self.modeConstraints.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modeConstraints', pretty_print=pretty_print)
        if self.mirroredModeConstraints is not None:
            namespaceprefix_ = self.mirroredModeConstraints_nsprefix_ + ':' if (UseCapturedNS_ and self.mirroredModeConstraints_nsprefix_) else ''
            self.mirroredModeConstraints.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mirroredModeConstraints', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
        elif nodeName_ == 'presence':
            obj_ = presenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.presence = obj_
            obj_.original_tagname_ = 'presence'
        elif nodeName_ == 'width':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'direction':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'direction')
            value_ = self.gds_validate_string(value_, node, 'direction')
            self.direction = value_
            self.direction_nsprefix_ = child_.prefix
            # validate type direction
            self.validate_direction(self.direction)
        elif nodeName_ == 'modeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modeConstraints = obj_
            obj_.original_tagname_ = 'modeConstraints'
        elif nodeName_ == 'mirroredModeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mirroredModeConstraints = obj_
            obj_.original_tagname_ = 'mirroredModeConstraints'
# end class onSystemType


class onMasterType(GeneratedsSuper):
    """width -- Number of bits required to represent this port. Absence of this element indicates unconstrained number of bits, i.e. the component will define the number of bits in this port. The logical numbering of the port starts at 0 to width-1.
    direction -- If this element is present, the direction of this port is restricted to the specified value. The direction is relative to the non-mirrored interface.
    modeConstraints -- Specifies default constraints for the enclosing wire type port. If the mirroredModeConstraints element is not defined, then these constraints applied to this port when it appears in a 'mode' bus interface or a mirrored-'mode' bus interface. Otherwise they only apply when the port appears in a 'mode' bus interface.
    mirroredModeConstraints -- Specifies default constraints for the enclosing wire type port when it appears in a mirrored-'mode' bus interface.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('presence', 'presenceType', 0, 1, {'minOccurs': '0', 'name': 'presence', 'ref': 'presence', 'type': 'presence'}, None),
        MemberSpec_('width', 'unsignedPositiveIntExpression', 0, 1, {'minOccurs': '0', 'name': 'width', 'type': 'unsignedPositiveIntExpression'}, None),
        MemberSpec_('direction', ['direction', 'xs:token'], 0, 1, {'default': 'out', 'minOccurs': '0', 'name': 'direction', 'type': 'xs:token'}, None),
        MemberSpec_('modeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'name': 'modeConstraints', 'type': 'abstractionDefPortConstraintsType'}, None),
        MemberSpec_('mirroredModeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'name': 'mirroredModeConstraints', 'type': 'abstractionDefPortConstraintsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, presence=None, width=None, direction='out', modeConstraints=None, mirroredModeConstraints=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.presence = presence
        self.presence_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.direction = direction
        self.validate_direction(self.direction)
        self.direction_nsprefix_ = None
        self.modeConstraints = modeConstraints
        self.modeConstraints_nsprefix_ = None
        self.mirroredModeConstraints = mirroredModeConstraints
        self.mirroredModeConstraints_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onMasterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onMasterType.subclass:
            return onMasterType.subclass(*args_, **kwargs_)
        else:
            return onMasterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_presence(self):
        return self.presence
    def set_presence(self, presence):
        self.presence = presence
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_modeConstraints(self):
        return self.modeConstraints
    def set_modeConstraints(self, modeConstraints):
        self.modeConstraints = modeConstraints
    def get_mirroredModeConstraints(self):
        return self.mirroredModeConstraints
    def set_mirroredModeConstraints(self, mirroredModeConstraints):
        self.mirroredModeConstraints = mirroredModeConstraints
    def validate_direction(self, value):
        result = True
        # Validate type direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['in', 'out', 'inout']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.presence is not None or
            self.width is not None or
            self.direction != "out" or
            self.modeConstraints is not None or
            self.mirroredModeConstraints is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onMasterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onMasterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'onMasterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='onMasterType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='onMasterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='onMasterType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onMasterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.presence is not None:
            namespaceprefix_ = self.presence_nsprefix_ + ':' if (UseCapturedNS_ and self.presence_nsprefix_) else ''
            self.presence.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='presence', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.direction != "out":
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), namespaceprefix_ , eol_))
        if self.modeConstraints is not None:
            namespaceprefix_ = self.modeConstraints_nsprefix_ + ':' if (UseCapturedNS_ and self.modeConstraints_nsprefix_) else ''
            self.modeConstraints.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modeConstraints', pretty_print=pretty_print)
        if self.mirroredModeConstraints is not None:
            namespaceprefix_ = self.mirroredModeConstraints_nsprefix_ + ':' if (UseCapturedNS_ and self.mirroredModeConstraints_nsprefix_) else ''
            self.mirroredModeConstraints.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mirroredModeConstraints', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'presence':
            obj_ = presenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.presence = obj_
            obj_.original_tagname_ = 'presence'
        elif nodeName_ == 'width':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'direction':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'direction')
            value_ = self.gds_validate_string(value_, node, 'direction')
            self.direction = value_
            self.direction_nsprefix_ = child_.prefix
            # validate type direction
            self.validate_direction(self.direction)
        elif nodeName_ == 'modeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modeConstraints = obj_
            obj_.original_tagname_ = 'modeConstraints'
        elif nodeName_ == 'mirroredModeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mirroredModeConstraints = obj_
            obj_.original_tagname_ = 'mirroredModeConstraints'
# end class onMasterType


class onSlaveType(GeneratedsSuper):
    """width -- Number of bits required to represent this port. Absence of this element indicates unconstrained number of bits, i.e. the component will define the number of bits in this port. The logical numbering of the port starts at 0 to width-1.
    direction -- If this element is present, the direction of this port is restricted to the specified value. The direction is relative to the non-mirrored interface.
    modeConstraints -- Specifies default constraints for the enclosing wire type port. If the mirroredModeConstraints element is not defined, then these constraints applied to this port when it appears in a 'mode' bus interface or a mirrored-'mode' bus interface. Otherwise they only apply when the port appears in a 'mode' bus interface.
    mirroredModeConstraints -- Specifies default constraints for the enclosing wire type port when it appears in a mirrored-'mode' bus interface.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('presence', 'presenceType', 0, 1, {'minOccurs': '0', 'name': 'presence', 'ref': 'presence', 'type': 'presence'}, None),
        MemberSpec_('width', 'unsignedPositiveIntExpression', 0, 1, {'minOccurs': '0', 'name': 'width', 'type': 'unsignedPositiveIntExpression'}, None),
        MemberSpec_('direction', ['direction', 'xs:token'], 0, 1, {'default': 'out', 'minOccurs': '0', 'name': 'direction', 'type': 'xs:token'}, None),
        MemberSpec_('modeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'name': 'modeConstraints', 'type': 'abstractionDefPortConstraintsType'}, None),
        MemberSpec_('mirroredModeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'name': 'mirroredModeConstraints', 'type': 'abstractionDefPortConstraintsType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, presence=None, width=None, direction='out', modeConstraints=None, mirroredModeConstraints=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.presence = presence
        self.presence_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.direction = direction
        self.validate_direction(self.direction)
        self.direction_nsprefix_ = None
        self.modeConstraints = modeConstraints
        self.modeConstraints_nsprefix_ = None
        self.mirroredModeConstraints = mirroredModeConstraints
        self.mirroredModeConstraints_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onSlaveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onSlaveType.subclass:
            return onSlaveType.subclass(*args_, **kwargs_)
        else:
            return onSlaveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_presence(self):
        return self.presence
    def set_presence(self, presence):
        self.presence = presence
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_direction(self):
        return self.direction
    def set_direction(self, direction):
        self.direction = direction
    def get_modeConstraints(self):
        return self.modeConstraints
    def set_modeConstraints(self, modeConstraints):
        self.modeConstraints = modeConstraints
    def get_mirroredModeConstraints(self):
        return self.mirroredModeConstraints
    def set_mirroredModeConstraints(self, mirroredModeConstraints):
        self.mirroredModeConstraints = mirroredModeConstraints
    def validate_direction(self, value):
        result = True
        # Validate type direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['in', 'out', 'inout']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on direction' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.presence is not None or
            self.width is not None or
            self.direction != "out" or
            self.modeConstraints is not None or
            self.mirroredModeConstraints is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onSlaveType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onSlaveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'onSlaveType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='onSlaveType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='onSlaveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='onSlaveType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onSlaveType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.presence is not None:
            namespaceprefix_ = self.presence_nsprefix_ + ':' if (UseCapturedNS_ and self.presence_nsprefix_) else ''
            self.presence.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='presence', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.direction != "out":
            namespaceprefix_ = self.direction_nsprefix_ + ':' if (UseCapturedNS_ and self.direction_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdirection>%s</%sdirection>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), namespaceprefix_ , eol_))
        if self.modeConstraints is not None:
            namespaceprefix_ = self.modeConstraints_nsprefix_ + ':' if (UseCapturedNS_ and self.modeConstraints_nsprefix_) else ''
            self.modeConstraints.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modeConstraints', pretty_print=pretty_print)
        if self.mirroredModeConstraints is not None:
            namespaceprefix_ = self.mirroredModeConstraints_nsprefix_ + ':' if (UseCapturedNS_ and self.mirroredModeConstraints_nsprefix_) else ''
            self.mirroredModeConstraints.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mirroredModeConstraints', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'presence':
            obj_ = presenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.presence = obj_
            obj_.original_tagname_ = 'presence'
        elif nodeName_ == 'width':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'direction':
            value_ = child_.text
            if value_:
                value_ = re_.sub(String_cleanup_pat_, " ", value_).strip()
            else:
                value_ = ""
            value_ = self.gds_parse_string(value_, node, 'direction')
            value_ = self.gds_validate_string(value_, node, 'direction')
            self.direction = value_
            self.direction_nsprefix_ = child_.prefix
            # validate type direction
            self.validate_direction(self.direction)
        elif nodeName_ == 'modeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modeConstraints = obj_
            obj_.original_tagname_ = 'modeConstraints'
        elif nodeName_ == 'mirroredModeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mirroredModeConstraints = obj_
            obj_.original_tagname_ = 'mirroredModeConstraints'
# end class onSlaveType


class transactionalType(GeneratedsSuper):
    """qualifier -- The type of information this port carries A transactional port can carry both address and data information.
    onSystem -- Defines constraints for this port when present in a system bus interface with a matching group name.
    onMaster -- Defines constraints for this port when present in a master bus interface.
    onSlave -- Defines constraints for this port when present in a slave bus interface.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('qualifier', 'qualifierType36', 0, 1, {'minOccurs': '0', 'name': 'qualifier', 'type': 'qualifierType36'}, None),
        MemberSpec_('onSystem', 'onSystemType37', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'onSystem', 'type': 'onSystemType37'}, None),
        MemberSpec_('onMaster', 'onMasterType39', 0, 1, {'minOccurs': '0', 'name': 'onMaster', 'type': 'onMasterType39'}, None),
        MemberSpec_('onSlave', 'onSlaveType41', 0, 1, {'minOccurs': '0', 'name': 'onSlave', 'type': 'onSlaveType41'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, qualifier=None, onSystem=None, onMaster=None, onSlave=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.qualifier = qualifier
        self.qualifier_nsprefix_ = None
        if onSystem is None:
            self.onSystem = []
        else:
            self.onSystem = onSystem
        self.onSystem_nsprefix_ = None
        self.onMaster = onMaster
        self.onMaster_nsprefix_ = None
        self.onSlave = onSlave
        self.onSlave_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transactionalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transactionalType.subclass:
            return transactionalType.subclass(*args_, **kwargs_)
        else:
            return transactionalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qualifier(self):
        return self.qualifier
    def set_qualifier(self, qualifier):
        self.qualifier = qualifier
    def get_onSystem(self):
        return self.onSystem
    def set_onSystem(self, onSystem):
        self.onSystem = onSystem
    def add_onSystem(self, value):
        self.onSystem.append(value)
    def insert_onSystem_at(self, index, value):
        self.onSystem.insert(index, value)
    def replace_onSystem_at(self, index, value):
        self.onSystem[index] = value
    def get_onMaster(self):
        return self.onMaster
    def set_onMaster(self, onMaster):
        self.onMaster = onMaster
    def get_onSlave(self):
        return self.onSlave
    def set_onSlave(self, onSlave):
        self.onSlave = onSlave
    def _hasContent(self):
        if (
            self.qualifier is not None or
            self.onSystem or
            self.onMaster is not None or
            self.onSlave is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transactionalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transactionalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'transactionalType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transactionalType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='transactionalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='transactionalType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='transactionalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qualifier is not None:
            namespaceprefix_ = self.qualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.qualifier_nsprefix_) else ''
            self.qualifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='qualifier', pretty_print=pretty_print)
        for onSystem_ in self.onSystem:
            namespaceprefix_ = self.onSystem_nsprefix_ + ':' if (UseCapturedNS_ and self.onSystem_nsprefix_) else ''
            onSystem_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='onSystem', pretty_print=pretty_print)
        if self.onMaster is not None:
            namespaceprefix_ = self.onMaster_nsprefix_ + ':' if (UseCapturedNS_ and self.onMaster_nsprefix_) else ''
            self.onMaster.export(outfile, level, namespaceprefix_, namespacedef_='', name_='onMaster', pretty_print=pretty_print)
        if self.onSlave is not None:
            namespaceprefix_ = self.onSlave_nsprefix_ + ':' if (UseCapturedNS_ and self.onSlave_nsprefix_) else ''
            self.onSlave.export(outfile, level, namespaceprefix_, namespacedef_='', name_='onSlave', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'qualifier':
            obj_ = qualifierType36.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.qualifier = obj_
            obj_.original_tagname_ = 'qualifier'
        elif nodeName_ == 'onSystem':
            obj_ = onSystemType37.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.onSystem.append(obj_)
            obj_.original_tagname_ = 'onSystem'
        elif nodeName_ == 'onMaster':
            obj_ = onMasterType39.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.onMaster = obj_
            obj_.original_tagname_ = 'onMaster'
        elif nodeName_ == 'onSlave':
            obj_ = onSlaveType41.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.onSlave = obj_
            obj_.original_tagname_ = 'onSlave'
# end class transactionalType


class qualifierType36(GeneratedsSuper):
    """isAddress -- If this element is present, the port contains address information.
    isData -- If this element is present, the port contains data information.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('isAddress', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isAddress', 'type': 'xs:boolean'}, None),
        MemberSpec_('isData', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'isData', 'type': 'xs:boolean'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, isAddress=None, isData=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.isAddress = isAddress
        self.isAddress_nsprefix_ = None
        self.isData = isData
        self.isData_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qualifierType36)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qualifierType36.subclass:
            return qualifierType36.subclass(*args_, **kwargs_)
        else:
            return qualifierType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isAddress(self):
        return self.isAddress
    def set_isAddress(self, isAddress):
        self.isAddress = isAddress
    def get_isData(self):
        return self.isData
    def set_isData(self, isData):
        self.isData = isData
    def _hasContent(self):
        if (
            self.isAddress is not None or
            self.isData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='qualifierType36', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qualifierType36')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'qualifierType36':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='qualifierType36')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='qualifierType36', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='qualifierType36'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='qualifierType36', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isAddress is not None:
            namespaceprefix_ = self.isAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.isAddress_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisAddress>%s</%sisAddress>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isAddress, input_name='isAddress'), namespaceprefix_ , eol_))
        if self.isData is not None:
            namespaceprefix_ = self.isData_nsprefix_ + ':' if (UseCapturedNS_ and self.isData_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisData>%s</%sisData>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isData, input_name='isData'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isAddress':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isAddress')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAddress')
            self.isAddress = ival_
            self.isAddress_nsprefix_ = child_.prefix
        elif nodeName_ == 'isData':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isData')
            ival_ = self.gds_validate_boolean(ival_, node, 'isData')
            self.isData = ival_
            self.isData_nsprefix_ = child_.prefix
# end class qualifierType36


class onSystemType37(GeneratedsSuper):
    """group -- Used to group system ports into different groups within a common bus.
    initiative -- If this element is present, the type of access is restricted to the specified value.
    busWidth -- If this element is present, the width must match
    protocol -- If this element is present, the name must match
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('group', 'xs:Name', 0, 0, {'name': 'group', 'type': 'xs:Name'}, None),
        MemberSpec_('presence', 'presenceType', 0, 1, {'minOccurs': '0', 'name': 'presence', 'ref': 'presence', 'type': 'presence'}, None),
        MemberSpec_('initiative', ['initiativeType38', 'xs:string'], 0, 1, {'default': 'requires', 'minOccurs': '0', 'name': 'initiative', 'type': 'xs:string'}, None),
        MemberSpec_('kind', 'kind', 0, 1, {'minOccurs': '0', 'name': 'kind', 'ref': 'kind', 'type': 'kind'}, None),
        MemberSpec_('busWidth', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'name': 'busWidth', 'type': 'unsignedPositiveIntExpression'}, None),
        MemberSpec_('protocol', 'protocol', 0, 1, {'minOccurs': '0', 'name': 'protocol', 'ref': 'protocol', 'type': 'protocol'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, group=None, presence=None, initiative='requires', kind=None, busWidth=None, protocol=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.group = group
        self.group_nsprefix_ = None
        self.presence = presence
        self.presence_nsprefix_ = None
        self.initiative = initiative
        self.validate_initiativeType38(self.initiative)
        self.initiative_nsprefix_ = None
        self.kind = kind
        self.kind_nsprefix_ = None
        self.busWidth = busWidth
        self.busWidth_nsprefix_ = None
        self.protocol = protocol
        self.protocol_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onSystemType37)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onSystemType37.subclass:
            return onSystemType37.subclass(*args_, **kwargs_)
        else:
            return onSystemType37(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def get_presence(self):
        return self.presence
    def set_presence(self, presence):
        self.presence = presence
    def get_initiative(self):
        return self.initiative
    def set_initiative(self, initiative):
        self.initiative = initiative
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def get_busWidth(self):
        return self.busWidth
    def set_busWidth(self, busWidth):
        self.busWidth = busWidth
    def get_protocol(self):
        return self.protocol
    def set_protocol(self, protocol):
        self.protocol = protocol
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_initiativeType38(self, value):
        result = True
        # Validate type initiativeType38, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['requires', 'provides', 'both']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on initiativeType38' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.group is not None or
            self.presence is not None or
            self.initiative != "requires" or
            self.kind is not None or
            self.busWidth is not None or
            self.protocol is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onSystemType37', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onSystemType37')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'onSystemType37':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='onSystemType37')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='onSystemType37', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='onSystemType37'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onSystemType37', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroup>%s</%sgroup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), namespaceprefix_ , eol_))
        if self.presence is not None:
            namespaceprefix_ = self.presence_nsprefix_ + ':' if (UseCapturedNS_ and self.presence_nsprefix_) else ''
            self.presence.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='presence', pretty_print=pretty_print)
        if self.initiative != "requires":
            namespaceprefix_ = self.initiative_nsprefix_ + ':' if (UseCapturedNS_ and self.initiative_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitiative>%s</%sinitiative>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.initiative), input_name='initiative')), namespaceprefix_ , eol_))
        if self.kind is not None:
            namespaceprefix_ = self.kind_nsprefix_ + ':' if (UseCapturedNS_ and self.kind_nsprefix_) else ''
            self.kind.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='kind', pretty_print=pretty_print)
        if self.busWidth is not None:
            namespaceprefix_ = self.busWidth_nsprefix_ + ':' if (UseCapturedNS_ and self.busWidth_nsprefix_) else ''
            self.busWidth.export(outfile, level, namespaceprefix_, namespacedef_='', name_='busWidth', pretty_print=pretty_print)
        if self.protocol is not None:
            namespaceprefix_ = self.protocol_nsprefix_ + ':' if (UseCapturedNS_ and self.protocol_nsprefix_) else ''
            self.protocol.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='protocol', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'group')
            value_ = self.gds_validate_string(value_, node, 'group')
            self.group = value_
            self.group_nsprefix_ = child_.prefix
        elif nodeName_ == 'presence':
            obj_ = presenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.presence = obj_
            obj_.original_tagname_ = 'presence'
        elif nodeName_ == 'initiative':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'initiative')
            value_ = self.gds_validate_string(value_, node, 'initiative')
            self.initiative = value_
            self.initiative_nsprefix_ = child_.prefix
            # validate type initiativeType38
            self.validate_initiativeType38(self.initiative)
        elif nodeName_ == 'kind':
            obj_ = kind.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'busWidth':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.busWidth = obj_
            obj_.original_tagname_ = 'busWidth'
        elif nodeName_ == 'protocol':
            obj_ = protocol.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocol = obj_
            obj_.original_tagname_ = 'protocol'
# end class onSystemType37


class onMasterType39(GeneratedsSuper):
    """initiative -- If this element is present, the type of access is restricted to the specified value.
    busWidth -- If this element is present, the width must match
    protocol -- If this element is present, the name must match
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('presence', 'presenceType', 0, 1, {'minOccurs': '0', 'name': 'presence', 'ref': 'presence', 'type': 'presence'}, None),
        MemberSpec_('initiative', ['initiativeType40', 'xs:string'], 0, 1, {'default': 'requires', 'minOccurs': '0', 'name': 'initiative', 'type': 'xs:string'}, None),
        MemberSpec_('kind', 'kind', 0, 1, {'minOccurs': '0', 'name': 'kind', 'ref': 'kind', 'type': 'kind'}, None),
        MemberSpec_('busWidth', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'name': 'busWidth', 'type': 'unsignedPositiveIntExpression'}, None),
        MemberSpec_('protocol', 'protocol', 0, 1, {'minOccurs': '0', 'name': 'protocol', 'ref': 'protocol', 'type': 'protocol'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, presence=None, initiative='requires', kind=None, busWidth=None, protocol=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.presence = presence
        self.presence_nsprefix_ = None
        self.initiative = initiative
        self.validate_initiativeType40(self.initiative)
        self.initiative_nsprefix_ = None
        self.kind = kind
        self.kind_nsprefix_ = None
        self.busWidth = busWidth
        self.busWidth_nsprefix_ = None
        self.protocol = protocol
        self.protocol_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onMasterType39)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onMasterType39.subclass:
            return onMasterType39.subclass(*args_, **kwargs_)
        else:
            return onMasterType39(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_presence(self):
        return self.presence
    def set_presence(self, presence):
        self.presence = presence
    def get_initiative(self):
        return self.initiative
    def set_initiative(self, initiative):
        self.initiative = initiative
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def get_busWidth(self):
        return self.busWidth
    def set_busWidth(self, busWidth):
        self.busWidth = busWidth
    def get_protocol(self):
        return self.protocol
    def set_protocol(self, protocol):
        self.protocol = protocol
    def validate_initiativeType40(self, value):
        result = True
        # Validate type initiativeType40, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['requires', 'provides', 'both']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on initiativeType40' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.presence is not None or
            self.initiative != "requires" or
            self.kind is not None or
            self.busWidth is not None or
            self.protocol is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onMasterType39', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onMasterType39')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'onMasterType39':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='onMasterType39')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='onMasterType39', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='onMasterType39'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onMasterType39', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.presence is not None:
            namespaceprefix_ = self.presence_nsprefix_ + ':' if (UseCapturedNS_ and self.presence_nsprefix_) else ''
            self.presence.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='presence', pretty_print=pretty_print)
        if self.initiative != "requires":
            namespaceprefix_ = self.initiative_nsprefix_ + ':' if (UseCapturedNS_ and self.initiative_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitiative>%s</%sinitiative>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.initiative), input_name='initiative')), namespaceprefix_ , eol_))
        if self.kind is not None:
            namespaceprefix_ = self.kind_nsprefix_ + ':' if (UseCapturedNS_ and self.kind_nsprefix_) else ''
            self.kind.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='kind', pretty_print=pretty_print)
        if self.busWidth is not None:
            namespaceprefix_ = self.busWidth_nsprefix_ + ':' if (UseCapturedNS_ and self.busWidth_nsprefix_) else ''
            self.busWidth.export(outfile, level, namespaceprefix_, namespacedef_='', name_='busWidth', pretty_print=pretty_print)
        if self.protocol is not None:
            namespaceprefix_ = self.protocol_nsprefix_ + ':' if (UseCapturedNS_ and self.protocol_nsprefix_) else ''
            self.protocol.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='protocol', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'presence':
            obj_ = presenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.presence = obj_
            obj_.original_tagname_ = 'presence'
        elif nodeName_ == 'initiative':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'initiative')
            value_ = self.gds_validate_string(value_, node, 'initiative')
            self.initiative = value_
            self.initiative_nsprefix_ = child_.prefix
            # validate type initiativeType40
            self.validate_initiativeType40(self.initiative)
        elif nodeName_ == 'kind':
            obj_ = kind.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'busWidth':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.busWidth = obj_
            obj_.original_tagname_ = 'busWidth'
        elif nodeName_ == 'protocol':
            obj_ = protocol.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocol = obj_
            obj_.original_tagname_ = 'protocol'
# end class onMasterType39


class onSlaveType41(GeneratedsSuper):
    """initiative -- If this element is present, the type of access is restricted to the specified value.
    busWidth -- If this element is present, the width must match
    protocol -- If this element is present, the name must match
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('presence', 'presenceType', 0, 1, {'minOccurs': '0', 'name': 'presence', 'ref': 'presence', 'type': 'presence'}, None),
        MemberSpec_('initiative', ['initiativeType42', 'xs:string'], 0, 1, {'default': 'requires', 'minOccurs': '0', 'name': 'initiative', 'type': 'xs:string'}, None),
        MemberSpec_('kind', 'kind', 0, 1, {'minOccurs': '0', 'name': 'kind', 'ref': 'kind', 'type': 'kind'}, None),
        MemberSpec_('busWidth', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'name': 'busWidth', 'type': 'unsignedPositiveIntExpression'}, None),
        MemberSpec_('protocol', 'protocol', 0, 1, {'minOccurs': '0', 'name': 'protocol', 'ref': 'protocol', 'type': 'protocol'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, presence=None, initiative='requires', kind=None, busWidth=None, protocol=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.presence = presence
        self.presence_nsprefix_ = None
        self.initiative = initiative
        self.validate_initiativeType42(self.initiative)
        self.initiative_nsprefix_ = None
        self.kind = kind
        self.kind_nsprefix_ = None
        self.busWidth = busWidth
        self.busWidth_nsprefix_ = None
        self.protocol = protocol
        self.protocol_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onSlaveType41)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onSlaveType41.subclass:
            return onSlaveType41.subclass(*args_, **kwargs_)
        else:
            return onSlaveType41(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_presence(self):
        return self.presence
    def set_presence(self, presence):
        self.presence = presence
    def get_initiative(self):
        return self.initiative
    def set_initiative(self, initiative):
        self.initiative = initiative
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def get_busWidth(self):
        return self.busWidth
    def set_busWidth(self, busWidth):
        self.busWidth = busWidth
    def get_protocol(self):
        return self.protocol
    def set_protocol(self, protocol):
        self.protocol = protocol
    def validate_initiativeType42(self, value):
        result = True
        # Validate type initiativeType42, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['requires', 'provides', 'both']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on initiativeType42' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.presence is not None or
            self.initiative != "requires" or
            self.kind is not None or
            self.busWidth is not None or
            self.protocol is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onSlaveType41', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onSlaveType41')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'onSlaveType41':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='onSlaveType41')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='onSlaveType41', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='onSlaveType41'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='onSlaveType41', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.presence is not None:
            namespaceprefix_ = self.presence_nsprefix_ + ':' if (UseCapturedNS_ and self.presence_nsprefix_) else ''
            self.presence.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='presence', pretty_print=pretty_print)
        if self.initiative != "requires":
            namespaceprefix_ = self.initiative_nsprefix_ + ':' if (UseCapturedNS_ and self.initiative_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinitiative>%s</%sinitiative>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.initiative), input_name='initiative')), namespaceprefix_ , eol_))
        if self.kind is not None:
            namespaceprefix_ = self.kind_nsprefix_ + ':' if (UseCapturedNS_ and self.kind_nsprefix_) else ''
            self.kind.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='kind', pretty_print=pretty_print)
        if self.busWidth is not None:
            namespaceprefix_ = self.busWidth_nsprefix_ + ':' if (UseCapturedNS_ and self.busWidth_nsprefix_) else ''
            self.busWidth.export(outfile, level, namespaceprefix_, namespacedef_='', name_='busWidth', pretty_print=pretty_print)
        if self.protocol is not None:
            namespaceprefix_ = self.protocol_nsprefix_ + ':' if (UseCapturedNS_ and self.protocol_nsprefix_) else ''
            self.protocol.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='protocol', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'presence':
            obj_ = presenceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.presence = obj_
            obj_.original_tagname_ = 'presence'
        elif nodeName_ == 'initiative':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'initiative')
            value_ = self.gds_validate_string(value_, node, 'initiative')
            self.initiative = value_
            self.initiative_nsprefix_ = child_.prefix
            # validate type initiativeType42
            self.validate_initiativeType42(self.initiative)
        elif nodeName_ == 'kind':
            obj_ = kind.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'busWidth':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.busWidth = obj_
            obj_.original_tagname_ = 'busWidth'
        elif nodeName_ == 'protocol':
            obj_ = protocol.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.protocol = obj_
            obj_.original_tagname_ = 'protocol'
# end class onSlaveType41


class accessHandlesType43(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'simpleAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'simpleAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType43)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType43.subclass:
            return accessHandlesType43.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType43(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType43', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType43')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType43':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType43')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType43', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType43'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType43', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = simpleAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType43


class accessHandlesType44(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'simpleAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'simpleAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType44)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType44.subclass:
            return accessHandlesType44.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType44(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType44', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType44')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType44':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType44')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType44', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType44'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType44', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = simpleAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType44


class accessHandlesType45(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'nonIndexedLeafAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'nonIndexedLeafAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType45)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType45.subclass:
            return accessHandlesType45.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType45(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType45', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType45')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType45':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType45')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType45', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType45'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType45', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = nonIndexedLeafAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType45


class accessHandlesType46(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'simpleAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'simpleAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType46)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType46.subclass:
            return accessHandlesType46.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType46(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType46', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType46')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType46':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType46')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType46', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType46'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType46', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = simpleAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType46


class accessHandlesType47(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'simpleAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'simpleAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType47)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType47.subclass:
            return accessHandlesType47.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType47(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType47', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType47')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType47':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType47')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType47', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType47'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType47', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = simpleAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType47


class accessHandlesType48(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'nonIndexedLeafAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'nonIndexedLeafAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType48)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType48.subclass:
            return accessHandlesType48.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType48(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType48', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType48')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType48':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType48')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType48', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType48'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType48', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = nonIndexedLeafAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType48


class accessHandlesType49(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'nonIndexedLeafAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'nonIndexedLeafAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType49)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType49.subclass:
            return accessHandlesType49.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType49(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType49', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType49')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType49':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType49')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType49', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType49'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType49', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = nonIndexedLeafAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType49


class resetsType(GeneratedsSuper):
    """reset -- BitField reset value
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('reset', 'reset', 1, 0, {'maxOccurs': 'unbounded', 'name': 'reset', 'ref': 'reset', 'type': 'reset'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, reset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if reset is None:
            self.reset = []
        else:
            self.reset = reset
        self.reset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resetsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resetsType.subclass:
            return resetsType.subclass(*args_, **kwargs_)
        else:
            return resetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_reset(self):
        return self.reset
    def set_reset(self, reset):
        self.reset = reset
    def add_reset(self, value):
        self.reset.append(value)
    def insert_reset_at(self, index, value):
        self.reset.insert(index, value)
    def replace_reset_at(self, index, value):
        self.reset[index] = value
    def _hasContent(self):
        if (
            self.reset
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='resetsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resetsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'resetsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='resetsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='resetsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='resetsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='resetsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reset_ in self.reset:
            namespaceprefix_ = self.reset_nsprefix_ + ':' if (UseCapturedNS_ and self.reset_nsprefix_) else ''
            reset_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='reset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'reset':
            obj_ = reset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reset.append(obj_)
            obj_.original_tagname_ = 'reset'
# end class resetsType


class addressSpaceType(GeneratedsSuper):
    """name -- Unique name
    range -- The address range of an address block.  Expressed as the number of addressable units accessible to the block. The range and the width are related by the following formulas:
    number_of_bits_in_block = ipxact:addressUnitBits * ipxact:range
    number_of_rows_in_block = number_of_bits_in_block / ipxact:width
      
    * width -- The bit width of a row in the address block. The range and the width are related by the following formulas:
      number_of_bits_in_block = ipxact:addressUnitBits * ipxact:range
      number_of_rows_in_block = number_of_bits_in_block / ipxact:width
      
    * segments -- Address segments withing an addressSpace
    * localMemoryMap -- Provides the local memory map of an address space.  Blocks in this memory map are accessable to master interfaces on this component that reference this address space.   They are not accessable to any external master interface.
    * parameters -- Data specific to this address space.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('Range', 'unsignedPositiveLongintExpression', 0, 0, {'name': 'range', 'type': 'unsignedPositiveLongintExpression'}, None),
        MemberSpec_('width', 'unsignedIntExpression', 0, 0, {'name': 'width', 'type': 'unsignedIntExpression'}, None),
        MemberSpec_('segments', 'segmentsType', 0, 1, {'minOccurs': '0', 'name': 'segments', 'type': 'segmentsType'}, None),
        MemberSpec_('addressUnitBits', 'unsignedPositiveLongintExpression', 0, 1, {'minOccurs': '0', 'name': 'addressUnitBits', 'ref': 'addressUnitBits', 'type': 'addressUnitBits'}, None),
        MemberSpec_('executableImage', 'executableImage', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'executableImage', 'ref': 'executableImage', 'type': 'executableImage'}, None),
        MemberSpec_('localMemoryMap', 'localMemoryMapType', 0, 1, {'minOccurs': '0', 'name': 'localMemoryMap', 'type': 'localMemoryMapType'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, Range=None, width=None, segments=None, addressUnitBits=None, executableImage=None, localMemoryMap=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        self.Range = Range
        self.Range_nsprefix_ = None
        self.width = width
        self.width_nsprefix_ = None
        self.segments = segments
        self.segments_nsprefix_ = None
        self.addressUnitBits = addressUnitBits
        self.addressUnitBits_nsprefix_ = None
        if executableImage is None:
            self.executableImage = []
        else:
            self.executableImage = executableImage
        self.executableImage_nsprefix_ = None
        self.localMemoryMap = localMemoryMap
        self.localMemoryMap_nsprefix_ = None
        self.parameters = parameters
        self.parameters_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressSpaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressSpaceType.subclass:
            return addressSpaceType.subclass(*args_, **kwargs_)
        else:
            return addressSpaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_range(self):
        return self.Range
    def set_range(self, Range):
        self.Range = Range
    def get_width(self):
        return self.width
    def set_width(self, width):
        self.width = width
    def get_segments(self):
        return self.segments
    def set_segments(self, segments):
        self.segments = segments
    def get_addressUnitBits(self):
        return self.addressUnitBits
    def set_addressUnitBits(self, addressUnitBits):
        self.addressUnitBits = addressUnitBits
    def get_executableImage(self):
        return self.executableImage
    def set_executableImage(self, executableImage):
        self.executableImage = executableImage
    def add_executableImage(self, value):
        self.executableImage.append(value)
    def insert_executableImage_at(self, index, value):
        self.executableImage.insert(index, value)
    def replace_executableImage_at(self, index, value):
        self.executableImage[index] = value
    def get_localMemoryMap(self):
        return self.localMemoryMap
    def set_localMemoryMap(self, localMemoryMap):
        self.localMemoryMap = localMemoryMap
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.Range is not None or
            self.width is not None or
            self.segments is not None or
            self.addressUnitBits is not None or
            self.executableImage or
            self.localMemoryMap is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressSpaceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressSpaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'addressSpaceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addressSpaceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addressSpaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addressSpaceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='addressSpaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.Range is not None:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            self.Range.export(outfile, level, namespaceprefix_, namespacedef_='', name_='range', pretty_print=pretty_print)
        if self.width is not None:
            namespaceprefix_ = self.width_nsprefix_ + ':' if (UseCapturedNS_ and self.width_nsprefix_) else ''
            self.width.export(outfile, level, namespaceprefix_, namespacedef_='', name_='width', pretty_print=pretty_print)
        if self.segments is not None:
            namespaceprefix_ = self.segments_nsprefix_ + ':' if (UseCapturedNS_ and self.segments_nsprefix_) else ''
            self.segments.export(outfile, level, namespaceprefix_, namespacedef_='', name_='segments', pretty_print=pretty_print)
        if self.addressUnitBits is not None:
            namespaceprefix_ = self.addressUnitBits_nsprefix_ + ':' if (UseCapturedNS_ and self.addressUnitBits_nsprefix_) else ''
            self.addressUnitBits.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='addressUnitBits', pretty_print=pretty_print)
        for executableImage_ in self.executableImage:
            namespaceprefix_ = self.executableImage_nsprefix_ + ':' if (UseCapturedNS_ and self.executableImage_nsprefix_) else ''
            executableImage_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='executableImage', pretty_print=pretty_print)
        if self.localMemoryMap is not None:
            namespaceprefix_ = self.localMemoryMap_nsprefix_ + ':' if (UseCapturedNS_ and self.localMemoryMap_nsprefix_) else ''
            self.localMemoryMap.export(outfile, level, namespaceprefix_, namespacedef_='', name_='localMemoryMap', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'range':
            obj_ = unsignedPositiveLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
        elif nodeName_ == 'width':
            obj_ = unsignedIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'segments':
            obj_ = segmentsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.segments = obj_
            obj_.original_tagname_ = 'segments'
        elif nodeName_ == 'addressUnitBits':
            obj_ = unsignedPositiveLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressUnitBits = obj_
            obj_.original_tagname_ = 'addressUnitBits'
        elif nodeName_ == 'executableImage':
            obj_ = executableImage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.executableImage.append(obj_)
            obj_.original_tagname_ = 'executableImage'
        elif nodeName_ == 'localMemoryMap':
            obj_ = localMemoryMapType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.localMemoryMap = obj_
            obj_.original_tagname_ = 'localMemoryMap'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class addressSpaceType


class segmentsType(GeneratedsSuper):
    """segment -- Address segment withing an addressSpace
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('segment', 'segmentType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'segment', 'type': 'segmentType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, segment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
        self.segment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, segmentsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if segmentsType.subclass:
            return segmentsType.subclass(*args_, **kwargs_)
        else:
            return segmentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_segment(self):
        return self.segment
    def set_segment(self, segment):
        self.segment = segment
    def add_segment(self, value):
        self.segment.append(value)
    def insert_segment_at(self, index, value):
        self.segment.insert(index, value)
    def replace_segment_at(self, index, value):
        self.segment[index] = value
    def _hasContent(self):
        if (
            self.segment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='segmentsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('segmentsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'segmentsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='segmentsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='segmentsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='segmentsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='segmentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for segment_ in self.segment:
            namespaceprefix_ = self.segment_nsprefix_ + ':' if (UseCapturedNS_ and self.segment_nsprefix_) else ''
            segment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='segment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'segment':
            obj_ = segmentType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.segment.append(obj_)
            obj_.original_tagname_ = 'segment'
# end class segmentsType


class segmentType(GeneratedsSuper):
    """name -- Unique name
    addressOffset -- Address offset of the segment within the containing address space.
    range -- The address range of asegment.  Expressed as the number of addressable units accessible to the segment.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'name': 'addressOffset', 'type': 'unsignedLongintExpression'}, None),
        MemberSpec_('Range', 'unsignedPositiveLongintExpression', 0, 0, {'name': 'range', 'type': 'unsignedPositiveLongintExpression'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, addressOffset=None, Range=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        self.addressOffset = addressOffset
        self.addressOffset_nsprefix_ = None
        self.Range = Range
        self.Range_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, segmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if segmentType.subclass:
            return segmentType.subclass(*args_, **kwargs_)
        else:
            return segmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_addressOffset(self):
        return self.addressOffset
    def set_addressOffset(self, addressOffset):
        self.addressOffset = addressOffset
    def get_range(self):
        return self.Range
    def set_range(self, Range):
        self.Range = Range
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.addressOffset is not None or
            self.Range is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='segmentType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('segmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'segmentType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='segmentType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='segmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='segmentType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='segmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.addressOffset is not None:
            namespaceprefix_ = self.addressOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.addressOffset_nsprefix_) else ''
            self.addressOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressOffset', pretty_print=pretty_print)
        if self.Range is not None:
            namespaceprefix_ = self.Range_nsprefix_ + ':' if (UseCapturedNS_ and self.Range_nsprefix_) else ''
            self.Range.export(outfile, level, namespaceprefix_, namespacedef_='', name_='range', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'range':
            obj_ = unsignedPositiveLongintExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class segmentType


class registerType(GeneratedsSuper):
    """Unique name
    name -- Unique name
    dim -- Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.
    addressOffset -- Offset from the address block's baseAddress or the containing register file's addressOffset, expressed as the number of addressUnitBits from the containing memoryMap or localMemoryMap.
    Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the registerDefinitionGroup.
    typeIdentifier -- Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the registerDefinitionGroup.
    size -- Width of the register in bits.
    field -- Describes individual bit fields within the register.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType50', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType50'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('dim', 'dimType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'dim', 'type': 'dimType'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'name': 'addressOffset', 'type': 'unsignedLongintExpression'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'typeIdentifier', 'type': 'xs:Name'}, None),
        MemberSpec_('size', 'unsignedPositiveIntExpression', 0, 0, {'name': 'size', 'type': 'unsignedPositiveIntExpression'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('field', 'fieldType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'field', 'type': 'fieldType'}, None),
        MemberSpec_('alternateRegisters', 'alternateRegisters', 0, 1, {'minOccurs': '0', 'name': 'alternateRegisters', 'ref': 'alternateRegisters', 'type': 'alternateRegisters'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, dim=None, addressOffset=None, typeIdentifier=None, size=None, volatile=None, access=None, field=None, alternateRegisters=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        if dim is None:
            self.dim = []
        else:
            self.dim = dim
        self.dim_nsprefix_ = None
        self.addressOffset = addressOffset
        self.addressOffset_nsprefix_ = None
        self.typeIdentifier = typeIdentifier
        self.typeIdentifier_nsprefix_ = None
        self.size = size
        self.size_nsprefix_ = None
        self.volatile = volatile
        self.volatile_nsprefix_ = None
        self.access = access
        self.access_nsprefix_ = None
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = None
        self.alternateRegisters = alternateRegisters
        self.alternateRegisters_nsprefix_ = None
        self.parameters = parameters
        self.parameters_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, registerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if registerType.subclass:
            return registerType.subclass(*args_, **kwargs_)
        else:
            return registerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_dim(self):
        return self.dim
    def set_dim(self, dim):
        self.dim = dim
    def add_dim(self, value):
        self.dim.append(value)
    def insert_dim_at(self, index, value):
        self.dim.insert(index, value)
    def replace_dim_at(self, index, value):
        self.dim[index] = value
    def get_addressOffset(self):
        return self.addressOffset
    def set_addressOffset(self, addressOffset):
        self.addressOffset = addressOffset
    def get_typeIdentifier(self):
        return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier):
        self.typeIdentifier = typeIdentifier
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def add_field(self, value):
        self.field.append(value)
    def insert_field_at(self, index, value):
        self.field.insert(index, value)
    def replace_field_at(self, index, value):
        self.field[index] = value
    def get_alternateRegisters(self):
        return self.alternateRegisters
    def set_alternateRegisters(self, alternateRegisters):
        self.alternateRegisters = alternateRegisters
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.dim or
            self.addressOffset is not None or
            self.typeIdentifier is not None or
            self.size is not None or
            self.volatile is not None or
            self.access is not None or
            self.field or
            self.alternateRegisters is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='registerType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('registerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'registerType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='registerType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='registerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='registerType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='registerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for dim_ in self.dim:
            namespaceprefix_ = self.dim_nsprefix_ + ':' if (UseCapturedNS_ and self.dim_nsprefix_) else ''
            dim_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dim', pretty_print=pretty_print)
        if self.addressOffset is not None:
            namespaceprefix_ = self.addressOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.addressOffset_nsprefix_) else ''
            self.addressOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressOffset', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            namespaceprefix_ = self.typeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.typeIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stypeIdentifier>%s</%stypeIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), namespaceprefix_ , eol_))
        if self.size is not None:
            namespaceprefix_ = self.size_nsprefix_ + ':' if (UseCapturedNS_ and self.size_nsprefix_) else ''
            self.size.export(outfile, level, namespaceprefix_, namespacedef_='', name_='size', pretty_print=pretty_print)
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        for field_ in self.field:
            namespaceprefix_ = self.field_nsprefix_ + ':' if (UseCapturedNS_ and self.field_nsprefix_) else ''
            field_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='field', pretty_print=pretty_print)
        if self.alternateRegisters is not None:
            namespaceprefix_ = self.alternateRegisters_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateRegisters_nsprefix_) else ''
            self.alternateRegisters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='alternateRegisters', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType50.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'dim':
            obj_ = dimType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dim.append(obj_)
            obj_.original_tagname_ = 'dim'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'typeIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeIdentifier')
            value_ = self.gds_validate_string(value_, node, 'typeIdentifier')
            self.typeIdentifier = value_
            self.typeIdentifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'size':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.size = obj_
            obj_.original_tagname_ = 'size'
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'field':
            obj_ = fieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        elif nodeName_ == 'alternateRegisters':
            obj_ = alternateRegisters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateRegisters = obj_
            obj_.original_tagname_ = 'alternateRegisters'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class registerType


class accessHandlesType50(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'indexedAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType50)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType50.subclass:
            return accessHandlesType50.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType50(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType50', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType50')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType50':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType50')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType50', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType50'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType50', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType50


class registerType51(GeneratedsSuper):
    """name -- Unique name
    dim -- Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.
    addressOffset -- Offset from the address block's baseAddress or the containing register file's addressOffset, expressed as the number of addressUnitBits from the containing memoryMap or localMemoryMap.
    typeIdentifier -- Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the registerDefinitionGroup.
    size -- Width of the register in bits.
    field -- Describes individual bit fields within the register.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType52', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType52'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('dim', 'dimType53', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'dim', 'type': 'dimType53'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'name': 'addressOffset', 'type': 'unsignedLongintExpression'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'typeIdentifier', 'type': 'xs:Name'}, None),
        MemberSpec_('size', 'unsignedPositiveIntExpression', 0, 0, {'name': 'size', 'type': 'unsignedPositiveIntExpression'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('field', 'fieldType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'field', 'type': 'fieldType'}, None),
        MemberSpec_('alternateRegisters', 'alternateRegisters', 0, 1, {'minOccurs': '0', 'name': 'alternateRegisters', 'ref': 'alternateRegisters', 'type': 'alternateRegisters'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, dim=None, addressOffset=None, typeIdentifier=None, size=None, volatile=None, access=None, field=None, alternateRegisters=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        if dim is None:
            self.dim = []
        else:
            self.dim = dim
        self.dim_nsprefix_ = None
        self.addressOffset = addressOffset
        self.addressOffset_nsprefix_ = None
        self.typeIdentifier = typeIdentifier
        self.typeIdentifier_nsprefix_ = None
        self.size = size
        self.size_nsprefix_ = None
        self.volatile = volatile
        self.volatile_nsprefix_ = None
        self.access = access
        self.access_nsprefix_ = None
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = None
        self.alternateRegisters = alternateRegisters
        self.alternateRegisters_nsprefix_ = None
        self.parameters = parameters
        self.parameters_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, registerType51)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if registerType51.subclass:
            return registerType51.subclass(*args_, **kwargs_)
        else:
            return registerType51(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_dim(self):
        return self.dim
    def set_dim(self, dim):
        self.dim = dim
    def add_dim(self, value):
        self.dim.append(value)
    def insert_dim_at(self, index, value):
        self.dim.insert(index, value)
    def replace_dim_at(self, index, value):
        self.dim[index] = value
    def get_addressOffset(self):
        return self.addressOffset
    def set_addressOffset(self, addressOffset):
        self.addressOffset = addressOffset
    def get_typeIdentifier(self):
        return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier):
        self.typeIdentifier = typeIdentifier
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def add_field(self, value):
        self.field.append(value)
    def insert_field_at(self, index, value):
        self.field.insert(index, value)
    def replace_field_at(self, index, value):
        self.field[index] = value
    def get_alternateRegisters(self):
        return self.alternateRegisters
    def set_alternateRegisters(self, alternateRegisters):
        self.alternateRegisters = alternateRegisters
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.dim or
            self.addressOffset is not None or
            self.typeIdentifier is not None or
            self.size is not None or
            self.volatile is not None or
            self.access is not None or
            self.field or
            self.alternateRegisters is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='registerType51', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('registerType51')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'registerType51':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='registerType51')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='registerType51', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='registerType51'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='registerType51', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for dim_ in self.dim:
            namespaceprefix_ = self.dim_nsprefix_ + ':' if (UseCapturedNS_ and self.dim_nsprefix_) else ''
            dim_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dim', pretty_print=pretty_print)
        if self.addressOffset is not None:
            namespaceprefix_ = self.addressOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.addressOffset_nsprefix_) else ''
            self.addressOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressOffset', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            namespaceprefix_ = self.typeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.typeIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stypeIdentifier>%s</%stypeIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), namespaceprefix_ , eol_))
        if self.size is not None:
            namespaceprefix_ = self.size_nsprefix_ + ':' if (UseCapturedNS_ and self.size_nsprefix_) else ''
            self.size.export(outfile, level, namespaceprefix_, namespacedef_='', name_='size', pretty_print=pretty_print)
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        for field_ in self.field:
            namespaceprefix_ = self.field_nsprefix_ + ':' if (UseCapturedNS_ and self.field_nsprefix_) else ''
            field_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='field', pretty_print=pretty_print)
        if self.alternateRegisters is not None:
            namespaceprefix_ = self.alternateRegisters_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateRegisters_nsprefix_) else ''
            self.alternateRegisters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='alternateRegisters', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType52.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'dim':
            obj_ = dimType53.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dim.append(obj_)
            obj_.original_tagname_ = 'dim'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'typeIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeIdentifier')
            value_ = self.gds_validate_string(value_, node, 'typeIdentifier')
            self.typeIdentifier = value_
            self.typeIdentifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'size':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.size = obj_
            obj_.original_tagname_ = 'size'
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'field':
            obj_ = fieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        elif nodeName_ == 'alternateRegisters':
            obj_ = alternateRegisters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateRegisters = obj_
            obj_.original_tagname_ = 'alternateRegisters'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class registerType51


class accessHandlesType52(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'indexedAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType52)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType52.subclass:
            return accessHandlesType52.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType52(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType52', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType52')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType52':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType52')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType52', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType52'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType52', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType52


class alternateRegisterType(GeneratedsSuper):
    """name -- Unique name
    alternateGroups -- Defines a list of grouping names that this register description belongs.
    typeIdentifier -- Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the alternateRegisterDefinitionGroup.
    field -- Describes individual bit fields within the register.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType54', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType54'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('alternateGroups', 'alternateGroupsType', 0, 0, {'name': 'alternateGroups', 'type': 'alternateGroupsType'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'typeIdentifier', 'type': 'xs:Name'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('field', 'fieldType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'field', 'type': 'fieldType'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, alternateGroups=None, typeIdentifier=None, volatile=None, access=None, field=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        self.alternateGroups = alternateGroups
        self.alternateGroups_nsprefix_ = None
        self.typeIdentifier = typeIdentifier
        self.typeIdentifier_nsprefix_ = None
        self.volatile = volatile
        self.volatile_nsprefix_ = None
        self.access = access
        self.access_nsprefix_ = None
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = None
        self.parameters = parameters
        self.parameters_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateRegisterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateRegisterType.subclass:
            return alternateRegisterType.subclass(*args_, **kwargs_)
        else:
            return alternateRegisterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_alternateGroups(self):
        return self.alternateGroups
    def set_alternateGroups(self, alternateGroups):
        self.alternateGroups = alternateGroups
    def get_typeIdentifier(self):
        return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier):
        self.typeIdentifier = typeIdentifier
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def add_field(self, value):
        self.field.append(value)
    def insert_field_at(self, index, value):
        self.field.insert(index, value)
    def replace_field_at(self, index, value):
        self.field[index] = value
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.alternateGroups is not None or
            self.typeIdentifier is not None or
            self.volatile is not None or
            self.access is not None or
            self.field or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='alternateRegisterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateRegisterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateRegisterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateRegisterType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateRegisterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateRegisterType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='alternateRegisterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.alternateGroups is not None:
            namespaceprefix_ = self.alternateGroups_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateGroups_nsprefix_) else ''
            self.alternateGroups.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateGroups', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            namespaceprefix_ = self.typeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.typeIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stypeIdentifier>%s</%stypeIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), namespaceprefix_ , eol_))
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        for field_ in self.field:
            namespaceprefix_ = self.field_nsprefix_ + ':' if (UseCapturedNS_ and self.field_nsprefix_) else ''
            field_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='field', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType54.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'alternateGroups':
            obj_ = alternateGroupsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateGroups = obj_
            obj_.original_tagname_ = 'alternateGroups'
        elif nodeName_ == 'typeIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeIdentifier')
            value_ = self.gds_validate_string(value_, node, 'typeIdentifier')
            self.typeIdentifier = value_
            self.typeIdentifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'field':
            obj_ = fieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class alternateRegisterType


class accessHandlesType54(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'indexedAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType54)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType54.subclass:
            return accessHandlesType54.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType54(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType54', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType54')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType54':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType54')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType54', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType54'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType54', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType54


class alternateGroupsType(GeneratedsSuper):
    """alternateGroup -- Defines a grouping name that this register description belongs.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('alternateGroup', 'alternateGroupType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'alternateGroup', 'type': 'alternateGroupType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, alternateGroup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if alternateGroup is None:
            self.alternateGroup = []
        else:
            self.alternateGroup = alternateGroup
        self.alternateGroup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateGroupsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateGroupsType.subclass:
            return alternateGroupsType.subclass(*args_, **kwargs_)
        else:
            return alternateGroupsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alternateGroup(self):
        return self.alternateGroup
    def set_alternateGroup(self, alternateGroup):
        self.alternateGroup = alternateGroup
    def add_alternateGroup(self, value):
        self.alternateGroup.append(value)
    def insert_alternateGroup_at(self, index, value):
        self.alternateGroup.insert(index, value)
    def replace_alternateGroup_at(self, index, value):
        self.alternateGroup[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.alternateGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='alternateGroupsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateGroupsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateGroupsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateGroupsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateGroupsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateGroupsType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='alternateGroupsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateGroup_ in self.alternateGroup:
            namespaceprefix_ = self.alternateGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateGroup_nsprefix_) else ''
            alternateGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='alternateGroup', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alternateGroup':
            obj_ = alternateGroupType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateGroup.append(obj_)
            obj_.original_tagname_ = 'alternateGroup'
# end class alternateGroupsType


class alternateGroupType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateGroupType.subclass:
            return alternateGroupType.subclass(*args_, **kwargs_)
        else:
            return alternateGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='alternateGroupType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateGroupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'alternateGroupType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='alternateGroupType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='alternateGroupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='alternateGroupType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='alternateGroupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class alternateGroupType


class enumeratedValueType(GeneratedsSuper):
    """name -- Unique name
    value -- Enumerated bit field value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('usage', 'usageType55', 0, 1, {'use': 'optional', 'name': 'usage'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('value', 'stringExpression', 0, 0, {'name': 'value', 'type': 'unsignedBitVectorExpression'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, usage='read-write', id=None, name=None, displayName=None, description=None, value=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.usage = _cast(None, usage)
        self.usage_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, enumeratedValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if enumeratedValueType.subclass:
            return enumeratedValueType.subclass(*args_, **kwargs_)
        else:
            return enumeratedValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_usage(self):
        return self.usage
    def set_usage(self, usage):
        self.usage = usage
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_usageType55(self, value):
        # Validate type usageType55, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['read', 'write', 'read-write']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on usageType55' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.value is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='enumeratedValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('enumeratedValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'enumeratedValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='enumeratedValueType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='enumeratedValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='enumeratedValueType'):
        if self.usage != "read-write" and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usage), input_name='usage')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='enumeratedValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
            self.validate_usageType55(self.usage)    # validate type usageType55
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'value':
            obj_ = unsignedBitVectorExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class enumeratedValueType


class modifiedWriteValueType56(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('modify', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'modify'}),
        MemberSpec_('valueOf_', ['modifiedWriteValueType', 'xs:Name'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, modify=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modify = _cast(None, modify)
        self.modify_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, modifiedWriteValueType56)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if modifiedWriteValueType56.subclass:
            return modifiedWriteValueType56.subclass(*args_, **kwargs_)
        else:
            return modifiedWriteValueType56(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_modify(self):
        return self.modify
    def set_modify(self, modify):
        self.modify = modify
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_modifiedWriteValueType(self, value):
        result = True
        # Validate type modifiedWriteValueType, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['oneToClear', 'oneToSet', 'oneToToggle', 'zeroToClear', 'zeroToSet', 'zeroToToggle', 'clear', 'set', 'modify']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on modifiedWriteValueType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='modifiedWriteValueType56', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('modifiedWriteValueType56')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'modifiedWriteValueType56':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='modifiedWriteValueType56')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='modifiedWriteValueType56', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='modifiedWriteValueType56'):
        if self.modify is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            outfile.write(' modify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modify), input_name='modify')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='modifiedWriteValueType56', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modify', node)
        if value is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            self.modify = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class modifiedWriteValueType56


class readActionType57(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('modify', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'modify'}),
        MemberSpec_('valueOf_', ['readActionType', 'xs:Name'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, modify=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modify = _cast(None, modify)
        self.modify_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, readActionType57)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if readActionType57.subclass:
            return readActionType57.subclass(*args_, **kwargs_)
        else:
            return readActionType57(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_modify(self):
        return self.modify
    def set_modify(self, modify):
        self.modify = modify
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_readActionType(self, value):
        result = True
        # Validate type readActionType, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['clear', 'set', 'modify']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on readActionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='readActionType57', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('readActionType57')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'readActionType57':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='readActionType57')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='readActionType57', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='readActionType57'):
        if self.modify is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            outfile.write(' modify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modify), input_name='modify')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='readActionType57', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modify', node)
        if value is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            self.modify = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class readActionType57


class testableType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('testConstraint', 'testConstraintType', 0, 1, {'use': 'optional', 'name': 'testConstraint'}),
        MemberSpec_('valueOf_', 'xs:boolean', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, testConstraint='unconstrained', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.testConstraint = _cast(None, testConstraint)
        self.testConstraint_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, testableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if testableType.subclass:
            return testableType.subclass(*args_, **kwargs_)
        else:
            return testableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_testConstraint(self):
        return self.testConstraint
    def set_testConstraint(self, testConstraint):
        self.testConstraint = testConstraint
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_testConstraintType(self, value):
        # Validate type testConstraintType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['unconstrained', 'restore', 'writeAsRead', 'readOnly']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on testConstraintType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='testableType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('testableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'testableType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='testableType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='testableType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='testableType'):
        if self.testConstraint != "unconstrained" and 'testConstraint' not in already_processed:
            already_processed.add('testConstraint')
            outfile.write(' testConstraint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.testConstraint), input_name='testConstraint')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='testableType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('testConstraint', node)
        if value is not None and 'testConstraint' not in already_processed:
            already_processed.add('testConstraint')
            self.testConstraint = value
            self.validate_testConstraintType(self.testConstraint)    # validate type testConstraintType
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class testableType


class accessHandlesType58(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'indexedAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType58)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType58.subclass:
            return accessHandlesType58.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType58(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType58', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType58')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType58':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType58')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType58', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType58'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType58', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType58


class modifiedWriteValueType60(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('modify', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'modify'}),
        MemberSpec_('valueOf_', ['modifiedWriteValueType', 'xs:Name'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, modify=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modify = _cast(None, modify)
        self.modify_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, modifiedWriteValueType60)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if modifiedWriteValueType60.subclass:
            return modifiedWriteValueType60.subclass(*args_, **kwargs_)
        else:
            return modifiedWriteValueType60(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_modify(self):
        return self.modify
    def set_modify(self, modify):
        self.modify = modify
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_modifiedWriteValueType(self, value):
        result = True
        # Validate type modifiedWriteValueType, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['oneToClear', 'oneToSet', 'oneToToggle', 'zeroToClear', 'zeroToSet', 'zeroToToggle', 'clear', 'set', 'modify']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on modifiedWriteValueType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='modifiedWriteValueType60', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('modifiedWriteValueType60')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'modifiedWriteValueType60':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='modifiedWriteValueType60')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='modifiedWriteValueType60', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='modifiedWriteValueType60'):
        if self.modify is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            outfile.write(' modify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modify), input_name='modify')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='modifiedWriteValueType60', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modify', node)
        if value is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            self.modify = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class modifiedWriteValueType60


class readActionType61(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('modify', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'modify'}),
        MemberSpec_('valueOf_', ['readActionType', 'xs:Name'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, modify=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.modify = _cast(None, modify)
        self.modify_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, readActionType61)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if readActionType61.subclass:
            return readActionType61.subclass(*args_, **kwargs_)
        else:
            return readActionType61(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_modify(self):
        return self.modify
    def set_modify(self, modify):
        self.modify = modify
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_readActionType(self, value):
        result = True
        # Validate type readActionType, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['clear', 'set', 'modify']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on readActionType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='readActionType61', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('readActionType61')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'readActionType61':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='readActionType61')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='readActionType61', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='readActionType61'):
        if self.modify is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            outfile.write(' modify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modify), input_name='modify')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='readActionType61', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modify', node)
        if value is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            self.modify = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class readActionType61


class testableType62(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('testConstraint', 'testConstraintType63', 0, 1, {'use': 'optional', 'name': 'testConstraint'}),
        MemberSpec_('valueOf_', 'xs:boolean', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, testConstraint='unconstrained', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.testConstraint = _cast(None, testConstraint)
        self.testConstraint_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, testableType62)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if testableType62.subclass:
            return testableType62.subclass(*args_, **kwargs_)
        else:
            return testableType62(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_testConstraint(self):
        return self.testConstraint
    def set_testConstraint(self, testConstraint):
        self.testConstraint = testConstraint
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_testConstraintType63(self, value):
        # Validate type testConstraintType63, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['unconstrained', 'restore', 'writeAsRead', 'readOnly']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on testConstraintType63' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='testableType62', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('testableType62')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'testableType62':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='testableType62')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='testableType62', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='testableType62'):
        if self.testConstraint != "unconstrained" and 'testConstraint' not in already_processed:
            already_processed.add('testConstraint')
            outfile.write(' testConstraint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.testConstraint), input_name='testConstraint')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='testableType62', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('testConstraint', node)
        if value is not None and 'testConstraint' not in already_processed:
            already_processed.add('testConstraint')
            self.testConstraint = value
            self.validate_testConstraintType63(self.testConstraint)    # validate type testConstraintType63
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class testableType62


class registerType64(GeneratedsSuper):
    """name -- Unique name
    dim -- Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.
    addressOffset -- Offset from the address block's baseAddress or the containing register file's addressOffset, expressed as the number of addressUnitBits from the containing memoryMap or localMemoryMap.
    typeIdentifier -- Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the registerDefinitionGroup.
    size -- Width of the register in bits.
    field -- Describes individual bit fields within the register.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType65', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType65'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('dim', 'dimType66', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'dim', 'type': 'dimType66'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'name': 'addressOffset', 'type': 'unsignedLongintExpression'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'typeIdentifier', 'type': 'xs:Name'}, None),
        MemberSpec_('size', 'unsignedPositiveIntExpression', 0, 0, {'name': 'size', 'type': 'unsignedPositiveIntExpression'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('field', 'fieldType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'field', 'type': 'fieldType'}, None),
        MemberSpec_('alternateRegisters', 'alternateRegisters', 0, 1, {'minOccurs': '0', 'name': 'alternateRegisters', 'ref': 'alternateRegisters', 'type': 'alternateRegisters'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, dim=None, addressOffset=None, typeIdentifier=None, size=None, volatile=None, access=None, field=None, alternateRegisters=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        if dim is None:
            self.dim = []
        else:
            self.dim = dim
        self.dim_nsprefix_ = None
        self.addressOffset = addressOffset
        self.addressOffset_nsprefix_ = None
        self.typeIdentifier = typeIdentifier
        self.typeIdentifier_nsprefix_ = None
        self.size = size
        self.size_nsprefix_ = None
        self.volatile = volatile
        self.volatile_nsprefix_ = None
        self.access = access
        self.access_nsprefix_ = None
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = None
        self.alternateRegisters = alternateRegisters
        self.alternateRegisters_nsprefix_ = None
        self.parameters = parameters
        self.parameters_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, registerType64)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if registerType64.subclass:
            return registerType64.subclass(*args_, **kwargs_)
        else:
            return registerType64(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_dim(self):
        return self.dim
    def set_dim(self, dim):
        self.dim = dim
    def add_dim(self, value):
        self.dim.append(value)
    def insert_dim_at(self, index, value):
        self.dim.insert(index, value)
    def replace_dim_at(self, index, value):
        self.dim[index] = value
    def get_addressOffset(self):
        return self.addressOffset
    def set_addressOffset(self, addressOffset):
        self.addressOffset = addressOffset
    def get_typeIdentifier(self):
        return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier):
        self.typeIdentifier = typeIdentifier
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def add_field(self, value):
        self.field.append(value)
    def insert_field_at(self, index, value):
        self.field.insert(index, value)
    def replace_field_at(self, index, value):
        self.field[index] = value
    def get_alternateRegisters(self):
        return self.alternateRegisters
    def set_alternateRegisters(self, alternateRegisters):
        self.alternateRegisters = alternateRegisters
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.dim or
            self.addressOffset is not None or
            self.typeIdentifier is not None or
            self.size is not None or
            self.volatile is not None or
            self.access is not None or
            self.field or
            self.alternateRegisters is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='registerType64', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('registerType64')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'registerType64':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='registerType64')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='registerType64', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='registerType64'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='registerType64', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for dim_ in self.dim:
            namespaceprefix_ = self.dim_nsprefix_ + ':' if (UseCapturedNS_ and self.dim_nsprefix_) else ''
            dim_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dim', pretty_print=pretty_print)
        if self.addressOffset is not None:
            namespaceprefix_ = self.addressOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.addressOffset_nsprefix_) else ''
            self.addressOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressOffset', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            namespaceprefix_ = self.typeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.typeIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stypeIdentifier>%s</%stypeIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), namespaceprefix_ , eol_))
        if self.size is not None:
            namespaceprefix_ = self.size_nsprefix_ + ':' if (UseCapturedNS_ and self.size_nsprefix_) else ''
            self.size.export(outfile, level, namespaceprefix_, namespacedef_='', name_='size', pretty_print=pretty_print)
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        for field_ in self.field:
            namespaceprefix_ = self.field_nsprefix_ + ':' if (UseCapturedNS_ and self.field_nsprefix_) else ''
            field_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='field', pretty_print=pretty_print)
        if self.alternateRegisters is not None:
            namespaceprefix_ = self.alternateRegisters_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateRegisters_nsprefix_) else ''
            self.alternateRegisters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='alternateRegisters', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType65.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'dim':
            obj_ = dimType66.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dim.append(obj_)
            obj_.original_tagname_ = 'dim'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'typeIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeIdentifier')
            value_ = self.gds_validate_string(value_, node, 'typeIdentifier')
            self.typeIdentifier = value_
            self.typeIdentifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'size':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.size = obj_
            obj_.original_tagname_ = 'size'
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'field':
            obj_ = fieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        elif nodeName_ == 'alternateRegisters':
            obj_ = alternateRegisters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateRegisters = obj_
            obj_.original_tagname_ = 'alternateRegisters'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class registerType64


class accessHandlesType65(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'indexedAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType65)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType65.subclass:
            return accessHandlesType65.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType65(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType65', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType65')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType65':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType65')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType65', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType65'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType65', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType65


class registerType67(GeneratedsSuper):
    """name -- Unique name
    dim -- Dimensions a register array, the semantics for dim elements are the same as the C language standard for the  layout of memory in multidimensional arrays.
    addressOffset -- Offset from the address block's baseAddress or the containing register file's addressOffset, expressed as the number of addressUnitBits from the containing memoryMap or localMemoryMap.
    typeIdentifier -- Identifier name used to indicate that multiple register elements contain the exact same information for the elements in the registerDefinitionGroup.
    size -- Width of the register in bits.
    field -- Describes individual bit fields within the register.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'name': 'name', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType68', 0, 1, {'minOccurs': '0', 'name': 'accessHandles', 'type': 'accessHandlesType68'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('dim', 'dimType69', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'dim', 'type': 'dimType69'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'name': 'addressOffset', 'type': 'unsignedLongintExpression'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'name': 'typeIdentifier', 'type': 'xs:Name'}, None),
        MemberSpec_('size', 'unsignedPositiveIntExpression', 0, 0, {'name': 'size', 'type': 'unsignedPositiveIntExpression'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'name': 'volatile', 'ref': 'volatile', 'type': 'xs:boolean'}, None),
        MemberSpec_('access', 'accessType', 0, 1, {'minOccurs': '0', 'name': 'access', 'ref': 'access', 'type': 'access'}, None),
        MemberSpec_('field', 'fieldType', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'field', 'type': 'fieldType'}, None),
        MemberSpec_('alternateRegisters', 'alternateRegisters', 0, 1, {'minOccurs': '0', 'name': 'alternateRegisters', 'ref': 'alternateRegisters', 'type': 'alternateRegisters'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'name': 'parameters', 'ref': 'parameters', 'type': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'name': 'vendorExtensions', 'ref': 'vendorExtensions', 'type': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, dim=None, addressOffset=None, typeIdentifier=None, size=None, volatile=None, access=None, field=None, alternateRegisters=None, parameters=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.accessHandles = accessHandles
        self.accessHandles_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        if dim is None:
            self.dim = []
        else:
            self.dim = dim
        self.dim_nsprefix_ = None
        self.addressOffset = addressOffset
        self.addressOffset_nsprefix_ = None
        self.typeIdentifier = typeIdentifier
        self.typeIdentifier_nsprefix_ = None
        self.size = size
        self.size_nsprefix_ = None
        self.volatile = volatile
        self.volatile_nsprefix_ = None
        self.access = access
        self.access_nsprefix_ = None
        if field is None:
            self.field = []
        else:
            self.field = field
        self.field_nsprefix_ = None
        self.alternateRegisters = alternateRegisters
        self.alternateRegisters_nsprefix_ = None
        self.parameters = parameters
        self.parameters_nsprefix_ = None
        self.vendorExtensions = vendorExtensions
        self.vendorExtensions_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, registerType67)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if registerType67.subclass:
            return registerType67.subclass(*args_, **kwargs_)
        else:
            return registerType67(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_accessHandles(self):
        return self.accessHandles
    def set_accessHandles(self, accessHandles):
        self.accessHandles = accessHandles
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_dim(self):
        return self.dim
    def set_dim(self, dim):
        self.dim = dim
    def add_dim(self, value):
        self.dim.append(value)
    def insert_dim_at(self, index, value):
        self.dim.insert(index, value)
    def replace_dim_at(self, index, value):
        self.dim[index] = value
    def get_addressOffset(self):
        return self.addressOffset
    def set_addressOffset(self, addressOffset):
        self.addressOffset = addressOffset
    def get_typeIdentifier(self):
        return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier):
        self.typeIdentifier = typeIdentifier
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_volatile(self):
        return self.volatile
    def set_volatile(self, volatile):
        self.volatile = volatile
    def get_access(self):
        return self.access
    def set_access(self, access):
        self.access = access
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def add_field(self, value):
        self.field.append(value)
    def insert_field_at(self, index, value):
        self.field.insert(index, value)
    def replace_field_at(self, index, value):
        self.field[index] = value
    def get_alternateRegisters(self):
        return self.alternateRegisters
    def set_alternateRegisters(self, alternateRegisters):
        self.alternateRegisters = alternateRegisters
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def get_vendorExtensions(self):
        return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions):
        self.vendorExtensions = vendorExtensions
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.dim or
            self.addressOffset is not None or
            self.typeIdentifier is not None or
            self.size is not None or
            self.volatile is not None or
            self.access is not None or
            self.field or
            self.alternateRegisters is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='registerType67', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('registerType67')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'registerType67':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='registerType67')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='registerType67', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='registerType67'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='registerType67', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.accessHandles is not None:
            namespaceprefix_ = self.accessHandles_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandles_nsprefix_) else ''
            self.accessHandles.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for dim_ in self.dim:
            namespaceprefix_ = self.dim_nsprefix_ + ':' if (UseCapturedNS_ and self.dim_nsprefix_) else ''
            dim_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dim', pretty_print=pretty_print)
        if self.addressOffset is not None:
            namespaceprefix_ = self.addressOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.addressOffset_nsprefix_) else ''
            self.addressOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='addressOffset', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            namespaceprefix_ = self.typeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.typeIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stypeIdentifier>%s</%stypeIdentifier>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), namespaceprefix_ , eol_))
        if self.size is not None:
            namespaceprefix_ = self.size_nsprefix_ + ':' if (UseCapturedNS_ and self.size_nsprefix_) else ''
            self.size.export(outfile, level, namespaceprefix_, namespacedef_='', name_='size', pretty_print=pretty_print)
        if self.volatile is not None:
            namespaceprefix_ = self.volatile_nsprefix_ + ':' if (UseCapturedNS_ and self.volatile_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svolatile>%s</%svolatile>%s' % (namespaceprefix_ , self.gds_format_boolean(self.volatile, input_name='volatile'), namespaceprefix_ , eol_))
        if self.access is not None:
            namespaceprefix_ = self.access_nsprefix_ + ':' if (UseCapturedNS_ and self.access_nsprefix_) else ''
            self.access.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='access', pretty_print=pretty_print)
        for field_ in self.field:
            namespaceprefix_ = self.field_nsprefix_ + ':' if (UseCapturedNS_ and self.field_nsprefix_) else ''
            field_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='field', pretty_print=pretty_print)
        if self.alternateRegisters is not None:
            namespaceprefix_ = self.alternateRegisters_nsprefix_ + ':' if (UseCapturedNS_ and self.alternateRegisters_nsprefix_) else ''
            self.alternateRegisters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='alternateRegisters', pretty_print=pretty_print)
        if self.parameters is not None:
            namespaceprefix_ = self.parameters_nsprefix_ + ':' if (UseCapturedNS_ and self.parameters_nsprefix_) else ''
            self.parameters.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            namespaceprefix_ = self.vendorExtensions_nsprefix_ + ':' if (UseCapturedNS_ and self.vendorExtensions_nsprefix_) else ''
            self.vendorExtensions.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType68.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'dim':
            obj_ = dimType69.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dim.append(obj_)
            obj_.original_tagname_ = 'dim'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'typeIdentifier':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'typeIdentifier')
            value_ = self.gds_validate_string(value_, node, 'typeIdentifier')
            self.typeIdentifier = value_
            self.typeIdentifier_nsprefix_ = child_.prefix
        elif nodeName_ == 'size':
            obj_ = unsignedPositiveIntExpression.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.size = obj_
            obj_.original_tagname_ = 'size'
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'volatile')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
            self.volatile_nsprefix_ = child_.prefix
        elif nodeName_ == 'access':
            obj_ = accessType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'field':
            obj_ = fieldType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        elif nodeName_ == 'alternateRegisters':
            obj_ = alternateRegisters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.alternateRegisters = obj_
            obj_.original_tagname_ = 'alternateRegisters'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class registerType67


class accessHandlesType68(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'maxOccurs': 'unbounded', 'minOccurs': '1', 'name': 'accessHandle', 'type': 'indexedAccessHandle'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
        self.accessHandle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType68)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType68.subclass:
            return accessHandlesType68.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType68(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accessHandle(self):
        return self.accessHandle
    def set_accessHandle(self, accessHandle):
        self.accessHandle = accessHandle
    def add_accessHandle(self, value):
        self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value):
        self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value):
        self.accessHandle[index] = value
    def _hasContent(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType68', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType68')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'accessHandlesType68':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='accessHandlesType68')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='accessHandlesType68', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='accessHandlesType68'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='accessHandlesType68', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            namespaceprefix_ = self.accessHandle_nsprefix_ + ':' if (UseCapturedNS_ and self.accessHandle_nsprefix_) else ''
            accessHandle_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accessHandle', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType68


class moduleParametersType(GeneratedsSuper):
    """moduleParameter -- A module parameter name value pair. The name is given in an attribute. The value is the element value. The dataType (applicable to high level modeling) is given in the dataType attribute. For hardware based models, the name should be identical to the RTL (VHDL generic or Verilog parameter). The usageType attribute indicates how the model parameter is to be used.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('moduleParameter', 'moduleParameterType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'moduleParameter', 'type': 'moduleParameterType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, moduleParameter=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if moduleParameter is None:
            self.moduleParameter = []
        else:
            self.moduleParameter = moduleParameter
        self.moduleParameter_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, moduleParametersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if moduleParametersType.subclass:
            return moduleParametersType.subclass(*args_, **kwargs_)
        else:
            return moduleParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_moduleParameter(self):
        return self.moduleParameter
    def set_moduleParameter(self, moduleParameter):
        self.moduleParameter = moduleParameter
    def add_moduleParameter(self, value):
        self.moduleParameter.append(value)
    def insert_moduleParameter_at(self, index, value):
        self.moduleParameter.insert(index, value)
    def replace_moduleParameter_at(self, index, value):
        self.moduleParameter[index] = value
    def _hasContent(self):
        if (
            self.moduleParameter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='moduleParametersType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('moduleParametersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'moduleParametersType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='moduleParametersType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='moduleParametersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='moduleParametersType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='moduleParametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for moduleParameter_ in self.moduleParameter:
            namespaceprefix_ = self.moduleParameter_nsprefix_ + ':' if (UseCapturedNS_ and self.moduleParameter_nsprefix_) else ''
            moduleParameter_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='moduleParameter', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'moduleParameter':
            obj_ = moduleParameterType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.moduleParameter.append(obj_)
            obj_.original_tagname_ = 'moduleParameter'
# end class moduleParametersType


class whiteboxElementRefsType(GeneratedsSuper):
    """whiteboxElementRef --  Reference to a white box element which is visible within this view.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('whiteboxElementRef', 'whiteboxElementRefType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'whiteboxElementRef', 'type': 'whiteboxElementRefType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, whiteboxElementRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if whiteboxElementRef is None:
            self.whiteboxElementRef = []
        else:
            self.whiteboxElementRef = whiteboxElementRef
        self.whiteboxElementRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, whiteboxElementRefsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if whiteboxElementRefsType.subclass:
            return whiteboxElementRefsType.subclass(*args_, **kwargs_)
        else:
            return whiteboxElementRefsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_whiteboxElementRef(self):
        return self.whiteboxElementRef
    def set_whiteboxElementRef(self, whiteboxElementRef):
        self.whiteboxElementRef = whiteboxElementRef
    def add_whiteboxElementRef(self, value):
        self.whiteboxElementRef.append(value)
    def insert_whiteboxElementRef_at(self, index, value):
        self.whiteboxElementRef.insert(index, value)
    def replace_whiteboxElementRef_at(self, index, value):
        self.whiteboxElementRef[index] = value
    def _hasContent(self):
        if (
            self.whiteboxElementRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='whiteboxElementRefsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('whiteboxElementRefsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'whiteboxElementRefsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='whiteboxElementRefsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='whiteboxElementRefsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='whiteboxElementRefsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='whiteboxElementRefsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for whiteboxElementRef_ in self.whiteboxElementRef:
            namespaceprefix_ = self.whiteboxElementRef_nsprefix_ + ':' if (UseCapturedNS_ and self.whiteboxElementRef_nsprefix_) else ''
            whiteboxElementRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='whiteboxElementRef', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'whiteboxElementRef':
            obj_ = whiteboxElementRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.whiteboxElementRef.append(obj_)
            obj_.original_tagname_ = 'whiteboxElementRef'
# end class whiteboxElementRefsType


class viewsType(GeneratedsSuper):
    """view -- Single view of a component
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('view', 'viewType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'view', 'type': 'viewType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, view=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if view is None:
            self.view = []
        else:
            self.view = view
        self.view_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewsType.subclass:
            return viewsType.subclass(*args_, **kwargs_)
        else:
            return viewsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_view(self):
        return self.view
    def set_view(self, view):
        self.view = view
    def add_view(self, value):
        self.view.append(value)
    def insert_view_at(self, index, value):
        self.view.insert(index, value)
    def replace_view_at(self, index, value):
        self.view[index] = value
    def _hasContent(self):
        if (
            self.view
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for view_ in self.view:
            namespaceprefix_ = self.view_nsprefix_ + ':' if (UseCapturedNS_ and self.view_nsprefix_) else ''
            view_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='view', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'view':
            obj_ = viewType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.view.append(obj_)
            obj_.original_tagname_ = 'view'
# end class viewsType


class viewType(GeneratedsSuper):
    """name -- Unique name
    envIdentifier --  Defines the hardware environment in which this view applies. The format of the string is language:tool:vendor_extension, with each piece being optional. The language must be one of the types from ipxact:fileType. The tool values are defined by the Accellera Systems Initiative, and include generic values "*Simulation" and "*Synthesis" to imply any tool of the indicated type. Having more than one envIdentifier indicates that the view applies to multiple environments.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('envIdentifier', 'envIdentifierType70', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'envIdentifier', 'type': 'envIdentifierType70'}, None),
        MemberSpec_('componentInstantiationRef', 'xs:NMTOKEN', 0, 1, {'minOccurs': '0', 'name': 'componentInstantiationRef', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('designInstantiationRef', 'xs:NMTOKEN', 0, 1, {'minOccurs': '0', 'name': 'designInstantiationRef', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('designConfigurationInstantiationRef', 'xs:NMTOKEN', 0, 1, {'minOccurs': '0', 'name': 'designConfigurationInstantiationRef', 'type': 'xs:NMTOKEN'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, isPresent=None, envIdentifier=None, componentInstantiationRef=None, designInstantiationRef=None, designConfigurationInstantiationRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        if envIdentifier is None:
            self.envIdentifier = []
        else:
            self.envIdentifier = envIdentifier
        self.envIdentifier_nsprefix_ = None
        self.componentInstantiationRef = componentInstantiationRef
        self.componentInstantiationRef_nsprefix_ = None
        self.designInstantiationRef = designInstantiationRef
        self.designInstantiationRef_nsprefix_ = None
        self.designConfigurationInstantiationRef = designConfigurationInstantiationRef
        self.designConfigurationInstantiationRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewType.subclass:
            return viewType.subclass(*args_, **kwargs_)
        else:
            return viewType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_envIdentifier(self):
        return self.envIdentifier
    def set_envIdentifier(self, envIdentifier):
        self.envIdentifier = envIdentifier
    def add_envIdentifier(self, value):
        self.envIdentifier.append(value)
    def insert_envIdentifier_at(self, index, value):
        self.envIdentifier.insert(index, value)
    def replace_envIdentifier_at(self, index, value):
        self.envIdentifier[index] = value
    def get_componentInstantiationRef(self):
        return self.componentInstantiationRef
    def set_componentInstantiationRef(self, componentInstantiationRef):
        self.componentInstantiationRef = componentInstantiationRef
    def get_designInstantiationRef(self):
        return self.designInstantiationRef
    def set_designInstantiationRef(self, designInstantiationRef):
        self.designInstantiationRef = designInstantiationRef
    def get_designConfigurationInstantiationRef(self):
        return self.designConfigurationInstantiationRef
    def set_designConfigurationInstantiationRef(self, designConfigurationInstantiationRef):
        self.designConfigurationInstantiationRef = designConfigurationInstantiationRef
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.envIdentifier or
            self.componentInstantiationRef is not None or
            self.designInstantiationRef is not None or
            self.designConfigurationInstantiationRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for envIdentifier_ in self.envIdentifier:
            namespaceprefix_ = self.envIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.envIdentifier_nsprefix_) else ''
            envIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='envIdentifier', pretty_print=pretty_print)
        if self.componentInstantiationRef is not None:
            namespaceprefix_ = self.componentInstantiationRef_nsprefix_ + ':' if (UseCapturedNS_ and self.componentInstantiationRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomponentInstantiationRef>%s</%scomponentInstantiationRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.componentInstantiationRef), input_name='componentInstantiationRef')), namespaceprefix_ , eol_))
        if self.designInstantiationRef is not None:
            namespaceprefix_ = self.designInstantiationRef_nsprefix_ + ':' if (UseCapturedNS_ and self.designInstantiationRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdesignInstantiationRef>%s</%sdesignInstantiationRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.designInstantiationRef), input_name='designInstantiationRef')), namespaceprefix_ , eol_))
        if self.designConfigurationInstantiationRef is not None:
            namespaceprefix_ = self.designConfigurationInstantiationRef_nsprefix_ + ':' if (UseCapturedNS_ and self.designConfigurationInstantiationRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdesignConfigurationInstantiationRef>%s</%sdesignConfigurationInstantiationRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.designConfigurationInstantiationRef), input_name='designConfigurationInstantiationRef')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'envIdentifier':
            obj_ = envIdentifierType70.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.envIdentifier.append(obj_)
            obj_.original_tagname_ = 'envIdentifier'
        elif nodeName_ == 'componentInstantiationRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'componentInstantiationRef')
            value_ = self.gds_validate_string(value_, node, 'componentInstantiationRef')
            self.componentInstantiationRef = value_
            self.componentInstantiationRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'designInstantiationRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'designInstantiationRef')
            value_ = self.gds_validate_string(value_, node, 'designInstantiationRef')
            self.designInstantiationRef = value_
            self.designInstantiationRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'designConfigurationInstantiationRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'designConfigurationInstantiationRef')
            value_ = self.gds_validate_string(value_, node, 'designConfigurationInstantiationRef')
            self.designConfigurationInstantiationRef = value_
            self.designConfigurationInstantiationRef_nsprefix_ = child_.prefix
# end class viewType


class envIdentifierType70(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', ['envIdentifierType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, envIdentifierType70)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if envIdentifierType70.subclass:
            return envIdentifierType70.subclass(*args_, **kwargs_)
        else:
            return envIdentifierType70(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_envIdentifierType(self, value):
        result = True
        # Validate type envIdentifierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_envIdentifierType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_envIdentifierType_patterns_, ))
                result = False
        return result
    validate_envIdentifierType_patterns_ = [['^([a-zA-Z0-9_+\\*\\.]*:[a-zA-Z0-9_+\\*\\.]*:[a-zA-Z0-9_+\\*\\.]*)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='envIdentifierType70', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('envIdentifierType70')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'envIdentifierType70':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='envIdentifierType70')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='envIdentifierType70', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='envIdentifierType70'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='envIdentifierType70', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class envIdentifierType70


class instantiationsType(GeneratedsSuper):
    """componentInstantiation -- Component Instantiation
    designInstantiation -- Design Instantiation
    designConfigurationInstantiation -- Design Configuration Instantiation
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('componentInstantiation', 'componentInstantiationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'componentInstantiation', 'type': 'componentInstantiationType'}, 35),
        MemberSpec_('designInstantiation', 'designInstantiationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'designInstantiation', 'type': 'designInstantiationType'}, 35),
        MemberSpec_('designConfigurationInstantiation', 'designConfigurationInstantiationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'designConfigurationInstantiation', 'type': 'designConfigurationInstantiationType'}, 35),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentInstantiation=None, designInstantiation=None, designConfigurationInstantiation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if componentInstantiation is None:
            self.componentInstantiation = []
        else:
            self.componentInstantiation = componentInstantiation
        self.componentInstantiation_nsprefix_ = None
        if designInstantiation is None:
            self.designInstantiation = []
        else:
            self.designInstantiation = designInstantiation
        self.designInstantiation_nsprefix_ = None
        if designConfigurationInstantiation is None:
            self.designConfigurationInstantiation = []
        else:
            self.designConfigurationInstantiation = designConfigurationInstantiation
        self.designConfigurationInstantiation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instantiationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instantiationsType.subclass:
            return instantiationsType.subclass(*args_, **kwargs_)
        else:
            return instantiationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_componentInstantiation(self):
        return self.componentInstantiation
    def set_componentInstantiation(self, componentInstantiation):
        self.componentInstantiation = componentInstantiation
    def add_componentInstantiation(self, value):
        self.componentInstantiation.append(value)
    def insert_componentInstantiation_at(self, index, value):
        self.componentInstantiation.insert(index, value)
    def replace_componentInstantiation_at(self, index, value):
        self.componentInstantiation[index] = value
    def get_designInstantiation(self):
        return self.designInstantiation
    def set_designInstantiation(self, designInstantiation):
        self.designInstantiation = designInstantiation
    def add_designInstantiation(self, value):
        self.designInstantiation.append(value)
    def insert_designInstantiation_at(self, index, value):
        self.designInstantiation.insert(index, value)
    def replace_designInstantiation_at(self, index, value):
        self.designInstantiation[index] = value
    def get_designConfigurationInstantiation(self):
        return self.designConfigurationInstantiation
    def set_designConfigurationInstantiation(self, designConfigurationInstantiation):
        self.designConfigurationInstantiation = designConfigurationInstantiation
    def add_designConfigurationInstantiation(self, value):
        self.designConfigurationInstantiation.append(value)
    def insert_designConfigurationInstantiation_at(self, index, value):
        self.designConfigurationInstantiation.insert(index, value)
    def replace_designConfigurationInstantiation_at(self, index, value):
        self.designConfigurationInstantiation[index] = value
    def _hasContent(self):
        if (
            self.componentInstantiation or
            self.designInstantiation or
            self.designConfigurationInstantiation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='instantiationsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instantiationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'instantiationsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instantiationsType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='instantiationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='instantiationsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='instantiationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for componentInstantiation_ in self.componentInstantiation:
            namespaceprefix_ = self.componentInstantiation_nsprefix_ + ':' if (UseCapturedNS_ and self.componentInstantiation_nsprefix_) else ''
            componentInstantiation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='componentInstantiation', pretty_print=pretty_print)
        for designInstantiation_ in self.designInstantiation:
            namespaceprefix_ = self.designInstantiation_nsprefix_ + ':' if (UseCapturedNS_ and self.designInstantiation_nsprefix_) else ''
            designInstantiation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='designInstantiation', pretty_print=pretty_print)
        for designConfigurationInstantiation_ in self.designConfigurationInstantiation:
            namespaceprefix_ = self.designConfigurationInstantiation_nsprefix_ + ':' if (UseCapturedNS_ and self.designConfigurationInstantiation_nsprefix_) else ''
            designConfigurationInstantiation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='designConfigurationInstantiation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'componentInstantiation':
            obj_ = componentInstantiationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.componentInstantiation.append(obj_)
            obj_.original_tagname_ = 'componentInstantiation'
        elif nodeName_ == 'designInstantiation':
            obj_ = designInstantiationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.designInstantiation.append(obj_)
            obj_.original_tagname_ = 'designInstantiation'
        elif nodeName_ == 'designConfigurationInstantiation':
            obj_ = designConfigurationInstantiationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.designConfigurationInstantiation.append(obj_)
            obj_.original_tagname_ = 'designConfigurationInstantiation'
# end class instantiationsType


class portsType71(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('port', 'portType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'port', 'ref': 'port', 'type': 'port'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, port=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if port is None:
            self.port = []
        else:
            self.port = port
        self.port_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portsType71)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portsType71.subclass:
            return portsType71.subclass(*args_, **kwargs_)
        else:
            return portsType71(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    def add_port(self, value):
        self.port.append(value)
    def insert_port_at(self, index, value):
        self.port.insert(index, value)
    def replace_port_at(self, index, value):
        self.port[index] = value
    def _hasContent(self):
        if (
            self.port
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portsType71', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portsType71')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'portsType71':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='portsType71')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='portsType71', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='portsType71'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portsType71', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for port_ in self.port:
            namespaceprefix_ = self.port_nsprefix_ + ':' if (UseCapturedNS_ and self.port_nsprefix_) else ''
            port_.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='port', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'port':
            obj_ = Port.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.port.append(obj_)
            obj_.original_tagname_ = 'port'
# end class portsType71


class viewsType72(GeneratedsSuper):
    """view -- Single view of an abstracto
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('view', 'viewType73', 1, 0, {'maxOccurs': 'unbounded', 'name': 'view', 'type': 'viewType73'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, view=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if view is None:
            self.view = []
        else:
            self.view = view
        self.view_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewsType72)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewsType72.subclass:
            return viewsType72.subclass(*args_, **kwargs_)
        else:
            return viewsType72(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_view(self):
        return self.view
    def set_view(self, view):
        self.view = view
    def add_view(self, value):
        self.view.append(value)
    def insert_view_at(self, index, value):
        self.view.insert(index, value)
    def replace_view_at(self, index, value):
        self.view[index] = value
    def _hasContent(self):
        if (
            self.view
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewsType72', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewsType72')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewsType72':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewsType72')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewsType72', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewsType72'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewsType72', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for view_ in self.view:
            namespaceprefix_ = self.view_nsprefix_ + ':' if (UseCapturedNS_ and self.view_nsprefix_) else ''
            view_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='view', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'view':
            obj_ = viewType73.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.view.append(obj_)
            obj_.original_tagname_ = 'view'
# end class viewsType72


class viewType73(GeneratedsSuper):
    """name -- Unique name
    envIdentifier --  Defines the hardware environment in which this view applies. The format of the string is language:tool:vendor_extension, with each piece being optional. The language must be one of the types from ipxact:fileType. The tool values are defined by the Accellera Systems Initiative, and include generic values "*Simulation" and "*Synthesis" to imply any tool of the indicated type. Having more than one envIdentifier indicates that the view applies to multiple environments.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'name': 'name', 'type': 'xs:NMTOKEN'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('envIdentifier', 'envIdentifierType74', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'envIdentifier', 'type': 'envIdentifierType74'}, None),
        MemberSpec_('componentInstantiationRef', 'xs:NMTOKEN', 0, 1, {'minOccurs': '0', 'name': 'componentInstantiationRef', 'type': 'xs:NMTOKEN'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, isPresent=None, envIdentifier=None, componentInstantiationRef=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.name = name
        self.name_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        if envIdentifier is None:
            self.envIdentifier = []
        else:
            self.envIdentifier = envIdentifier
        self.envIdentifier_nsprefix_ = None
        self.componentInstantiationRef = componentInstantiationRef
        self.componentInstantiationRef_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewType73)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewType73.subclass:
            return viewType73.subclass(*args_, **kwargs_)
        else:
            return viewType73(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_envIdentifier(self):
        return self.envIdentifier
    def set_envIdentifier(self, envIdentifier):
        self.envIdentifier = envIdentifier
    def add_envIdentifier(self, value):
        self.envIdentifier.append(value)
    def insert_envIdentifier_at(self, index, value):
        self.envIdentifier.insert(index, value)
    def replace_envIdentifier_at(self, index, value):
        self.envIdentifier[index] = value
    def get_componentInstantiationRef(self):
        return self.componentInstantiationRef
    def set_componentInstantiationRef(self, componentInstantiationRef):
        self.componentInstantiationRef = componentInstantiationRef
    def _hasContent(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.envIdentifier or
            self.componentInstantiationRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewType73', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewType73')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewType73':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewType73')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewType73', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewType73'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewType73', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            namespaceprefix_ = self.name_nsprefix_ + ':' if (UseCapturedNS_ and self.name_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for envIdentifier_ in self.envIdentifier:
            namespaceprefix_ = self.envIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.envIdentifier_nsprefix_) else ''
            envIdentifier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='envIdentifier', pretty_print=pretty_print)
        if self.componentInstantiationRef is not None:
            namespaceprefix_ = self.componentInstantiationRef_nsprefix_ + ':' if (UseCapturedNS_ and self.componentInstantiationRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scomponentInstantiationRef>%s</%scomponentInstantiationRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.componentInstantiationRef), input_name='componentInstantiationRef')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'name':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'name')
            value_ = self.gds_validate_string(value_, node, 'name')
            self.name = value_
            self.name_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'envIdentifier':
            obj_ = envIdentifierType74.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.envIdentifier.append(obj_)
            obj_.original_tagname_ = 'envIdentifier'
        elif nodeName_ == 'componentInstantiationRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'componentInstantiationRef')
            value_ = self.gds_validate_string(value_, node, 'componentInstantiationRef')
            self.componentInstantiationRef = value_
            self.componentInstantiationRef_nsprefix_ = child_.prefix
# end class viewType73


class envIdentifierType74(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', ['envIdentifierType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, envIdentifierType74)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if envIdentifierType74.subclass:
            return envIdentifierType74.subclass(*args_, **kwargs_)
        else:
            return envIdentifierType74(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_envIdentifierType(self, value):
        result = True
        # Validate type envIdentifierType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_envIdentifierType_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_envIdentifierType_patterns_, ))
                result = False
        return result
    validate_envIdentifierType_patterns_ = [['^([a-zA-Z0-9_+\\*\\.]*:[a-zA-Z0-9_+\\*\\.]*:[a-zA-Z0-9_+\\*\\.]*)$']]
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='envIdentifierType74', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('envIdentifierType74')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'envIdentifierType74':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='envIdentifierType74')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='envIdentifierType74', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='envIdentifierType74'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='envIdentifierType74', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class envIdentifierType74


class instantiationsType75(GeneratedsSuper):
    """componentInstantiation -- Component Instantiation
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('componentInstantiation', 'componentInstantiationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'componentInstantiation', 'type': 'componentInstantiationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentInstantiation=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if componentInstantiation is None:
            self.componentInstantiation = []
        else:
            self.componentInstantiation = componentInstantiation
        self.componentInstantiation_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instantiationsType75)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instantiationsType75.subclass:
            return instantiationsType75.subclass(*args_, **kwargs_)
        else:
            return instantiationsType75(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_componentInstantiation(self):
        return self.componentInstantiation
    def set_componentInstantiation(self, componentInstantiation):
        self.componentInstantiation = componentInstantiation
    def add_componentInstantiation(self, value):
        self.componentInstantiation.append(value)
    def insert_componentInstantiation_at(self, index, value):
        self.componentInstantiation.insert(index, value)
    def replace_componentInstantiation_at(self, index, value):
        self.componentInstantiation[index] = value
    def _hasContent(self):
        if (
            self.componentInstantiation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='instantiationsType75', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instantiationsType75')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'instantiationsType75':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instantiationsType75')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='instantiationsType75', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='instantiationsType75'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='instantiationsType75', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for componentInstantiation_ in self.componentInstantiation:
            namespaceprefix_ = self.componentInstantiation_nsprefix_ + ':' if (UseCapturedNS_ and self.componentInstantiation_nsprefix_) else ''
            componentInstantiation_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='componentInstantiation', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'componentInstantiation':
            obj_ = componentInstantiationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.componentInstantiation.append(obj_)
            obj_.original_tagname_ = 'componentInstantiation'
# end class instantiationsType75


class portsType76(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('port', 'portType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'port', 'type': 'abstractorPortType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, port=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if port is None:
            self.port = []
        else:
            self.port = port
        self.port_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portsType76)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portsType76.subclass:
            return portsType76.subclass(*args_, **kwargs_)
        else:
            return portsType76(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    def add_port(self, value):
        self.port.append(value)
    def insert_port_at(self, index, value):
        self.port.insert(index, value)
    def replace_port_at(self, index, value):
        self.port[index] = value
    def _hasContent(self):
        if (
            self.port
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portsType76', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portsType76')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'portsType76':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='portsType76')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='portsType76', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='portsType76'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='portsType76', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for port_ in self.port:
            namespaceprefix_ = self.port_nsprefix_ + ':' if (UseCapturedNS_ and self.port_nsprefix_) else ''
            port_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='port', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'port':
            obj_ = abstractorPortType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.port.append(obj_)
            obj_.original_tagname_ = 'port'
# end class portsType76


class interconnectionConfigurationType(GeneratedsSuper):
    """interconnectionRef -- Reference to the interconnection name, monitor interconnection name or possibly a hierConnection interfaceName in a design file.
    abstractorInstances -- List of abstractor-instances for this interconnection. Multiple abstractor-instances elements may be present for a 1-to-many (broadcast) interconnection. In that case, the optional interfaceRef elements must reference non-overlapping interfaces from the 'many' side of the interconnection.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('interconnectionRef', 'xs:Name', 0, 0, {'name': 'interconnectionRef', 'type': 'xs:Name'}, None),
        MemberSpec_('abstractorInstances', 'abstractorInstancesType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'abstractorInstances', 'type': 'abstractorInstancesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, isPresent=None, interconnectionRef=None, abstractorInstances=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        self.interconnectionRef = interconnectionRef
        self.interconnectionRef_nsprefix_ = None
        if abstractorInstances is None:
            self.abstractorInstances = []
        else:
            self.abstractorInstances = abstractorInstances
        self.abstractorInstances_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interconnectionConfigurationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interconnectionConfigurationType.subclass:
            return interconnectionConfigurationType.subclass(*args_, **kwargs_)
        else:
            return interconnectionConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_interconnectionRef(self):
        return self.interconnectionRef
    def set_interconnectionRef(self, interconnectionRef):
        self.interconnectionRef = interconnectionRef
    def get_abstractorInstances(self):
        return self.abstractorInstances
    def set_abstractorInstances(self, abstractorInstances):
        self.abstractorInstances = abstractorInstances
    def add_abstractorInstances(self, value):
        self.abstractorInstances.append(value)
    def insert_abstractorInstances_at(self, index, value):
        self.abstractorInstances.insert(index, value)
    def replace_abstractorInstances_at(self, index, value):
        self.abstractorInstances[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.isPresent is not None or
            self.interconnectionRef is not None or
            self.abstractorInstances
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='interconnectionConfigurationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('interconnectionConfigurationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'interconnectionConfigurationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='interconnectionConfigurationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='interconnectionConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='interconnectionConfigurationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='interconnectionConfigurationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.interconnectionRef is not None:
            namespaceprefix_ = self.interconnectionRef_nsprefix_ + ':' if (UseCapturedNS_ and self.interconnectionRef_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinterconnectionRef>%s</%sinterconnectionRef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.interconnectionRef), input_name='interconnectionRef')), namespaceprefix_ , eol_))
        for abstractorInstances_ in self.abstractorInstances:
            namespaceprefix_ = self.abstractorInstances_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractorInstances_nsprefix_) else ''
            abstractorInstances_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstractorInstances', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'interconnectionRef':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'interconnectionRef')
            value_ = self.gds_validate_string(value_, node, 'interconnectionRef')
            self.interconnectionRef = value_
            self.interconnectionRef_nsprefix_ = child_.prefix
        elif nodeName_ == 'abstractorInstances':
            obj_ = abstractorInstancesType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractorInstances.append(obj_)
            obj_.original_tagname_ = 'abstractorInstances'
# end class interconnectionConfigurationType


class abstractorInstancesType(GeneratedsSuper):
    """interfaceRef -- Defines the broadcast endpoint to which this chain of abstractors applies.
    abstractorInstance -- Element to hold a the abstractor reference, the configuration and viewName. If multiple elements are present then the order is the order in which the abstractors should be chained together.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('interfaceRef', 'interfaceRefType', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'interfaceRef', 'type': 'interfaceRefType'}, None),
        MemberSpec_('abstractorInstance', 'abstractorInstanceType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'abstractorInstance', 'type': 'abstractorInstanceType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, isPresent=None, interfaceRef=None, abstractorInstance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        if interfaceRef is None:
            self.interfaceRef = []
        else:
            self.interfaceRef = interfaceRef
        self.interfaceRef_nsprefix_ = None
        if abstractorInstance is None:
            self.abstractorInstance = []
        else:
            self.abstractorInstance = abstractorInstance
        self.abstractorInstance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorInstancesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorInstancesType.subclass:
            return abstractorInstancesType.subclass(*args_, **kwargs_)
        else:
            return abstractorInstancesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_interfaceRef(self):
        return self.interfaceRef
    def set_interfaceRef(self, interfaceRef):
        self.interfaceRef = interfaceRef
    def add_interfaceRef(self, value):
        self.interfaceRef.append(value)
    def insert_interfaceRef_at(self, index, value):
        self.interfaceRef.insert(index, value)
    def replace_interfaceRef_at(self, index, value):
        self.interfaceRef[index] = value
    def get_abstractorInstance(self):
        return self.abstractorInstance
    def set_abstractorInstance(self, abstractorInstance):
        self.abstractorInstance = abstractorInstance
    def add_abstractorInstance(self, value):
        self.abstractorInstance.append(value)
    def insert_abstractorInstance_at(self, index, value):
        self.abstractorInstance.insert(index, value)
    def replace_abstractorInstance_at(self, index, value):
        self.abstractorInstance[index] = value
    def _hasContent(self):
        if (
            self.isPresent is not None or
            self.interfaceRef or
            self.abstractorInstance
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorInstancesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorInstancesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractorInstancesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractorInstancesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractorInstancesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='abstractorInstancesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorInstancesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        for interfaceRef_ in self.interfaceRef:
            namespaceprefix_ = self.interfaceRef_nsprefix_ + ':' if (UseCapturedNS_ and self.interfaceRef_nsprefix_) else ''
            interfaceRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interfaceRef', pretty_print=pretty_print)
        for abstractorInstance_ in self.abstractorInstance:
            namespaceprefix_ = self.abstractorInstance_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractorInstance_nsprefix_) else ''
            abstractorInstance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstractorInstance', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'interfaceRef':
            obj_ = interfaceRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interfaceRef.append(obj_)
            obj_.original_tagname_ = 'interfaceRef'
        elif nodeName_ == 'abstractorInstance':
            obj_ = abstractorInstanceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractorInstance.append(obj_)
            obj_.original_tagname_ = 'abstractorInstance'
# end class abstractorInstancesType


class interfaceRefType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('componentRef', 'xs:Name', 0, 0, {'use': 'required', 'name': 'componentRef'}),
        MemberSpec_('busRef', 'xs:Name', 0, 0, {'use': 'required', 'name': 'busRef'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentRef=None, busRef=None, isPresent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.componentRef = _cast(None, componentRef)
        self.componentRef_nsprefix_ = None
        self.busRef = _cast(None, busRef)
        self.busRef_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interfaceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interfaceRefType.subclass:
            return interfaceRefType.subclass(*args_, **kwargs_)
        else:
            return interfaceRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_componentRef(self):
        return self.componentRef
    def set_componentRef(self, componentRef):
        self.componentRef = componentRef
    def get_busRef(self):
        return self.busRef
    def set_busRef(self, busRef):
        self.busRef = busRef
    def _hasContent(self):
        if (
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='interfaceRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('interfaceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'interfaceRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='interfaceRefType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='interfaceRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='interfaceRefType'):
        if self.componentRef is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            outfile.write(' componentRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.componentRef), input_name='componentRef')), ))
        if self.busRef is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            outfile.write(' busRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.busRef), input_name='busRef')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='interfaceRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('componentRef', node)
        if value is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            self.componentRef = value
        value = find_attr_value_('busRef', node)
        if value is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            self.busRef = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class interfaceRefType


class abstractorInstanceType(GeneratedsSuper):
    """instanceName -- Instance name for the abstractor
    abstractorRef -- Abstractor reference
    viewName -- The name of the active view for this abstractor instance.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('instanceName', 'xs:Name', 0, 0, {'name': 'instanceName', 'type': 'xs:Name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'displayName', 'ref': 'displayName', 'type': 'xs:string'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'name': 'description', 'ref': 'description', 'type': 'xs:string'}, None),
        MemberSpec_('abstractorRef', 'configurableLibraryRefType', 0, 0, {'name': 'abstractorRef', 'type': 'configurableLibraryRefType'}, None),
        MemberSpec_('viewName', 'xs:Name', 0, 0, {'name': 'viewName', 'type': 'xs:Name'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, instanceName=None, displayName=None, description=None, abstractorRef=None, viewName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.instanceName = instanceName
        self.instanceName_nsprefix_ = None
        self.displayName = displayName
        self.displayName_nsprefix_ = None
        self.description = description
        self.description_nsprefix_ = None
        self.abstractorRef = abstractorRef
        self.abstractorRef_nsprefix_ = None
        self.viewName = viewName
        self.viewName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorInstanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorInstanceType.subclass:
            return abstractorInstanceType.subclass(*args_, **kwargs_)
        else:
            return abstractorInstanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_instanceName(self):
        return self.instanceName
    def set_instanceName(self, instanceName):
        self.instanceName = instanceName
    def get_displayName(self):
        return self.displayName
    def set_displayName(self, displayName):
        self.displayName = displayName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_abstractorRef(self):
        return self.abstractorRef
    def set_abstractorRef(self, abstractorRef):
        self.abstractorRef = abstractorRef
    def get_viewName(self):
        return self.viewName
    def set_viewName(self, viewName):
        self.viewName = viewName
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.instanceName is not None or
            self.displayName is not None or
            self.description is not None or
            self.abstractorRef is not None or
            self.viewName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorInstanceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorInstanceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractorInstanceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractorInstanceType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractorInstanceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='abstractorInstanceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorInstanceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.instanceName is not None:
            namespaceprefix_ = self.instanceName_nsprefix_ + ':' if (UseCapturedNS_ and self.instanceName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstanceName>%s</%sinstanceName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.instanceName), input_name='instanceName')), namespaceprefix_ , eol_))
        if self.displayName is not None:
            namespaceprefix_ = self.displayName_nsprefix_ + ':' if (UseCapturedNS_ and self.displayName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplayName>%s</%sdisplayName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), namespaceprefix_ , eol_))
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.abstractorRef is not None:
            namespaceprefix_ = self.abstractorRef_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractorRef_nsprefix_) else ''
            self.abstractorRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstractorRef', pretty_print=pretty_print)
        if self.viewName is not None:
            namespaceprefix_ = self.viewName_nsprefix_ + ':' if (UseCapturedNS_ and self.viewName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sviewName>%s</%sviewName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.viewName), input_name='viewName')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'instanceName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'instanceName')
            value_ = self.gds_validate_string(value_, node, 'instanceName')
            self.instanceName = value_
            self.instanceName_nsprefix_ = child_.prefix
        elif nodeName_ == 'displayName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'displayName')
            value_ = self.gds_validate_string(value_, node, 'displayName')
            self.displayName = value_
            self.displayName_nsprefix_ = child_.prefix
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
        elif nodeName_ == 'abstractorRef':
            obj_ = ConfigurableLibraryRef.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractorRef = obj_
            obj_.original_tagname_ = 'abstractorRef'
        elif nodeName_ == 'viewName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'viewName')
            value_ = self.gds_validate_string(value_, node, 'viewName')
            self.viewName = value_
            self.viewName_nsprefix_ = child_.prefix
# end class abstractorInstanceType


class viewConfigurationType(GeneratedsSuper):
    """view -- The selected view for the instance.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('instanceName', 'xs:Name', 0, 0, {'name': 'instanceName', 'ref': 'instanceName', 'type': 'xs:Name'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
        MemberSpec_('view', 'viewType77', 0, 0, {'name': 'view', 'type': 'viewType77'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, instanceName=None, isPresent=None, view=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.instanceName = instanceName
        self.instanceName_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = None
        self.view = view
        self.view_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewConfigurationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewConfigurationType.subclass:
            return viewConfigurationType.subclass(*args_, **kwargs_)
        else:
            return viewConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_instanceName(self):
        return self.instanceName
    def set_instanceName(self, instanceName):
        self.instanceName = instanceName
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_view(self):
        return self.view
    def set_view(self, view):
        self.view = view
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            self.instanceName is not None or
            self.isPresent is not None or
            self.view is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewConfigurationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewConfigurationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewConfigurationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewConfigurationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewConfigurationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewConfigurationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.instanceName is not None:
            namespaceprefix_ = self.instanceName_nsprefix_ + ':' if (UseCapturedNS_ and self.instanceName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstanceName>%s</%sinstanceName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.instanceName), input_name='instanceName')), namespaceprefix_ , eol_))
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
        if self.view is not None:
            namespaceprefix_ = self.view_nsprefix_ + ':' if (UseCapturedNS_ and self.view_nsprefix_) else ''
            self.view.export(outfile, level, namespaceprefix_, namespacedef_='', name_='view', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'instanceName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'instanceName')
            value_ = self.gds_validate_string(value_, node, 'instanceName')
            self.instanceName = value_
            self.instanceName_nsprefix_ = child_.prefix
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'view':
            obj_ = viewType77.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.view = obj_
            obj_.original_tagname_ = 'view'
# end class viewConfigurationType


class viewType77(GeneratedsSuper):
    """configurableElementValues -- Parameter values to set in the selected configuredView.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('viewRef', 'xs:NMTOKEN', 0, 0, {'use': 'required', 'name': 'viewRef'}),
        MemberSpec_('configurableElementValues', 'configurableElementValues', 0, 1, {'minOccurs': '0', 'name': 'configurableElementValues', 'ref': 'configurableElementValues', 'type': 'configurableElementValues'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, viewRef=None, configurableElementValues=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.viewRef = _cast(None, viewRef)
        self.viewRef_nsprefix_ = None
        self.configurableElementValues = configurableElementValues
        self.configurableElementValues_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewType77)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewType77.subclass:
            return viewType77.subclass(*args_, **kwargs_)
        else:
            return viewType77(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_configurableElementValues(self):
        return self.configurableElementValues
    def set_configurableElementValues(self, configurableElementValues):
        self.configurableElementValues = configurableElementValues
    def get_viewRef(self):
        return self.viewRef
    def set_viewRef(self, viewRef):
        self.viewRef = viewRef
    def _hasContent(self):
        if (
            self.configurableElementValues is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewType77', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewType77')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'viewType77':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='viewType77')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='viewType77', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='viewType77'):
        if self.viewRef is not None and 'viewRef' not in already_processed:
            already_processed.add('viewRef')
            outfile.write(' viewRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.viewRef), input_name='viewRef')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='viewType77', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.configurableElementValues is not None:
            namespaceprefix_ = self.configurableElementValues_nsprefix_ + ':' if (UseCapturedNS_ and self.configurableElementValues_nsprefix_) else ''
            self.configurableElementValues.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='configurableElementValues', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('viewRef', node)
        if value is not None and 'viewRef' not in already_processed:
            already_processed.add('viewRef')
            self.viewRef = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'configurableElementValues':
            obj_ = configurableElementValues.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.configurableElementValues = obj_
            obj_.original_tagname_ = 'configurableElementValues'
# end class viewType77


class abstractorModeType78(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'group'}),
        MemberSpec_('valueOf_', ['abstractorModeType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.group = _cast(None, group)
        self.group_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorModeType78)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorModeType78.subclass:
            return abstractorModeType78.subclass(*args_, **kwargs_)
        else:
            return abstractorModeType78(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_abstractorModeType(self, value):
        result = True
        # Validate type abstractorModeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['master', 'slave', 'direct', 'system']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on abstractorModeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorModeType78', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorModeType78')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractorModeType78':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractorModeType78')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractorModeType78', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='abstractorModeType78'):
        if self.group is not None and 'group' not in already_processed:
            already_processed.add('group')
            outfile.write(' group=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.group), input_name='group')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorModeType78', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('group', node)
        if value is not None and 'group' not in already_processed:
            already_processed.add('group')
            self.group = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class abstractorModeType78


class abstractorInterfacesType(GeneratedsSuper):
    """abstractorInterface -- An abstractor must have exactly 2 Interfaces.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('abstractorInterface', 'abstractorBusInterfaceType', 1, 0, {'maxOccurs': '2', 'minOccurs': '2', 'name': 'abstractorInterface', 'type': 'abstractorBusInterfaceType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, abstractorInterface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if abstractorInterface is None:
            self.abstractorInterface = []
        else:
            self.abstractorInterface = abstractorInterface
        self.abstractorInterface_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorInterfacesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorInterfacesType.subclass:
            return abstractorInterfacesType.subclass(*args_, **kwargs_)
        else:
            return abstractorInterfacesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_abstractorInterface(self):
        return self.abstractorInterface
    def set_abstractorInterface(self, abstractorInterface):
        self.abstractorInterface = abstractorInterface
    def add_abstractorInterface(self, value):
        self.abstractorInterface.append(value)
    def insert_abstractorInterface_at(self, index, value):
        self.abstractorInterface.insert(index, value)
    def replace_abstractorInterface_at(self, index, value):
        self.abstractorInterface[index] = value
    def _hasContent(self):
        if (
            self.abstractorInterface
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorInterfacesType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorInterfacesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'abstractorInterfacesType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='abstractorInterfacesType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='abstractorInterfacesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='abstractorInterfacesType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='abstractorInterfacesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for abstractorInterface_ in self.abstractorInterface:
            namespaceprefix_ = self.abstractorInterface_nsprefix_ + ':' if (UseCapturedNS_ and self.abstractorInterface_nsprefix_) else ''
            abstractorInterface_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='abstractorInterface', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'abstractorInterface':
            obj_ = abstractorBusInterfaceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.abstractorInterface.append(obj_)
            obj_.original_tagname_ = 'abstractorInterface'
# end class abstractorInterfacesType


class instanceGeneratorType(generatorType):
    """group -- An identifier to specify the generator group. This is used by generator chains for selecting which generators to run.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('scope', 'scopeType', 0, 1, {'use': 'optional', 'name': 'scope'}),
        MemberSpec_('group', 'xs:Name', 1, 1, {'maxOccurs': 'unbounded', 'minOccurs': '0', 'name': 'group', 'type': 'groupType17'}, None),
    ]
    subclass = None
    superclass = generatorType
    def __init__(self, hidden=False, id=None, name=None, displayName=None, description=None, phase=None, parameters=None, apiType=None, transportMethods=None, generatorExe=None, vendorExtensions=None, scope='instance', group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("instanceGeneratorType"), self).__init__(hidden, id, name, displayName, description, phase, parameters, apiType, transportMethods, generatorExe, vendorExtensions,  **kwargs_)
        self.scope = _cast(None, scope)
        self.scope_nsprefix_ = None
        if group is None:
            self.group = []
        else:
            self.group = group
        self.group_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instanceGeneratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instanceGeneratorType.subclass:
            return instanceGeneratorType.subclass(*args_, **kwargs_)
        else:
            return instanceGeneratorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def add_group(self, value):
        self.group.append(value)
    def insert_group_at(self, index, value):
        self.group.insert(index, value)
    def replace_group_at(self, index, value):
        self.group[index] = value
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def validate_scopeType(self, value):
        # Validate type scopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['instance', 'entity']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on scopeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.group or
            super(instanceGeneratorType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='instanceGeneratorType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instanceGeneratorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'instanceGeneratorType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instanceGeneratorType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='instanceGeneratorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='instanceGeneratorType'):
        super(instanceGeneratorType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='instanceGeneratorType')
        if self.scope != "instance" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='instanceGeneratorType', fromsubclass_=False, pretty_print=True):
        super(instanceGeneratorType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for group_ in self.group:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            group_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
            self.validate_scopeType(self.scope)    # validate type scopeType
        super(instanceGeneratorType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            obj_ = groupType17.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
        super(instanceGeneratorType, self)._buildChildren(child_, node, nodeName_, True)
# end class instanceGeneratorType


class generator(generatorType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
    ]
    subclass = None
    superclass = generatorType
    def __init__(self, hidden=False, id=None, name=None, displayName=None, description=None, phase=None, parameters=None, apiType=None, transportMethods=None, generatorExe=None, vendorExtensions=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("generator"), self).__init__(hidden, id, name, displayName, description, phase, parameters, apiType, transportMethods, generatorExe, vendorExtensions,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generator.subclass:
            return generator.subclass(*args_, **kwargs_)
        else:
            return generator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(generator, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'generator':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='generator')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='generator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='generator'):
        super(generator, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='generator')
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='generator', fromsubclass_=False, pretty_print=True):
        super(generator, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(generator, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(generator, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class generator


class dependency(ipxactURI):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'ipxactURI', 0),
    ]
    subclass = None
    superclass = ipxactURI
    def __init__(self, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("dependency"), self).__init__(valueOf_,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dependency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dependency.subclass:
            return dependency.subclass(*args_, **kwargs_)
        else:
            return dependency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dependency, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dependency', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dependency')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dependency':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dependency')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dependency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='dependency'):
        super(dependency, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dependency')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dependency', fromsubclass_=False, pretty_print=True):
        super(dependency, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dependency, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class dependency


class clockDriver(clockDriverType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('clockName', 'xs:string', 0, 1, {'use': 'optional', 'name': 'clockName'}),
    ]
    subclass = None
    superclass = clockDriverType
    def __init__(self, id=None, clockPeriod=None, clockPulseOffset=None, clockPulseValue=None, clockPulseDuration=None, clockName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("clockDriver"), self).__init__(id, clockPeriod, clockPulseOffset, clockPulseValue, clockPulseDuration,  **kwargs_)
        self.clockName = _cast(None, clockName)
        self.clockName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clockDriver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clockDriver.subclass:
            return clockDriver.subclass(*args_, **kwargs_)
        else:
            return clockDriver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_clockName(self):
        return self.clockName
    def set_clockName(self, clockName):
        self.clockName = clockName
    def _hasContent(self):
        if (
            super(clockDriver, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='clockDriver', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clockDriver')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'clockDriver':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clockDriver')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='clockDriver', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='clockDriver'):
        super(clockDriver, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clockDriver')
        if self.clockName is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            outfile.write(' clockName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clockName), input_name='clockName')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='clockDriver', fromsubclass_=False, pretty_print=True):
        super(clockDriver, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clockName', node)
        if value is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            self.clockName = value
        super(clockDriver, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(clockDriver, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class clockDriver


class moduleParameterType(parameterType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('dataType', 'xs:string', 0, 1, {'use': 'optional', 'name': 'dataType'}),
        MemberSpec_('usageType', 'usageTypeType', 0, 1, {'use': 'optional', 'name': 'usageType'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'name': 'isPresent', 'ref': 'isPresent', 'type': 'isPresent'}, None),
    ]
    subclass = None
    superclass = parameterType
    def __init__(self, parameterId=None, prompt=None, choiceRef=None, order=None, configGroups=None, minimum=None, maximum=None, type_='string', sign=None, prefix=None, unit=None, name=None, displayName=None, description=None, Vectors=None, arrays=None, value=None, vendorExtensions=None, resolve='immediate', dataType=None, usageType='nontyped', isPresent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("moduleParameterType"), self).__init__(parameterId, prompt, choiceRef, order, configGroups, minimum, maximum, type_, sign, prefix, unit, name, displayName, description, Vectors, arrays, value, vendorExtensions, resolve,  **kwargs_)
        self.dataType = _cast(None, dataType)
        self.dataType_nsprefix_ = None
        self.usageType = _cast(None, usageType)
        self.usageType_nsprefix_ = None
        self.isPresent = isPresent
        self.isPresent_nsprefix_ = "ipxact"
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, moduleParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if moduleParameterType.subclass:
            return moduleParameterType.subclass(*args_, **kwargs_)
        else:
            return moduleParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isPresent(self):
        return self.isPresent
    def set_isPresent(self, isPresent):
        self.isPresent = isPresent
    def get_dataType(self):
        return self.dataType
    def set_dataType(self, dataType):
        self.dataType = dataType
    def get_usageType(self):
        return self.usageType
    def set_usageType(self, usageType):
        self.usageType = usageType
    def validate_usageTypeType(self, value):
        # Validate type usageTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['nontyped', 'typed']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on usageTypeType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            self.isPresent is not None or
            super(moduleParameterType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='moduleParameterType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('moduleParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'moduleParameterType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='moduleParameterType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='moduleParameterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='moduleParameterType'):
        super(moduleParameterType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='moduleParameterType')
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
        if self.usageType != "nontyped" and 'usageType' not in already_processed:
            already_processed.add('usageType')
            outfile.write(' usageType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usageType), input_name='usageType')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='moduleParameterType', fromsubclass_=False, pretty_print=True):
        super(moduleParameterType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            namespaceprefix_ = self.isPresent_nsprefix_ + ':' if (UseCapturedNS_ and self.isPresent_nsprefix_) else ''
            self.isPresent.export(outfile, level, namespaceprefix_='ipxact:', namespacedef_='', name_='isPresent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
        value = find_attr_value_('usageType', node)
        if value is not None and 'usageType' not in already_processed:
            already_processed.add('usageType')
            self.usageType = value
            self.validate_usageTypeType(self.usageType)    # validate type usageTypeType
        super(moduleParameterType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        super(moduleParameterType, self)._buildChildren(child_, node, nodeName_, True)
# end class moduleParameterType


class hierInterface(interfaceType):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('path', 'ipxact:instancePath', 0, 1, {'use': 'optional', 'name': 'path'}),
    ]
    subclass = None
    superclass = interfaceType
    def __init__(self, componentRef=None, busRef=None, id=None, path=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("hierInterface"), self).__init__(componentRef, busRef, id,  **kwargs_)
        self.path = _cast(None, path)
        self.path_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hierInterface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hierInterface.subclass:
            return hierInterface.subclass(*args_, **kwargs_)
        else:
            return hierInterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_path(self):
        return self.path
    def set_path(self, path):
        self.path = path
    def validate_instancePath(self, value):
        # Validate type ipxact:instancePath, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if not self.gds_validate_simple_patterns(
                    self.validate_instancePath_patterns_, value):
                self.gds_collector_.add_message('Value "%s" does not match xsd pattern restrictions: %s' % (encode_str_2_3(value), self.validate_instancePath_patterns_, ))
    validate_instancePath_patterns_ = [['^(\\i[\\p{L}\\p{N}\\.\\-:_]*)$', '^(\\i[\\p{L}\\p{N}\\.\\-:_]*/\\i[\\p{L}\\p{N}\\.\\-:_]*)$', '^((\\i[\\p{L}\\p{N}\\.\\-:_]*/)+[\\i\\p{L}\\p{N}\\.\\-:_]*)$']]
    def _hasContent(self):
        if (
            super(hierInterface, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='hierInterface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hierInterface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'hierInterface':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hierInterface')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='hierInterface', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='hierInterface'):
        super(hierInterface, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='hierInterface')
        if self.path is not None and 'path' not in already_processed:
            already_processed.add('path')
            outfile.write(' path=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.path), input_name='path')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='hierInterface', fromsubclass_=False, pretty_print=True):
        super(hierInterface, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('path', node)
        if value is not None and 'path' not in already_processed:
            already_processed.add('path')
            self.path = value
            self.validate_instancePath(self.path)    # validate type instancePath
        super(hierInterface, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(hierInterface, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class hierInterface


class unsignedBitVectorExpression(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("unsignedBitVectorExpression"), self).__init__(valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedBitVectorExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedBitVectorExpression.subclass:
            return unsignedBitVectorExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedBitVectorExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedBitVectorExpression, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedBitVectorExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedBitVectorExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'unsignedBitVectorExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedBitVectorExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='unsignedBitVectorExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='unsignedBitVectorExpression'):
        super(unsignedBitVectorExpression, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedBitVectorExpression')
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedBitVectorExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedBitVectorExpression, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(unsignedBitVectorExpression, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class unsignedBitVectorExpression


class unsignedBitExpression(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("unsignedBitExpression"), self).__init__(valueOf_, extensiontype_,  **kwargs_)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedBitExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedBitExpression.subclass:
            return unsignedBitExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedBitExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedBitExpression, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedBitExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedBitExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'unsignedBitExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedBitExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='unsignedBitExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='unsignedBitExpression'):
        super(unsignedBitExpression, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedBitExpression')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedBitExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedBitExpression, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(unsignedBitExpression, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class unsignedBitExpression


class stringURIExpression(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("stringURIExpression"), self).__init__(valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stringURIExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stringURIExpression.subclass:
            return stringURIExpression.subclass(*args_, **kwargs_)
        else:
            return stringURIExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(stringURIExpression, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='stringURIExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stringURIExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'stringURIExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stringURIExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='stringURIExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='stringURIExpression'):
        super(stringURIExpression, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stringURIExpression')
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='stringURIExpression', fromsubclass_=False, pretty_print=True):
        super(stringURIExpression, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(stringURIExpression, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class stringURIExpression


class stringExpression(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("stringExpression"), self).__init__(valueOf_, extensiontype_,  **kwargs_)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stringExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stringExpression.subclass:
            return stringExpression.subclass(*args_, **kwargs_)
        else:
            return stringExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(stringExpression, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='stringExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stringExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'stringExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stringExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='stringExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='stringExpression'):
        super(stringExpression, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='stringExpression')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='stringExpression', fromsubclass_=False, pretty_print=True):
        super(stringExpression, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(stringExpression, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class stringExpression


class realExpression(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:double', 0, 1, {'use': 'optional', 'name': 'minimum'}),
        MemberSpec_('maximum', 'xs:double', 0, 1, {'use': 'optional', 'name': 'maximum'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("realExpression"), self).__init__(valueOf_, extensiontype_,  **kwargs_)
        self.minimum = _cast(float, minimum)
        self.minimum_nsprefix_ = None
        self.maximum = _cast(float, maximum)
        self.maximum_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, realExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if realExpression.subclass:
            return realExpression.subclass(*args_, **kwargs_)
        else:
            return realExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(realExpression, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='realExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('realExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'realExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='realExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='realExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='realExpression'):
        super(realExpression, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='realExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_double(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_double(self.maximum, input_name='maximum'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='realExpression', fromsubclass_=False, pretty_print=True):
        super(realExpression, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            value = self.gds_parse_double(value, node, 'minimum')
            self.minimum = value
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            value = self.gds_parse_double(value, node, 'maximum')
            self.maximum = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(realExpression, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class realExpression


class signedIntExpression(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'minimum'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'maximum'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("signedIntExpression"), self).__init__(valueOf_,  **kwargs_)
        self.minimum = _cast(int, minimum)
        self.minimum_nsprefix_ = None
        self.maximum = _cast(int, maximum)
        self.maximum_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signedIntExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signedIntExpression.subclass:
            return signedIntExpression.subclass(*args_, **kwargs_)
        else:
            return signedIntExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(signedIntExpression, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='signedIntExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('signedIntExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'signedIntExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='signedIntExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='signedIntExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='signedIntExpression'):
        super(signedIntExpression, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='signedIntExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='signedIntExpression', fromsubclass_=False, pretty_print=True):
        super(signedIntExpression, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            self.minimum = self.gds_parse_integer(value, node, 'minimum')
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            self.maximum = self.gds_parse_integer(value, node, 'maximum')
        super(signedIntExpression, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class signedIntExpression


class unsignedPositiveIntExpression(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'minimum'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'maximum'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("unsignedPositiveIntExpression"), self).__init__(valueOf_,  **kwargs_)
        self.minimum = _cast(int, minimum)
        self.minimum_nsprefix_ = None
        self.maximum = _cast(int, maximum)
        self.maximum_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedPositiveIntExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedPositiveIntExpression.subclass:
            return unsignedPositiveIntExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedPositiveIntExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedPositiveIntExpression, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedPositiveIntExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedPositiveIntExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'unsignedPositiveIntExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedPositiveIntExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='unsignedPositiveIntExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='unsignedPositiveIntExpression'):
        super(unsignedPositiveIntExpression, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedPositiveIntExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedPositiveIntExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedPositiveIntExpression, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            self.minimum = self.gds_parse_integer(value, node, 'minimum')
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            self.maximum = self.gds_parse_integer(value, node, 'maximum')
        super(unsignedPositiveIntExpression, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
    def parse_uint(self):
        import re
        expr = self.valueOf_
        base = 10

        horrible_regex_hack = re.compile(r"\('h([0-9A-Fa-f]+)\) / \$pow\(2,(\d+)\) % \$pow\(2,(\d+)\)")
        horrible_regex_match = horrible_regex_hack.match(expr)

        if len(expr) > 2 and expr[0:2] == '0x':
            # handle non-standard SystemVerilog (but commonly-used) syntax
            expr = expr[2:]
            base = 16
        #Super-dirty hack to handle a common pattern used by XSLT upgrade transforms
        elif horrible_regex_match:
            _g = horrible_regex_match.groups()
            expr = str(int(int(_g[0], 16) / 2**int(_g[1]) % 2**int(_g[2])))
            
        elif "'" in expr:
            sep = expr.find("'")
            # ignore any bit size specified before ' because size is handled by other IP-XACT properties
            if expr[sep+1] in ["h", "H"]:
                base = 16
            elif expr[sep+1] in ["d", "D"]:
                base = 10
            elif expr[sep+1] in ["o", "O"]:
                base = 8
            elif expr[sep+1] in ["b", "B"]:
                base = 2
            else:
                raise ValueError("Could not convert expression to an integer: {}".format(self.valueOf_))
            expr = expr[sep+2:]

        return int(expr.replace('_', ''), base)
# end class unsignedPositiveIntExpression


class unsignedIntExpression(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'minimum'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'maximum'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("unsignedIntExpression"), self).__init__(valueOf_,  **kwargs_)
        self.minimum = _cast(int, minimum)
        self.minimum_nsprefix_ = None
        self.maximum = _cast(int, maximum)
        self.maximum_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedIntExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedIntExpression.subclass:
            return unsignedIntExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedIntExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedIntExpression, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedIntExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedIntExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'unsignedIntExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedIntExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='unsignedIntExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='unsignedIntExpression'):
        super(unsignedIntExpression, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedIntExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedIntExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedIntExpression, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            self.minimum = self.gds_parse_integer(value, node, 'minimum')
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            self.maximum = self.gds_parse_integer(value, node, 'maximum')
        super(unsignedIntExpression, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
    def parse_uint(self):
        import re
        expr = self.valueOf_
        base = 10

        horrible_regex_hack = re.compile(r"\('h([0-9A-Fa-f]+)\) / \$pow\(2,(\d+)\) % \$pow\(2,(\d+)\)")
        horrible_regex_match = horrible_regex_hack.match(expr)

        if len(expr) > 2 and expr[0:2] == '0x':
            # handle non-standard SystemVerilog (but commonly-used) syntax
            expr = expr[2:]
            base = 16
        #Super-dirty hack to handle a common pattern used by XSLT upgrade transforms
        elif horrible_regex_match:
            _g = horrible_regex_match.groups()
            expr = str(int(int(_g[0], 16) / 2**int(_g[1]) % 2**int(_g[2])))
            
        elif "'" in expr:
            sep = expr.find("'")
            # ignore any bit size specified before ' because size is handled by other IP-XACT properties
            if expr[sep+1] in ["h", "H"]:
                base = 16
            elif expr[sep+1] in ["d", "D"]:
                base = 10
            elif expr[sep+1] in ["o", "O"]:
                base = 8
            elif expr[sep+1] in ["b", "B"]:
                base = 2
            else:
                raise ValueError("Could not convert expression to an integer: {}".format(self.valueOf_))
            expr = expr[sep+2:]

        return int(expr.replace('_', ''), base)
# end class unsignedIntExpression


class signedLongintExpression(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'minimum'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'maximum'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("signedLongintExpression"), self).__init__(valueOf_,  **kwargs_)
        self.minimum = _cast(int, minimum)
        self.minimum_nsprefix_ = None
        self.maximum = _cast(int, maximum)
        self.maximum_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signedLongintExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signedLongintExpression.subclass:
            return signedLongintExpression.subclass(*args_, **kwargs_)
        else:
            return signedLongintExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(signedLongintExpression, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='signedLongintExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('signedLongintExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'signedLongintExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='signedLongintExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='signedLongintExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='signedLongintExpression'):
        super(signedLongintExpression, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='signedLongintExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='signedLongintExpression', fromsubclass_=False, pretty_print=True):
        super(signedLongintExpression, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            self.minimum = self.gds_parse_integer(value, node, 'minimum')
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            self.maximum = self.gds_parse_integer(value, node, 'maximum')
        super(signedLongintExpression, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class signedLongintExpression


class unsignedPositiveLongintExpression(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'minimum'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'maximum'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("unsignedPositiveLongintExpression"), self).__init__(valueOf_,  **kwargs_)
        self.minimum = _cast(int, minimum)
        self.minimum_nsprefix_ = None
        self.maximum = _cast(int, maximum)
        self.maximum_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedPositiveLongintExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedPositiveLongintExpression.subclass:
            return unsignedPositiveLongintExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedPositiveLongintExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedPositiveLongintExpression, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedPositiveLongintExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedPositiveLongintExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'unsignedPositiveLongintExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedPositiveLongintExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='unsignedPositiveLongintExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='unsignedPositiveLongintExpression'):
        super(unsignedPositiveLongintExpression, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedPositiveLongintExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedPositiveLongintExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedPositiveLongintExpression, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            self.minimum = self.gds_parse_integer(value, node, 'minimum')
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            self.maximum = self.gds_parse_integer(value, node, 'maximum')
        super(unsignedPositiveLongintExpression, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class unsignedPositiveLongintExpression


class unsignedLongintExpression(complexBaseExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'minimum'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional', 'name': 'maximum'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("unsignedLongintExpression"), self).__init__(valueOf_, extensiontype_,  **kwargs_)
        self.minimum = _cast(int, minimum)
        self.minimum_nsprefix_ = None
        self.maximum = _cast(int, maximum)
        self.maximum_nsprefix_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedLongintExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedLongintExpression.subclass:
            return unsignedLongintExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedLongintExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_minimum(self):
        return self.minimum
    def set_minimum(self, minimum):
        self.minimum = minimum
    def get_maximum(self):
        return self.maximum
    def set_maximum(self, maximum):
        self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedLongintExpression, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedLongintExpression', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedLongintExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'unsignedLongintExpression':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedLongintExpression')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='unsignedLongintExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='unsignedLongintExpression'):
        super(unsignedLongintExpression, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='unsignedLongintExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='unsignedLongintExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedLongintExpression, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            self.minimum = self.gds_parse_integer(value, node, 'minimum')
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            self.maximum = self.gds_parse_integer(value, node, 'maximum')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(unsignedLongintExpression, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
    def parse_uint(self):
        import re
        expr = self.valueOf_
        base = 10

        horrible_regex_hack = re.compile(r"\('h([0-9A-Fa-f]+)\) / \$pow\(2,(\d+)\) % \$pow\(2,(\d+)\)")
        horrible_regex_match = horrible_regex_hack.match(expr)

        if len(expr) > 2 and expr[0:2] == '0x':
            # handle non-standard SystemVerilog (but commonly-used) syntax
            expr = expr[2:]
            base = 16
        #Super-dirty hack to handle a common pattern used by XSLT upgrade transforms
        elif horrible_regex_match:
            _g = horrible_regex_match.groups()
            expr = str(int(int(_g[0], 16) / 2**int(_g[1]) % 2**int(_g[2])))
            
        elif "'" in expr:
            sep = expr.find("'")
            # ignore any bit size specified before ' because size is handled by other IP-XACT properties
            if expr[sep+1] in ["h", "H"]:
                base = 16
            elif expr[sep+1] in ["d", "D"]:
                base = 10
            elif expr[sep+1] in ["o", "O"]:
                base = 8
            elif expr[sep+1] in ["b", "B"]:
                base = 2
            else:
                raise ValueError("Could not convert expression to an integer: {}".format(self.valueOf_))
            expr = expr[sep+2:]

        return int(expr.replace('_', ''), base)
# end class unsignedLongintExpression


class dimType69(unsignedLongintExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("dimType69"), self).__init__(minimum, maximum, valueOf_,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dimType69)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dimType69.subclass:
            return dimType69.subclass(*args_, **kwargs_)
        else:
            return dimType69(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dimType69, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dimType69', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dimType69')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dimType69':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dimType69')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dimType69', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dimType69'):
        super(dimType69, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dimType69')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dimType69', fromsubclass_=False, pretty_print=True):
        super(dimType69, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dimType69, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class dimType69


class dimType66(unsignedLongintExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("dimType66"), self).__init__(minimum, maximum, valueOf_,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dimType66)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dimType66.subclass:
            return dimType66.subclass(*args_, **kwargs_)
        else:
            return dimType66(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dimType66, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dimType66', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dimType66')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dimType66':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dimType66')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dimType66', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dimType66'):
        super(dimType66, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dimType66')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dimType66', fromsubclass_=False, pretty_print=True):
        super(dimType66, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dimType66, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class dimType66


class dimType59(unsignedLongintExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("dimType59"), self).__init__(minimum, maximum, valueOf_,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dimType59)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dimType59.subclass:
            return dimType59.subclass(*args_, **kwargs_)
        else:
            return dimType59(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dimType59, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dimType59', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dimType59')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dimType59':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dimType59')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dimType59', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dimType59'):
        super(dimType59, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dimType59')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dimType59', fromsubclass_=False, pretty_print=True):
        super(dimType59, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dimType59, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class dimType59


class dimType53(unsignedLongintExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("dimType53"), self).__init__(minimum, maximum, valueOf_,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dimType53)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dimType53.subclass:
            return dimType53.subclass(*args_, **kwargs_)
        else:
            return dimType53(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dimType53, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dimType53', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dimType53')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dimType53':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dimType53')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dimType53', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dimType53'):
        super(dimType53, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dimType53')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dimType53', fromsubclass_=False, pretty_print=True):
        super(dimType53, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dimType53, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class dimType53


class dimType(unsignedLongintExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("dimType"), self).__init__(minimum, maximum, valueOf_,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dimType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dimType.subclass:
            return dimType.subclass(*args_, **kwargs_)
        else:
            return dimType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dimType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dimType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dimType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'dimType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dimType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dimType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dimType'):
        super(dimType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dimType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='dimType', fromsubclass_=False, pretty_print=True):
        super(dimType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dimType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class dimType


class remapAddressType27(unsignedLongintExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('state', 'xs:string', 0, 1, {'use': 'optional', 'name': 'state'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, state=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("remapAddressType27"), self).__init__(minimum, maximum, valueOf_,  **kwargs_)
        self.state = _cast(None, state)
        self.state_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapAddressType27)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapAddressType27.subclass:
            return remapAddressType27.subclass(*args_, **kwargs_)
        else:
            return remapAddressType27(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(remapAddressType27, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapAddressType27', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapAddressType27')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'remapAddressType27':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='remapAddressType27')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='remapAddressType27', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='remapAddressType27'):
        super(remapAddressType27, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='remapAddressType27')
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapAddressType27', fromsubclass_=False, pretty_print=True):
        super(remapAddressType27, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(remapAddressType27, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class remapAddressType27


class remapAddressType(unsignedLongintExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('state', 'xs:string', 0, 1, {'use': 'optional', 'name': 'state'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, state=None, id=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("remapAddressType"), self).__init__(minimum, maximum, valueOf_,  **kwargs_)
        self.state = _cast(None, state)
        self.state_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapAddressType.subclass:
            return remapAddressType.subclass(*args_, **kwargs_)
        else:
            return remapAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_state(self):
        return self.state
    def set_state(self, state):
        self.state = state
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(remapAddressType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapAddressType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'remapAddressType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='remapAddressType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='remapAddressType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='remapAddressType'):
        super(remapAddressType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='remapAddressType')
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='remapAddressType', fromsubclass_=False, pretty_print=True):
        super(remapAddressType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(remapAddressType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class remapAddressType


class flagsType(stringExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('append', 'xs:boolean', 0, 1, {'use': 'optional', 'name': 'append'}),
        MemberSpec_('valueOf_', 'stringExpression', 0),
    ]
    subclass = None
    superclass = stringExpression
    def __init__(self, append=None, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("flagsType"), self).__init__(valueOf_,  **kwargs_)
        self.append = _cast(bool, append)
        self.append_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, flagsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if flagsType.subclass:
            return flagsType.subclass(*args_, **kwargs_)
        else:
            return flagsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_append(self):
        return self.append
    def set_append(self, append):
        self.append = append
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(flagsType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='flagsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('flagsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'flagsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='flagsType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='flagsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='flagsType'):
        super(flagsType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='flagsType')
        if self.append is not None and 'append' not in already_processed:
            already_processed.add('append')
            outfile.write(' append="%s"' % self.gds_format_boolean(self.append, input_name='append'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='flagsType', fromsubclass_=False, pretty_print=True):
        super(flagsType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('append', node)
        if value is not None and 'append' not in already_processed:
            already_processed.add('append')
            if value in ('true', '1'):
                self.append = True
            elif value in ('false', '0'):
                self.append = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(flagsType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class flagsType


class clockPulseDurationType(realExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('units', 'ipxact:delayValueUnitType', 0, 1, {'use': 'optional', 'name': 'units'}),
        MemberSpec_('valueOf_', 'realExpression', 0),
    ]
    subclass = None
    superclass = realExpression
    def __init__(self, minimum=None, maximum=None, units='ns', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("clockPulseDurationType"), self).__init__(minimum, maximum, valueOf_,  **kwargs_)
        self.units = _cast(None, units)
        self.units_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clockPulseDurationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clockPulseDurationType.subclass:
            return clockPulseDurationType.subclass(*args_, **kwargs_)
        else:
            return clockPulseDurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_units(self):
        return self.units
    def set_units(self, units):
        self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_delayValueUnitType(self, value):
        # Validate type ipxact:delayValueUnitType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ps', 'ns']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on delayValueUnitType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(clockPulseDurationType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='clockPulseDurationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clockPulseDurationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'clockPulseDurationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clockPulseDurationType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='clockPulseDurationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='clockPulseDurationType'):
        super(clockPulseDurationType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clockPulseDurationType')
        if self.units != "ns" and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.units), input_name='units')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='clockPulseDurationType', fromsubclass_=False, pretty_print=True):
        super(clockPulseDurationType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
            self.units = ' '.join(self.units.split())
            self.validate_delayValueUnitType(self.units)    # validate type delayValueUnitType
        super(clockPulseDurationType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class clockPulseDurationType


class clockPulseOffsetType(realExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('units', 'ipxact:delayValueUnitType', 0, 1, {'use': 'optional', 'name': 'units'}),
        MemberSpec_('valueOf_', 'realExpression', 0),
    ]
    subclass = None
    superclass = realExpression
    def __init__(self, minimum=None, maximum=None, units='ns', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("clockPulseOffsetType"), self).__init__(minimum, maximum, valueOf_,  **kwargs_)
        self.units = _cast(None, units)
        self.units_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clockPulseOffsetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clockPulseOffsetType.subclass:
            return clockPulseOffsetType.subclass(*args_, **kwargs_)
        else:
            return clockPulseOffsetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_units(self):
        return self.units
    def set_units(self, units):
        self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_delayValueUnitType(self, value):
        # Validate type ipxact:delayValueUnitType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ps', 'ns']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on delayValueUnitType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(clockPulseOffsetType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='clockPulseOffsetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clockPulseOffsetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'clockPulseOffsetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clockPulseOffsetType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='clockPulseOffsetType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='clockPulseOffsetType'):
        super(clockPulseOffsetType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clockPulseOffsetType')
        if self.units != "ns" and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.units), input_name='units')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='clockPulseOffsetType', fromsubclass_=False, pretty_print=True):
        super(clockPulseOffsetType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
            self.units = ' '.join(self.units.split())
            self.validate_delayValueUnitType(self.units)    # validate type delayValueUnitType
        super(clockPulseOffsetType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class clockPulseOffsetType


class clockPeriodType(realExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('units', 'ipxact:delayValueUnitType', 0, 1, {'use': 'optional', 'name': 'units'}),
        MemberSpec_('valueOf_', 'realExpression', 0),
    ]
    subclass = None
    superclass = realExpression
    def __init__(self, minimum=None, maximum=None, units='ns', valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("clockPeriodType"), self).__init__(minimum, maximum, valueOf_,  **kwargs_)
        self.units = _cast(None, units)
        self.units_nsprefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clockPeriodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clockPeriodType.subclass:
            return clockPeriodType.subclass(*args_, **kwargs_)
        else:
            return clockPeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_units(self):
        return self.units
    def set_units(self, units):
        self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_delayValueUnitType(self, value):
        # Validate type ipxact:delayValueUnitType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['ps', 'ns']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on delayValueUnitType' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(clockPeriodType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='clockPeriodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clockPeriodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'clockPeriodType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clockPeriodType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='clockPeriodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='clockPeriodType'):
        super(clockPeriodType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='clockPeriodType')
        if self.units != "ns" and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.units), input_name='units')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='clockPeriodType', fromsubclass_=False, pretty_print=True):
        super(clockPeriodType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
            self.units = ' '.join(self.units.split())
            self.validate_delayValueUnitType(self.units)    # validate type delayValueUnitType
        super(clockPeriodType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class clockPeriodType


class isResetType(unsignedBitExpression):
    __hash__ = GeneratedsSuper.__hash__
    member_data_items_ = [
        MemberSpec_('resetTypeRef', 'xs:Name', 0, 1, {'use': 'optional', 'name': 'resetTypeRef'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional', 'name': 'id'}),
    ]
    subclass = None
    superclass = unsignedBitExpression
    def __init__(self, resetTypeRef=None, id=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = "ipxact"
        super(globals().get("isResetType"), self).__init__( **kwargs_)
        self.resetTypeRef = _cast(None, resetTypeRef)
        self.resetTypeRef_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, isResetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if isResetType.subclass:
            return isResetType.subclass(*args_, **kwargs_)
        else:
            return isResetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_resetTypeRef(self):
        return self.resetTypeRef
    def set_resetTypeRef(self, resetTypeRef):
        self.resetTypeRef = resetTypeRef
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def _hasContent(self):
        if (
            super(isResetType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='isResetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('isResetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'isResetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='isResetType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='isResetType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ipxact:', name_='isResetType'):
        super(isResetType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='isResetType')
        if self.resetTypeRef is not None and 'resetTypeRef' not in already_processed:
            already_processed.add('resetTypeRef')
            outfile.write(' resetTypeRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.resetTypeRef), input_name='resetTypeRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' xml:id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='ipxact:', namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"', name_='isResetType', fromsubclass_=False, pretty_print=True):
        super(isResetType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resetTypeRef', node)
        if value is not None and 'resetTypeRef' not in already_processed:
            already_processed.add('resetTypeRef')
            self.resetTypeRef = value
        value = find_attr_value_('xml:id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(isResetType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(isResetType, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class isResetType


GDSClassesMapping = {
    'BusInterface': BusInterface,
    'abstractor': abstractorType,
    'abstractorGenerator': instanceGeneratorType,
    'access': accessType,
    'activeCondition': unsignedBitExpression,
    'addressBlock': addressBlockType,
    'addressSpaceRef': addrSpaceRefType,
    'addressUnitBits': unsignedPositiveLongintExpression,
    'arrays': configurableArrays,
    'bank': addressBankType,
    'baseAddress': unsignedLongintExpression,
    'bitsInLau': unsignedPositiveLongintExpression,
    'busWidth': unsignedIntExpression,
    'component': Component,
    'componentGenerator': instanceGeneratorType,
    'defaultValue': unsignedBitVectorExpression,
    'driver': driverType,
    'fileSet': fileSetType,
    'indirectInterface': indirectInterfaceType,
    'initiative': initiativeType,
    'isPresent': unsignedBitExpression,
    'left': unsignedIntExpression,
    'memoryMapRef': memoryMapRefType,
    'model': Model,
    'parameter': parameterType,
    'phase': realExpression,
    'port': Port,
    'portAccessType': simplePortAccessType,
    'presence': presenceType,
    'right': unsignedIntExpression,
    'typeParameter': moduleParameterType,
    'value': stringExpression,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    prefix_tag = TagNamePrefix + tag
    rootClass = GDSClassesMapping.get(prefix_tag)
    if rootClass is None:
        rootClass = globals().get(prefix_tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'busDefinition'
        rootClass = busDefinition
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, reverse_mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'busDefinition'
        rootClass = busDefinition
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if mapping is None:
        mapping = {}
    if reverse_mapping is None:
        reverse_mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping,
        reverse_mapping_=reverse_mapping, nsmap_=nsmap)
    reverse_node_mapping = rootObj.gds_reverse_node_mapping(mapping)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_node_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'busDefinition'
        rootClass = busDefinition
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'busDefinition'
        rootClass = busDefinition
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from ipxact import *\n\n')
        sys.stdout.write('import ipxact as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'http://www.accellera.org/XMLSchema/IPXACT/1685-2014': [('portName',
                                                          '2014/simpleTypes.xsd',
                                                          'ST'),
                                                         ('instancePath',
                                                          '2014/simpleTypes.xsd',
                                                          'ST'),
                                                         ('simpleUnsignedBitExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'ST'),
                                                         ('simpleUnsignedLongintExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'ST'),
                                                         ('simpleBaseExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'ST'),
                                                         ('unsignedLongintExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('unsignedPositiveLongintExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('signedLongintExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('unsignedIntExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('unsignedPositiveIntExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('signedIntExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('realExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('stringExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('stringURIExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('unsignedBitExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('unsignedBitVectorExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('complexBaseExpression',
                                                          '2014/simpleTypes.xsd',
                                                          'CT'),
                                                         ('formatType',
                                                          '2014/autoConfigure.xsd',
                                                          'ST'),
                                                         ('signType',
                                                          '2014/autoConfigure.xsd',
                                                          'ST'),
                                                         ('delayValueUnitType',
                                                          '2014/autoConfigure.xsd',
                                                          'ST'),
                                                         ('moduleParameterType',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('leafAccessHandle',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('nonIndexedLeafAccessHandle',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('indexedAccessHandle',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('simpleAccessHandle',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('slicesType',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('sliceType',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('pathSegmentType',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('parameterBaseType',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('parameterType',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('nameValuePairType',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('configurableArrays',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('indicesType',
                                                          '2014/commonStructures.xsd',
                                                          'CT'),
                                                         ('libraryRefType',
                                                          '2014/identifier.xsd',
                                                          'CT'),
                                                         ('configurableLibraryRefType',
                                                          '2014/identifier.xsd',
                                                          'CT'),
                                                         ('simpleTiedValueType',
                                                          '2014/subInstances.xsd',
                                                          'ST'),
                                                         ('complexTiedValueType',
                                                          '2014/subInstances.xsd',
                                                          'CT'),
                                                         ('hierInterface',
                                                          '2014/subInstances.xsd',
                                                          'CT'),
                                                         ('interfaceType',
                                                          '2014/subInstances.xsd',
                                                          'CT'),
                                                         ('hierInterfaceType',
                                                          '2014/subInstances.xsd',
                                                          'CT'),
                                                         ('monitorInterfaceType',
                                                          '2014/subInstances.xsd',
                                                          'CT'),
                                                         ('driverType',
                                                          '2014/signalDrivers.xsd',
                                                          'CT'),
                                                         ('isResetType',
                                                          '2014/signalDrivers.xsd',
                                                          'CT'),
                                                         ('clockDriverType',
                                                          '2014/signalDrivers.xsd',
                                                          'CT'),
                                                         ('cellFunctionValueType',
                                                          '2014/constraints.xsd',
                                                          'ST'),
                                                         ('cellClassValueType',
                                                          '2014/constraints.xsd',
                                                          'ST'),
                                                         ('cellStrengthValueType',
                                                          '2014/constraints.xsd',
                                                          'ST'),
                                                         ('edgeValueType',
                                                          '2014/constraints.xsd',
                                                          'ST'),
                                                         ('delayValueType',
                                                          '2014/constraints.xsd',
                                                          'ST'),
                                                         ('delayPercentageType',
                                                          '2014/constraints.xsd',
                                                          'ST'),
                                                         ('nonNegativeFloat',
                                                          '2014/constraints.xsd',
                                                          'ST'),
                                                         ('otherClocks',
                                                          '2014/constraints.xsd',
                                                          'CT'),
                                                         ('abstractionDefPortConstraintsType',
                                                          '2014/constraints.xsd',
                                                          'CT'),
                                                         ('simpleFileType',
                                                          '2014/fileType.xsd',
                                                          'ST'),
                                                         ('returnTypeType',
                                                          '2014/file.xsd',
                                                          'ST'),
                                                         ('dataTypeType',
                                                          '2014/file.xsd',
                                                          'ST'),
                                                         ('fileBuilderType',
                                                          '2014/file.xsd',
                                                          'CT'),
                                                         ('fileSetType',
                                                          '2014/file.xsd',
                                                          'CT'),
                                                         ('ipxactURI',
                                                          '2014/file.xsd',
                                                          'CT'),
                                                         ('componentPortDirectionType',
                                                          '2014/port.xsd',
                                                          'ST'),
                                                         ('initiativeType',
                                                          '2014/port.xsd',
                                                          'ST'),
                                                         ('protocolTypeType',
                                                          '2014/port.xsd',
                                                          'ST'),
                                                         ('kindType',
                                                          '2014/port.xsd',
                                                          'ST'),
                                                         ('simplePortAccessType',
                                                          '2014/port.xsd',
                                                          'ST'),
                                                         ('portType',
                                                          '2014/port.xsd',
                                                          'CT'),
                                                         ('abstractorPortType',
                                                          '2014/port.xsd',
                                                          'CT'),
                                                         ('portWireType',
                                                          '2014/port.xsd',
                                                          'CT'),
                                                         ('portTransactionalType',
                                                          '2014/port.xsd',
                                                          'CT'),
                                                         ('abstractorPortWireType',
                                                          '2014/port.xsd',
                                                          'CT'),
                                                         ('portAccessType',
                                                          '2014/port.xsd',
                                                          'CT'),
                                                         ('apiType',
                                                          '2014/generator.xsd',
                                                          'ST'),
                                                         ('transportMethodType',
                                                          '2014/generator.xsd',
                                                          'ST'),
                                                         ('instanceGeneratorType',
                                                          '2014/generator.xsd',
                                                          'CT'),
                                                         ('generatorSelectorType',
                                                          '2014/generator.xsd',
                                                          'CT'),
                                                         ('generatorType',
                                                          '2014/generator.xsd',
                                                          'CT'),
                                                         ('presenceType',
                                                          '2014/abstractionDefinition.xsd',
                                                          'ST'),
                                                         ('direction',
                                                          '2014/abstractionDefinition.xsd',
                                                          'ST'),
                                                         ('accessType',
                                                          '2014/memoryMap.xsd',
                                                          'ST'),
                                                         ('sharedType',
                                                          '2014/memoryMap.xsd',
                                                          'ST'),
                                                         ('bankAlignmentType',
                                                          '2014/memoryMap.xsd',
                                                          'ST'),
                                                         ('usageType',
                                                          '2014/memoryMap.xsd',
                                                          'ST'),
                                                         ('modifiedWriteValueType',
                                                          '2014/memoryMap.xsd',
                                                          'ST'),
                                                         ('readActionType',
                                                          '2014/memoryMap.xsd',
                                                          'ST'),
                                                         ('addressBankType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('localAddressBankType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('addressBlockType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('addrSpaceRefType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('memoryMapRefType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('bankedBankType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('localBankedBankType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('bankedBlockType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('bankedSubspaceType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('fieldType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('memoryMapType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('memoryRemapType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('localMemoryMapType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('subspaceRefType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('valueMaskConfigType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('writeValueConstraintType',
                                                          '2014/memoryMap.xsd',
                                                          'CT'),
                                                         ('simpleBitSteeringExpression',
                                                          '2014/busInterface.xsd',
                                                          'ST'),
                                                         ('endianessType',
                                                          '2014/busInterface.xsd',
                                                          'ST'),
                                                         ('complexBitSteeringExpression',
                                                          '2014/busInterface.xsd',
                                                          'CT'),
                                                         ('busInterfaceType',
                                                          '2014/busInterface.xsd',
                                                          'CT'),
                                                         ('abstractorBusInterfaceType',
                                                          '2014/busInterface.xsd',
                                                          'CT'),
                                                         ('indirectInterfaceType',
                                                          '2014/busInterface.xsd',
                                                          'CT'),
                                                         ('envIdentifierType',
                                                          '2014/model.xsd',
                                                          'ST'),
                                                         ('modelInstantiationType',
                                                          '2014/model.xsd',
                                                          'ST'),
                                                         ('designInstantiationType',
                                                          '2014/model.xsd',
                                                          'CT'),
                                                         ('designConfigurationInstantiationType',
                                                          '2014/model.xsd',
                                                          'CT'),
                                                         ('componentInstantiationType',
                                                          '2014/model.xsd',
                                                          'CT'),
                                                         ('modelType',
                                                          '2014/model.xsd',
                                                          'CT'),
                                                         ('abstractorModelType',
                                                          '2014/model.xsd',
                                                          'CT'),
                                                         ('whiteboxElementRefType',
                                                          '2014/model.xsd',
                                                          'CT'),
                                                         ('languageType',
                                                          '2014/model.xsd',
                                                          'CT'),
                                                         ('simpleWhiteboxType',
                                                          '2014/component.xsd',
                                                          'ST'),
                                                         ('componentType',
                                                          '2014/component.xsd',
                                                          'CT'),
                                                         ('whiteboxElementType',
                                                          '2014/component.xsd',
                                                          'CT'),
                                                         ('ipxactFileTypesEnum',
                                                          '2014/catalog.xsd',
                                                          'ST'),
                                                         ('ipxactFilesType',
                                                          '2014/catalog.xsd',
                                                          'CT'),
                                                         ('ipxactFileType',
                                                          '2014/catalog.xsd',
                                                          'CT'),
                                                         ('abstractorModeType',
                                                          '2014/abstractor.xsd',
                                                          'ST'),
                                                         ('abstractorType',
                                                          '2014/abstractor.xsd',
                                                          'CT')],
 'http://www.w3.org/XML/1998/namespace': []}

__all__ = [
    "AbstractionType",
    "AbstractionTypes",
    "BusInterface",
    "BusInterfaces",
    "Component",
    "ConfigurableLibraryRef",
    "LibraryRef",
    "LogicalPort",
    "Master",
    "Model",
    "PartSelect",
    "PhysicalPort",
    "Port",
    "PortMap",
    "PortMaps",
    "PortWire",
    "Ports",
    "Range",
    "Slave",
    "Vector",
    "Vectors",
    "abstractionDefPortConstraintsType",
    "abstractionDefinition",
    "abstractorBusInterfaceType",
    "abstractorGenerators",
    "abstractorInstanceType",
    "abstractorInstancesType",
    "abstractorInterfacesType",
    "abstractorModeType78",
    "abstractorModelType",
    "abstractorPortType",
    "abstractorPortWireType",
    "abstractorType",
    "accessHandlesType",
    "accessHandlesType43",
    "accessHandlesType44",
    "accessHandlesType45",
    "accessHandlesType46",
    "accessHandlesType47",
    "accessHandlesType48",
    "accessHandlesType49",
    "accessHandlesType50",
    "accessHandlesType52",
    "accessHandlesType54",
    "accessHandlesType58",
    "accessHandlesType65",
    "accessHandlesType68",
    "accessType",
    "activeInterface",
    "adHocConnection",
    "adHocConnections",
    "addrSpaceRefType",
    "addressBankType",
    "addressBlockType",
    "addressSpaceRefType",
    "addressSpaceRefType21",
    "addressSpaceType",
    "addressSpaces",
    "alternateGroupType",
    "alternateGroupsType",
    "alternateRegisterType",
    "alternateRegisters",
    "apiTypeType",
    "argumentType",
    "arrayType",
    "assertion",
    "assertions",
    "bankedBankType",
    "bankedBlockType",
    "bankedSubspaceType",
    "baseAddressesType",
    "baseAddressesType26",
    "buildCommandType",
    "busDefinition",
    "busInterfaceRefType",
    "catalog",
    "cellFunctionType",
    "cellSpecification",
    "chainGroupType",
    "channelType",
    "channels",
    "choiceType",
    "choices",
    "clockDriver",
    "clockDriverType",
    "clockPeriodType",
    "clockPulseDurationType",
    "clockPulseOffsetType",
    "complexBaseExpression",
    "complexBitSteeringExpression",
    "complexTiedValueType",
    "componentGenerators",
    "componentInstance",
    "componentInstances",
    "componentInstantiationType",
    "configurableArrays",
    "configurableElementValue",
    "configurableElementValues",
    "connectionType",
    "constraintSet",
    "constraintSetRef",
    "constraintSets",
    "cpuType",
    "cpusType",
    "dependency",
    "design",
    "designConfiguration",
    "designConfigurationInstantiationType",
    "designInstantiationType",
    "dimType",
    "dimType53",
    "dimType59",
    "dimType66",
    "dimType69",
    "driveConstraint",
    "driverType",
    "drivers",
    "enumeratedValueType",
    "enumeratedValues",
    "enumerationType",
    "envIdentifierType70",
    "envIdentifierType74",
    "excludePortType",
    "excludePortsType",
    "executableImage",
    "exportedNameType",
    "extensionType",
    "externalPortReference",
    "fieldType",
    "file",
    "fileBuilderType",
    "fileBuilderType16",
    "fileSetRef",
    "fileSetRefGroupType",
    "fileSetRefGroupType19",
    "fileSetRefGroupType23",
    "fileSetType",
    "fileSets",
    "fileType",
    "flagsType",
    "functionType",
    "generator",
    "generatorChain",
    "generatorChainSelectorType",
    "generatorRef",
    "generatorSelectorType",
    "generatorType",
    "groupSelector",
    "groupType",
    "groupType17",
    "hierInterface",
    "hierInterfaceType",
    "imageTypeType",
    "indexedAccessHandle",
    "indicesType",
    "indicesType2",
    "indicesType5",
    "indirectInterfaceType",
    "indirectInterfaces",
    "initiativeType",
    "instanceGeneratorType",
    "instantiationsType",
    "instantiationsType75",
    "interconnection",
    "interconnectionConfigurationType",
    "interconnections",
    "interfaceRefType",
    "interfaceType",
    "internalPortReferenceType",
    "ipxactFileType",
    "ipxactFilesType",
    "ipxactURI",
    "isIncludeFileType",
    "isResetType",
    "kind",
    "languageToolsType",
    "languageType",
    "leafAccessHandle",
    "libraryName",
    "linkerCommandFile",
    "loadConstraint",
    "localAddressBankType",
    "localBankedBankType",
    "localMemoryMapType",
    "logicalNameType",
    "masterType20",
    "memoryMapRefType",
    "memoryMapType",
    "memoryMaps",
    "memoryRemapType",
    "mirroredMasterType",
    "mirroredMasterType28",
    "mirroredSlaveType",
    "mirroredSlaveType25",
    "mirroredSystemType",
    "mirroredSystemType29",
    "mirroredSystemType33",
    "modifiedWriteValueType56",
    "modifiedWriteValueType60",
    "moduleParameterType",
    "moduleParametersType",
    "monitorInterconnection",
    "monitorInterfaceType",
    "monitorInterfaceType1",
    "monitorType",
    "monitorType30",
    "nameType",
    "nameValuePairType",
    "nonIndexedLeafAccessHandle",
    "onMasterType",
    "onMasterType39",
    "onSlaveType",
    "onSlaveType41",
    "onSystemType",
    "onSystemType37",
    "otherClockDriver",
    "otherClocks",
    "parameterBaseType",
    "parameterType",
    "parameters",
    "pathSegmentType",
    "pathSegmentsType",
    "pathSegmentsType7",
    "pathSegmentsType8",
    "payload",
    "portAccessType",
    "portReferencesType",
    "portTransactionalType",
    "portType35",
    "portsType71",
    "portsType76",
    "presenceType",
    "protocol",
    "protocolTypeType9",
    "qualifierType",
    "qualifierType36",
    "readActionType57",
    "readActionType61",
    "realExpression",
    "registerFile",
    "registerType",
    "registerType51",
    "registerType64",
    "registerType67",
    "remapAddressType",
    "remapAddressType27",
    "remapPortType",
    "remapPortsType",
    "remapStateType",
    "remapStates",
    "requiresDriver",
    "reset",
    "resetTypeType",
    "resetTypesType",
    "resetsType",
    "segmentType",
    "segmentsType",
    "serviceTypeDef",
    "serviceTypeDefs",
    "signedIntExpression",
    "signedLongintExpression",
    "simpleAccessHandle",
    "simplePortAccessType",
    "singleShotDriver",
    "slaveType22",
    "sliceType",
    "slicesType",
    "sourceFileType",
    "stringExpression",
    "stringURIExpression",
    "subspaceRefType",
    "systemGroupNameType",
    "systemGroupNamesType",
    "systemType",
    "systemType24",
    "systemType32",
    "testableType",
    "testableType62",
    "timingConstraint",
    "transTypeDef",
    "transTypeDefs",
    "transactionalType",
    "transparentBridge",
    "transportMethodType18",
    "transportMethodsType",
    "typeDefinitionType",
    "typeDefinitionType12",
    "typeDefinitionType14",
    "typeNameType",
    "typeNameType11",
    "typeNameType13",
    "typeParameters",
    "unsignedBitExpression",
    "unsignedBitVectorExpression",
    "unsignedIntExpression",
    "unsignedLongintExpression",
    "unsignedPositiveIntExpression",
    "unsignedPositiveLongintExpression",
    "valueMaskConfigType",
    "vectorType",
    "vendorExtensions",
    "viewConfigurationType",
    "viewRef",
    "viewRefType",
    "viewRefType10",
    "viewRefType15",
    "viewRefType3",
    "viewRefType4",
    "viewRefType6",
    "viewType",
    "viewType73",
    "viewType77",
    "viewsType",
    "viewsType72",
    "whiteboxElementRefType",
    "whiteboxElementRefsType",
    "whiteboxElementType",
    "whiteboxElementsType",
    "wireType",
    "wireTypeDef",
    "wireTypeDefs",
    "writeValueConstraintType"
]
