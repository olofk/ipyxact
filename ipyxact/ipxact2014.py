#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Mar 12 22:30:02 2018 by generateDS.py version 2.29.5.
# Python 3.5.4 (default, Jan 15 2018, 08:56:49)  [GCC 6.4.0]
#
# Command line options:
#   ('-f', '')
#   ('-o', 'out/ipxact.py')
#   ('--no-namespace-defs', '')
#   ('--user-methods', 'gends_user_methods')
#
# Command line arguments:
#   2014/index.xsd
#
# Command line:
#   /home/olof/.local/bin/generateDS -f -o "out/ipxact.py" --no-namespace-defs --user-methods="gends_user_methods" 2014/index.xsd
#
# Current working directory (os.getcwd()):
#   ipxact_gen
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class busDefinition(GeneratedsSuper):
    """Defines the structural information associated with a bus type,
    independent of the abstraction level."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'vendor'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'library'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'version'}, None),
        MemberSpec_('directConnection', 'xs:boolean', 0, 0, {'type': 'xs:boolean', 'name': 'directConnection'}, None),
        MemberSpec_('broadcast', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'name': 'broadcast'}, None),
        MemberSpec_('isAddressable', 'xs:boolean', 0, 0, {'type': 'xs:boolean', 'name': 'isAddressable'}, None),
        MemberSpec_('extends', 'libraryRefType', 0, 1, {'minOccurs': '0', 'type': 'libraryRefType', 'name': 'extends'}, None),
        MemberSpec_('maxMasters', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedIntExpression', 'name': 'maxMasters'}, None),
        MemberSpec_('maxSlaves', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedIntExpression', 'name': 'maxSlaves'}, None),
        MemberSpec_('systemGroupNames', 'systemGroupNamesType', 0, 1, {'minOccurs': '0', 'type': 'systemGroupNamesType', 'name': 'systemGroupNames'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'type': 'assertions', 'ref': 'assertions', 'name': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, directConnection=None, broadcast=None, isAddressable=None, extends=None, maxMasters=None, maxSlaves=None, systemGroupNames=None, description=None, parameters=None, assertions=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.vendor = vendor
        self.library = library
        self.name = name
        self.version = version
        self.directConnection = directConnection
        self.broadcast = broadcast
        self.isAddressable = isAddressable
        self.extends = extends
        self.maxMasters = maxMasters
        self.maxSlaves = maxSlaves
        self.systemGroupNames = systemGroupNames
        self.description = description
        self.parameters = parameters
        self.assertions = assertions
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, busDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if busDefinition.subclass:
            return busDefinition.subclass(*args_, **kwargs_)
        else:
            return busDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_directConnection(self): return self.directConnection
    def set_directConnection(self, directConnection): self.directConnection = directConnection
    def get_broadcast(self): return self.broadcast
    def set_broadcast(self, broadcast): self.broadcast = broadcast
    def get_isAddressable(self): return self.isAddressable
    def set_isAddressable(self, isAddressable): self.isAddressable = isAddressable
    def get_extends(self): return self.extends
    def set_extends(self, extends): self.extends = extends
    def get_maxMasters(self): return self.maxMasters
    def set_maxMasters(self, maxMasters): self.maxMasters = maxMasters
    def get_maxSlaves(self): return self.maxSlaves
    def set_maxSlaves(self, maxSlaves): self.maxSlaves = maxSlaves
    def get_systemGroupNames(self): return self.systemGroupNames
    def set_systemGroupNames(self, systemGroupNames): self.systemGroupNames = systemGroupNames
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_assertions(self): return self.assertions
    def set_assertions(self, assertions): self.assertions = assertions
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.directConnection is not None or
            self.broadcast is not None or
            self.isAddressable is not None or
            self.extends is not None or
            self.maxMasters is not None or
            self.maxSlaves is not None or
            self.systemGroupNames is not None or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='busDefinition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('busDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='busDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='busDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='busDefinition'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='busDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:vendor>%s</ipxact:vendor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), eol_))
        if self.library is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:library>%s</ipxact:library>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:version>%s</ipxact:version>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), eol_))
        if self.directConnection is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:directConnection>%s</ipxact:directConnection>%s' % (self.gds_format_boolean(self.directConnection, input_name='directConnection'), eol_))
        if self.broadcast is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:broadcast>%s</ipxact:broadcast>%s' % (self.gds_format_boolean(self.broadcast, input_name='broadcast'), eol_))
        if self.isAddressable is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:isAddressable>%s</ipxact:isAddressable>%s' % (self.gds_format_boolean(self.isAddressable, input_name='isAddressable'), eol_))
        if self.extends is not None:
            self.extends.export(outfile, level, namespace_, name_='extends', pretty_print=pretty_print)
        if self.maxMasters is not None:
            self.maxMasters.export(outfile, level, namespace_, name_='maxMasters', pretty_print=pretty_print)
        if self.maxSlaves is not None:
            self.maxSlaves.export(outfile, level, namespace_, name_='maxSlaves', pretty_print=pretty_print)
        if self.systemGroupNames is not None:
            self.systemGroupNames.export(outfile, level, namespace_, name_='systemGroupNames', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            self.assertions.export(outfile, level, namespace_='ipxact:', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'library':
            library_ = child_.text
            library_ = self.gds_validate_string(library_, node, 'library')
            self.library = library_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'directConnection':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'directConnection')
            self.directConnection = ival_
        elif nodeName_ == 'broadcast':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'broadcast')
            self.broadcast = ival_
        elif nodeName_ == 'isAddressable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAddressable')
            self.isAddressable = ival_
        elif nodeName_ == 'extends':
            obj_ = LibraryRef.factory()
            obj_.build(child_)
            self.extends = obj_
            obj_.original_tagname_ = 'extends'
        elif nodeName_ == 'maxMasters':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.maxMasters = obj_
            obj_.original_tagname_ = 'maxMasters'
        elif nodeName_ == 'maxSlaves':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.maxSlaves = obj_
            obj_.original_tagname_ = 'maxSlaves'
        elif nodeName_ == 'systemGroupNames':
            obj_ = systemGroupNamesType.factory()
            obj_.build(child_)
            self.systemGroupNames = obj_
            obj_.original_tagname_ = 'systemGroupNames'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory()
            obj_.build(child_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class busDefinition


class LibraryRef(GeneratedsSuper):
    """Base IP-XACT document reference type. Contains vendor, library, name
    and version attributes.Base IP-XACT document reference. Contains
    vendor, library, name and version attributes."""
    member_data_items_ = [
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('library', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'use': 'required'}),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, vendor=None, library=None, name=None, version=None):
        self.original_tagname_ = None
        self.vendor = _cast(None, vendor)
        self.library = _cast(None, library)
        self.name = _cast(None, name)
        self.version = _cast(None, version)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LibraryRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LibraryRef.subclass:
            return LibraryRef.subclass(*args_, **kwargs_)
        else:
            return LibraryRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='libraryRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('libraryRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='libraryRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='libraryRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='libraryRefType'):
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vendor), input_name='vendor')), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.add('library')
            outfile.write(' library=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.library), input_name='library')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='libraryRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.add('library')
            self.library = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LibraryRef


class ConfigurableLibraryRef(GeneratedsSuper):
    """Base IP-XACT document reference type for configurable top-level
    objects. Contains vendor, library, name and version attributes
    along with configurable element values.Base IP-XACT document
    reference. Contains vendor, library, name and version
    attributes."""
    member_data_items_ = [
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('library', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'use': 'required'}),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'use': 'required'}),
        MemberSpec_('configurableElementValues', 'configurableElementValues', 0, 1, {'minOccurs': '0', 'type': 'configurableElementValues', 'ref': 'configurableElementValues', 'name': 'configurableElementValues'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, vendor=None, library=None, name=None, version=None, configurableElementValues=None):
        self.original_tagname_ = None
        self.vendor = _cast(None, vendor)
        self.library = _cast(None, library)
        self.name = _cast(None, name)
        self.version = _cast(None, version)
        self.configurableElementValues = configurableElementValues
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConfigurableLibraryRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConfigurableLibraryRef.subclass:
            return ConfigurableLibraryRef.subclass(*args_, **kwargs_)
        else:
            return ConfigurableLibraryRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_configurableElementValues(self): return self.configurableElementValues
    def set_configurableElementValues(self, configurableElementValues): self.configurableElementValues = configurableElementValues
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            self.configurableElementValues is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='configurableLibraryRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('configurableLibraryRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='configurableLibraryRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='configurableLibraryRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='configurableLibraryRefType'):
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.vendor), input_name='vendor')), ))
        if self.library is not None and 'library' not in already_processed:
            already_processed.add('library')
            outfile.write(' library=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.library), input_name='library')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='configurableLibraryRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.configurableElementValues is not None:
            self.configurableElementValues.export(outfile, level, namespace_='ipxact:', name_='configurableElementValues', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
        value = find_attr_value_('library', node)
        if value is not None and 'library' not in already_processed:
            already_processed.add('library')
            self.library = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'configurableElementValues':
            obj_ = configurableElementValues.factory()
            obj_.build(child_)
            self.configurableElementValues = obj_
            obj_.original_tagname_ = 'configurableElementValues'
# end class ConfigurableLibraryRef


class complexBaseExpression(GeneratedsSuper):
    """Represents the base-type for an expressions."""
    member_data_items_ = [
        MemberSpec_('valueOf_', ['simpleBaseExpression', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complexBaseExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complexBaseExpression.subclass:
            return complexBaseExpression.subclass(*args_, **kwargs_)
        else:
            return complexBaseExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='complexBaseExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complexBaseExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='complexBaseExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='complexBaseExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='complexBaseExpression'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='complexBaseExpression', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class complexBaseExpression


class choices(GeneratedsSuper):
    """Choices used by elements with an attribute ipxact:choiceRef."""
    member_data_items_ = [
        MemberSpec_('choice', 'choiceType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'choice', 'type': 'choiceType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, choice=None):
        self.original_tagname_ = None
        if choice is None:
            self.choice = []
        else:
            self.choice = choice
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, choices)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if choices.subclass:
            return choices.subclass(*args_, **kwargs_)
        else:
            return choices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_choice(self): return self.choice
    def set_choice(self, choice): self.choice = choice
    def add_choice(self, value): self.choice.append(value)
    def insert_choice_at(self, index, value): self.choice.insert(index, value)
    def replace_choice_at(self, index, value): self.choice[index] = value
    def hasContent_(self):
        if (
            self.choice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='choices', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('choices')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='choices')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='choices', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='choices'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='choices', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for choice_ in self.choice:
            choice_.export(outfile, level, namespace_, name_='choice', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'choice':
            obj_ = choiceType.factory()
            obj_.build(child_)
            self.choice.append(obj_)
            obj_.original_tagname_ = 'choice'
# end class choices


class complexTiedValueType(GeneratedsSuper):
    """An unsigned longint expression that resolves to the value set {0, 1,
    ...} or open or default. It is derived from longintExpression
    and it supports an expression value.For elements which can be
    specified using expression which are supposed to be resolved to
    a long value, this indicates the minimum value allowed.For
    elements which can be specified using expression which are
    supposed to be resolved to a long value, this indicates the
    maximum value allowed."""
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['simpleTiedValueType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, minimum=None, maximum=None, valueOf_=None):
        self.original_tagname_ = None
        self.minimum = _cast(int, minimum)
        self.maximum = _cast(int, maximum)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complexTiedValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complexTiedValueType.subclass:
            return complexTiedValueType.subclass(*args_, **kwargs_)
        else:
            return complexTiedValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='complexTiedValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complexTiedValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='complexTiedValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='complexTiedValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='complexTiedValueType'):
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='complexTiedValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            try:
                self.minimum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            try:
                self.maximum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class complexTiedValueType


class configurableElementValues(GeneratedsSuper):
    """All configuration information for a contained component, generator,
    generator chain or abstractor instance."""
    member_data_items_ = [
        MemberSpec_('configurableElementValue', 'configurableElementValue', 1, 0, {'type': 'configurableElementValue', 'ref': 'configurableElementValue', 'name': 'configurableElementValue', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, configurableElementValue=None):
        self.original_tagname_ = None
        if configurableElementValue is None:
            self.configurableElementValue = []
        else:
            self.configurableElementValue = configurableElementValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, configurableElementValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if configurableElementValues.subclass:
            return configurableElementValues.subclass(*args_, **kwargs_)
        else:
            return configurableElementValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_configurableElementValue(self): return self.configurableElementValue
    def set_configurableElementValue(self, configurableElementValue): self.configurableElementValue = configurableElementValue
    def add_configurableElementValue(self, value): self.configurableElementValue.append(value)
    def insert_configurableElementValue_at(self, index, value): self.configurableElementValue.insert(index, value)
    def replace_configurableElementValue_at(self, index, value): self.configurableElementValue[index] = value
    def hasContent_(self):
        if (
            self.configurableElementValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='configurableElementValues', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('configurableElementValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='configurableElementValues')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='configurableElementValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='configurableElementValues'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='configurableElementValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for configurableElementValue_ in self.configurableElementValue:
            configurableElementValue_.export(outfile, level, namespace_='ipxact:', name_='configurableElementValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'configurableElementValue':
            obj_ = configurableElementValue.factory()
            obj_.build(child_)
            self.configurableElementValue.append(obj_)
            obj_.original_tagname_ = 'configurableElementValue'
# end class configurableElementValues


class configurableElementValue(complexBaseExpression):
    """Describes the content of a configurable element. The required
    referenceId attribute refers to the ID attribute of the
    configurable element.Refers to the ID attribute of the
    configurable element."""
    member_data_items_ = [
        MemberSpec_('referenceId', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, referenceId=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        super(configurableElementValue, self).__init__(valueOf_, )
        self.referenceId = _cast(None, referenceId)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, configurableElementValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if configurableElementValue.subclass:
            return configurableElementValue.subclass(*args_, **kwargs_)
        else:
            return configurableElementValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_referenceId(self): return self.referenceId
    def set_referenceId(self, referenceId): self.referenceId = referenceId
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(configurableElementValue, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='configurableElementValue', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('configurableElementValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='configurableElementValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='configurableElementValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='configurableElementValue'):
        super(configurableElementValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='configurableElementValue')
        if self.referenceId is not None and 'referenceId' not in already_processed:
            already_processed.add('referenceId')
            outfile.write(' referenceId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.referenceId), input_name='referenceId')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='configurableElementValue', fromsubclass_=False, pretty_print=True):
        super(configurableElementValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('referenceId', node)
        if value is not None and 'referenceId' not in already_processed:
            already_processed.add('referenceId')
            self.referenceId = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(configurableElementValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class configurableElementValue


class componentInstance(GeneratedsSuper):
    """Component instance element. The instance name is contained in the
    unique-value instanceName attribute."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('instanceName', 'xs:Name', 0, 0, {'type': 'xs:Name', 'ref': 'instanceName', 'name': 'instanceName'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'isPresent', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('componentRef', 'configurableLibraryRefType', 0, 0, {'type': 'configurableLibraryRefType', 'name': 'componentRef'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, instanceName=None, displayName=None, description=None, isPresent=None, componentRef=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.instanceName = instanceName
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        self.componentRef = componentRef
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentInstance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentInstance.subclass:
            return componentInstance.subclass(*args_, **kwargs_)
        else:
            return componentInstance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instanceName(self): return self.instanceName
    def set_instanceName(self, instanceName): self.instanceName = instanceName
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_componentRef(self): return self.componentRef
    def set_componentRef(self, componentRef): self.componentRef = componentRef
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.instanceName is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.componentRef is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='componentInstance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentInstance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='componentInstance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='componentInstance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='componentInstance'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='componentInstance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.instanceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:instanceName>%s</ipxact:instanceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.instanceName), input_name='instanceName')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.componentRef is not None:
            self.componentRef.export(outfile, level, namespace_, name_='componentRef', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instanceName':
            instanceName_ = child_.text
            instanceName_ = self.gds_validate_string(instanceName_, node, 'instanceName')
            self.instanceName = instanceName_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'componentRef':
            obj_ = ConfigurableLibraryRef.factory()
            obj_.build(child_)
            self.componentRef = obj_
            obj_.original_tagname_ = 'componentRef'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class componentInstance


class componentInstances(GeneratedsSuper):
    """Sub instances of internal components."""
    member_data_items_ = [
        MemberSpec_('componentInstance', 'componentInstance', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'componentInstance', 'name': 'componentInstance', 'type': 'componentInstance'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentInstance=None):
        self.original_tagname_ = None
        if componentInstance is None:
            self.componentInstance = []
        else:
            self.componentInstance = componentInstance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentInstances)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentInstances.subclass:
            return componentInstances.subclass(*args_, **kwargs_)
        else:
            return componentInstances(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentInstance(self): return self.componentInstance
    def set_componentInstance(self, componentInstance): self.componentInstance = componentInstance
    def add_componentInstance(self, value): self.componentInstance.append(value)
    def insert_componentInstance_at(self, index, value): self.componentInstance.insert(index, value)
    def replace_componentInstance_at(self, index, value): self.componentInstance[index] = value
    def hasContent_(self):
        if (
            self.componentInstance
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='componentInstances', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentInstances')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='componentInstances')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='componentInstances', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='componentInstances'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='componentInstances', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for componentInstance_ in self.componentInstance:
            componentInstance_.export(outfile, level, namespace_='ipxact:', name_='componentInstance', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'componentInstance':
            obj_ = componentInstance.factory()
            obj_.build(child_)
            self.componentInstance.append(obj_)
            obj_.original_tagname_ = 'componentInstance'
# end class componentInstances


class adHocConnection(GeneratedsSuper):
    """Represents an ad-hoc connection between component ports."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', ['portName', 'xs:string'], 0, 0, {'type': 'xs:string', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'isPresent', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('tiedValue', 'complexTiedValueType', 0, 1, {'minOccurs': '0', 'type': 'complexTiedValueType', 'name': 'tiedValue'}, None),
        MemberSpec_('portReferences', 'portReferencesType', 0, 0, {'type': 'portReferencesType', 'name': 'portReferences'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, tiedValue=None, portReferences=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.validate_portName(self.name)
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        self.tiedValue = tiedValue
        self.portReferences = portReferences
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adHocConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adHocConnection.subclass:
            return adHocConnection.subclass(*args_, **kwargs_)
        else:
            return adHocConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_tiedValue(self): return self.tiedValue
    def set_tiedValue(self, tiedValue): self.tiedValue = tiedValue
    def get_portReferences(self): return self.portReferences
    def set_portReferences(self, portReferences): self.portReferences = portReferences
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_portName(self, value):
        # Validate type portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_portName_patterns_, ))
    validate_portName_patterns_ = [['^[A-Za-z0-9\\.\\-:_]*$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.tiedValue is not None or
            self.portReferences is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='adHocConnection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adHocConnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='adHocConnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='adHocConnection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='adHocConnection'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='adHocConnection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.tiedValue is not None:
            self.tiedValue.export(outfile, level, namespace_, name_='tiedValue', pretty_print=pretty_print)
        if self.portReferences is not None:
            self.portReferences.export(outfile, level, namespace_, name_='portReferences', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type portName
            self.validate_portName(self.name)
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'tiedValue':
            obj_ = complexTiedValueType.factory()
            obj_.build(child_)
            self.tiedValue = obj_
            obj_.original_tagname_ = 'tiedValue'
        elif nodeName_ == 'portReferences':
            obj_ = portReferencesType.factory()
            obj_.build(child_)
            self.portReferences = obj_
            obj_.original_tagname_ = 'portReferences'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class adHocConnection


class adHocConnections(GeneratedsSuper):
    """Defines the set of ad-hoc connections in a design. An ad-hoc
    connection represents a connection between two component pins
    which were not connected as a result of interface connections
    (i.e.the pin to pin connection was made explicitly and is
    represented explicitly)."""
    member_data_items_ = [
        MemberSpec_('adHocConnection', 'adHocConnection', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'adHocConnection', 'name': 'adHocConnection', 'type': 'adHocConnection'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, adHocConnection=None):
        self.original_tagname_ = None
        if adHocConnection is None:
            self.adHocConnection = []
        else:
            self.adHocConnection = adHocConnection
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adHocConnections)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adHocConnections.subclass:
            return adHocConnections.subclass(*args_, **kwargs_)
        else:
            return adHocConnections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_adHocConnection(self): return self.adHocConnection
    def set_adHocConnection(self, adHocConnection): self.adHocConnection = adHocConnection
    def add_adHocConnection(self, value): self.adHocConnection.append(value)
    def insert_adHocConnection_at(self, index, value): self.adHocConnection.insert(index, value)
    def replace_adHocConnection_at(self, index, value): self.adHocConnection[index] = value
    def hasContent_(self):
        if (
            self.adHocConnection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='adHocConnections', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adHocConnections')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='adHocConnections')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='adHocConnections', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='adHocConnections'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='adHocConnections', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for adHocConnection_ in self.adHocConnection:
            adHocConnection_.export(outfile, level, namespace_='ipxact:', name_='adHocConnection', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'adHocConnection':
            obj_ = adHocConnection.factory()
            obj_.build(child_)
            self.adHocConnection.append(obj_)
            obj_.original_tagname_ = 'adHocConnection'
# end class adHocConnections


class interconnection(GeneratedsSuper):
    """Describes a connection between two active (not monitor)
    busInterfaces."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'isPresent', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('activeInterface', 'activeInterface', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'activeInterface', 'name': 'activeInterface', 'type': 'activeInterface'}, 3),
        MemberSpec_('hierInterface', 'hierInterface', 1, 0, {'type': 'hierInterfaceType', 'name': 'hierInterface', 'maxOccurs': 'unbounded'}, 3),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, activeInterface=None, hierInterface=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        if activeInterface is None:
            self.activeInterface = []
        else:
            self.activeInterface = activeInterface
        if hierInterface is None:
            self.hierInterface = []
        else:
            self.hierInterface = hierInterface
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interconnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interconnection.subclass:
            return interconnection.subclass(*args_, **kwargs_)
        else:
            return interconnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_activeInterface(self): return self.activeInterface
    def set_activeInterface(self, activeInterface): self.activeInterface = activeInterface
    def add_activeInterface(self, value): self.activeInterface.append(value)
    def insert_activeInterface_at(self, index, value): self.activeInterface.insert(index, value)
    def replace_activeInterface_at(self, index, value): self.activeInterface[index] = value
    def get_hierInterface(self): return self.hierInterface
    def set_hierInterface(self, hierInterface): self.hierInterface = hierInterface
    def add_hierInterface(self, value): self.hierInterface.append(value)
    def insert_hierInterface_at(self, index, value): self.hierInterface.insert(index, value)
    def replace_hierInterface_at(self, index, value): self.hierInterface[index] = value
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.activeInterface or
            self.hierInterface or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='interconnection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('interconnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interconnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='interconnection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='interconnection'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='interconnection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for activeInterface_ in self.activeInterface:
            activeInterface_.export(outfile, level, namespace_='ipxact:', name_='activeInterface', pretty_print=pretty_print)
        for hierInterface_ in self.hierInterface:
            hierInterface_.export(outfile, level, namespace_, name_='hierInterface', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'activeInterface':
            obj_ = activeInterface.factory()
            obj_.build(child_)
            self.activeInterface.append(obj_)
            obj_.original_tagname_ = 'activeInterface'
        elif nodeName_ == 'hierInterface':
            obj_ = hierInterfaceType.factory()
            obj_.build(child_)
            self.hierInterface.append(obj_)
            obj_.original_tagname_ = 'hierInterface'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class interconnection


class monitorInterconnection(GeneratedsSuper):
    """Describes a connection from the interface of one component to any
    number of monitor interfaces in the design. An active interface
    can be connected to unlimited number of monitor interfaces."""
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'isPresent', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('monitoredActiveInterface', 'monitorInterfaceType', 0, 0, {'type': 'monitorInterfaceType', 'name': 'monitoredActiveInterface'}, None),
        MemberSpec_('monitorInterface', 'monitorInterfaceType1', 1, 0, {'maxOccurs': 'unbounded', 'name': 'monitorInterface', 'type': 'monitorInterfaceType1'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, isPresent=None, monitoredActiveInterface=None, monitorInterface=None):
        self.original_tagname_ = None
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        self.monitoredActiveInterface = monitoredActiveInterface
        if monitorInterface is None:
            self.monitorInterface = []
        else:
            self.monitorInterface = monitorInterface
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monitorInterconnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monitorInterconnection.subclass:
            return monitorInterconnection.subclass(*args_, **kwargs_)
        else:
            return monitorInterconnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_monitoredActiveInterface(self): return self.monitoredActiveInterface
    def set_monitoredActiveInterface(self, monitoredActiveInterface): self.monitoredActiveInterface = monitoredActiveInterface
    def get_monitorInterface(self): return self.monitorInterface
    def set_monitorInterface(self, monitorInterface): self.monitorInterface = monitorInterface
    def add_monitorInterface(self, value): self.monitorInterface.append(value)
    def insert_monitorInterface_at(self, index, value): self.monitorInterface.insert(index, value)
    def replace_monitorInterface_at(self, index, value): self.monitorInterface[index] = value
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.monitoredActiveInterface is not None or
            self.monitorInterface
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='monitorInterconnection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monitorInterconnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='monitorInterconnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='monitorInterconnection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='monitorInterconnection'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='monitorInterconnection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.monitoredActiveInterface is not None:
            self.monitoredActiveInterface.export(outfile, level, namespace_, name_='monitoredActiveInterface', pretty_print=pretty_print)
        for monitorInterface_ in self.monitorInterface:
            monitorInterface_.export(outfile, level, namespace_, name_='monitorInterface', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'monitoredActiveInterface':
            class_obj_ = self.get_class_obj_(child_, monitorInterfaceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.monitoredActiveInterface = obj_
            obj_.original_tagname_ = 'monitoredActiveInterface'
        elif nodeName_ == 'monitorInterface':
            obj_ = monitorInterfaceType1.factory()
            obj_.build(child_)
            self.monitorInterface.append(obj_)
            obj_.original_tagname_ = 'monitorInterface'
# end class monitorInterconnection


class interconnections(GeneratedsSuper):
    """Connections between internal sub components."""
    member_data_items_ = [
        MemberSpec_('interconnection', 'interconnection', 1, 1, {'type': 'interconnection', 'ref': 'interconnection', 'name': 'interconnection'}, 4),
        MemberSpec_('monitorInterconnection', 'monitorInterconnection', 1, 1, {'type': 'monitorInterconnection', 'ref': 'monitorInterconnection', 'name': 'monitorInterconnection'}, 4),
    ]
    subclass = None
    superclass = None
    def __init__(self, interconnection=None, monitorInterconnection=None):
        self.original_tagname_ = None
        if interconnection is None:
            self.interconnection = []
        else:
            self.interconnection = interconnection
        if monitorInterconnection is None:
            self.monitorInterconnection = []
        else:
            self.monitorInterconnection = monitorInterconnection
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interconnections)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interconnections.subclass:
            return interconnections.subclass(*args_, **kwargs_)
        else:
            return interconnections(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interconnection(self): return self.interconnection
    def set_interconnection(self, interconnection): self.interconnection = interconnection
    def add_interconnection(self, value): self.interconnection.append(value)
    def insert_interconnection_at(self, index, value): self.interconnection.insert(index, value)
    def replace_interconnection_at(self, index, value): self.interconnection[index] = value
    def get_monitorInterconnection(self): return self.monitorInterconnection
    def set_monitorInterconnection(self, monitorInterconnection): self.monitorInterconnection = monitorInterconnection
    def add_monitorInterconnection(self, value): self.monitorInterconnection.append(value)
    def insert_monitorInterconnection_at(self, index, value): self.monitorInterconnection.insert(index, value)
    def replace_monitorInterconnection_at(self, index, value): self.monitorInterconnection[index] = value
    def hasContent_(self):
        if (
            self.interconnection or
            self.monitorInterconnection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='interconnections', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('interconnections')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interconnections')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='interconnections', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='interconnections'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='interconnections', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for interconnection_ in self.interconnection:
            interconnection_.export(outfile, level, namespace_='ipxact:', name_='interconnection', pretty_print=pretty_print)
        for monitorInterconnection_ in self.monitorInterconnection:
            monitorInterconnection_.export(outfile, level, namespace_='ipxact:', name_='monitorInterconnection', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'interconnection':
            obj_ = interconnection.factory()
            obj_.build(child_)
            self.interconnection.append(obj_)
            obj_.original_tagname_ = 'interconnection'
        elif nodeName_ == 'monitorInterconnection':
            obj_ = monitorInterconnection.factory()
            obj_.build(child_)
            self.monitorInterconnection.append(obj_)
            obj_.original_tagname_ = 'monitorInterconnection'
# end class interconnections


class interfaceType(GeneratedsSuper):
    """A representation of a component/bus interface relation; i.e. a bus
    interface belonging to a certain component.Reference to a
    component instance name.Reference to the components bus
    interface"""
    member_data_items_ = [
        MemberSpec_('componentRef', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('busRef', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentRef=None, busRef=None, id=None, extensiontype_=None):
        self.original_tagname_ = None
        self.componentRef = _cast(None, componentRef)
        self.busRef = _cast(None, busRef)
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interfaceType.subclass:
            return interfaceType.subclass(*args_, **kwargs_)
        else:
            return interfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentRef(self): return self.componentRef
    def set_componentRef(self, componentRef): self.componentRef = componentRef
    def get_busRef(self): return self.busRef
    def set_busRef(self, busRef): self.busRef = busRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='interfaceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('interfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='interfaceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='interfaceType'):
        if self.componentRef is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            outfile.write(' componentRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.componentRef), input_name='componentRef')), ))
        if self.busRef is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            outfile.write(' busRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.busRef), input_name='busRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='interfaceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('componentRef', node)
        if value is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            self.componentRef = value
        value = find_attr_value_('busRef', node)
        if value is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            self.busRef = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class interfaceType


class hierInterfaceType(GeneratedsSuper):
    """A representation of an exported interface. The busRef indicates the
    name of the interface in the containing component.Reference to
    the components bus interface"""
    member_data_items_ = [
        MemberSpec_('busRef', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'isPresent', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, busRef=None, id=None, isPresent=None, description=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.busRef = _cast(None, busRef)
        self.id = _cast(None, id)
        self.isPresent = isPresent
        self.description = description
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hierInterfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hierInterfaceType.subclass:
            return hierInterfaceType.subclass(*args_, **kwargs_)
        else:
            return hierInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_busRef(self): return self.busRef
    def set_busRef(self, busRef): self.busRef = busRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.isPresent is not None or
            self.description is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='hierInterfaceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hierInterfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hierInterfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='hierInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='hierInterfaceType'):
        if self.busRef is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            outfile.write(' busRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.busRef), input_name='busRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='hierInterfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('busRef', node)
        if value is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            self.busRef = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class hierInterfaceType


class monitorInterfaceType(interfaceType):
    """Hierarchical reference to an interface being monitored or monitoring
    another interface.A decending hierarchical (slash separated -
    example x/y/z) path to the component instance containing the
    specified component instance in componentRef. If not specified
    the componentRef instance shall exist in the current design."""
    member_data_items_ = [
        MemberSpec_('path', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = interfaceType
    def __init__(self, componentRef=None, busRef=None, id=None, path=None, description=None, vendorExtensions=None, extensiontype_=None):
        self.original_tagname_ = None
        super(monitorInterfaceType, self).__init__(componentRef, busRef, id, extensiontype_, )
        self.path = _cast(None, path)
        self.description = description
        self.vendorExtensions = vendorExtensions
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monitorInterfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monitorInterfaceType.subclass:
            return monitorInterfaceType.subclass(*args_, **kwargs_)
        else:
            return monitorInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.description is not None or
            self.vendorExtensions is not None or
            super(monitorInterfaceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='monitorInterfaceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monitorInterfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='monitorInterfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='monitorInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='monitorInterfaceType'):
        super(monitorInterfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='monitorInterfaceType')
        if self.path is not None and 'path' not in already_processed:
            already_processed.add('path')
            outfile.write(' path=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.path), input_name='path')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='monitorInterfaceType', fromsubclass_=False, pretty_print=True):
        super(monitorInterfaceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('path', node)
        if value is not None and 'path' not in already_processed:
            already_processed.add('path')
            self.path = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(monitorInterfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
        super(monitorInterfaceType, self).buildChildren(child_, node, nodeName_, True)
# end class monitorInterfaceType


class externalPortReference(GeneratedsSuper):
    """A port on the on the referenced component from componentRef."""
    member_data_items_ = [
        MemberSpec_('portRef', 'ipxact:portName', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'isPresent', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('PartSelect', 'partSelect', 0, 1, {'minOccurs': '0', 'type': 'partSelect', 'ref': 'partSelect', 'name': 'partSelect'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, portRef=None, id=None, isPresent=None, PartSelect=None):
        self.original_tagname_ = None
        self.portRef = _cast(None, portRef)
        self.id = _cast(None, id)
        self.isPresent = isPresent
        self.PartSelect = PartSelect
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, externalPortReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if externalPortReference.subclass:
            return externalPortReference.subclass(*args_, **kwargs_)
        else:
            return externalPortReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_partSelect(self): return self.PartSelect
    def set_partSelect(self, PartSelect): self.PartSelect = PartSelect
    def get_portRef(self): return self.portRef
    def set_portRef(self, portRef): self.portRef = portRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.isPresent is not None or
            self.PartSelect is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='externalPortReference', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('externalPortReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='externalPortReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='externalPortReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='externalPortReference'):
        if self.portRef is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            outfile.write(' portRef=%s' % (quote_attrib(self.portRef), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='externalPortReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.PartSelect is not None:
            self.PartSelect.export(outfile, level, namespace_='ipxact:', name_='partSelect', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('portRef', node)
        if value is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            self.portRef = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'partSelect':
            obj_ = PartSelect.factory()
            obj_.build(child_)
            self.PartSelect = obj_
            obj_.original_tagname_ = 'partSelect'
# end class externalPortReference


class activeInterface(interfaceType):
    member_data_items_ = [
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'isPresent', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('excludePorts', 'excludePortsType', 0, 1, {'minOccurs': '0', 'type': 'excludePortsType', 'name': 'excludePorts'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = interfaceType
    def __init__(self, componentRef=None, busRef=None, id=None, isPresent=None, description=None, excludePorts=None, vendorExtensions=None):
        self.original_tagname_ = None
        super(activeInterface, self).__init__(componentRef, busRef, id, )
        self.isPresent = isPresent
        self.description = description
        self.excludePorts = excludePorts
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, activeInterface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if activeInterface.subclass:
            return activeInterface.subclass(*args_, **kwargs_)
        else:
            return activeInterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_excludePorts(self): return self.excludePorts
    def set_excludePorts(self, excludePorts): self.excludePorts = excludePorts
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def hasContent_(self):
        if (
            self.isPresent is not None or
            self.description is not None or
            self.excludePorts is not None or
            self.vendorExtensions is not None or
            super(activeInterface, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='activeInterface', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('activeInterface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='activeInterface')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='activeInterface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='activeInterface'):
        super(activeInterface, self).exportAttributes(outfile, level, already_processed, namespace_, name_='activeInterface')
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='activeInterface', fromsubclass_=False, pretty_print=True):
        super(activeInterface, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.excludePorts is not None:
            self.excludePorts.export(outfile, level, namespace_, name_='excludePorts', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(activeInterface, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'excludePorts':
            obj_ = excludePortsType.factory()
            obj_.build(child_)
            self.excludePorts = obj_
            obj_.original_tagname_ = 'excludePorts'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
        super(activeInterface, self).buildChildren(child_, node, nodeName_, True)
# end class activeInterface


class assertion(GeneratedsSuper):
    """Provides an expression for describing valid parameter value
    settings. If a assertion assert expression evaluates false, the
    name, displayName and/or description can be used to communicate
    the assertion failure."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('assert_', 'unsignedBitExpression', 0, 0, {'type': 'unsignedBitExpression', 'name': 'assert'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, assert_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.assert_ = assert_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, assertion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if assertion.subclass:
            return assertion.subclass(*args_, **kwargs_)
        else:
            return assertion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_assert(self): return self.assert_
    def set_assert(self, assert_): self.assert_ = assert_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.assert_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='assertion', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('assertion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='assertion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='assertion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='assertion'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='assertion', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.assert_ is not None:
            self.assert_.export(outfile, level, namespace_, name_='assert', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'assert':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.assert_ = obj_
            obj_.original_tagname_ = 'assert'
# end class assertion


class assertions(GeneratedsSuper):
    """List of assertions about allowed parameter values."""
    member_data_items_ = [
        MemberSpec_('assertion', 'assertion', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'assertion', 'name': 'assertion', 'type': 'assertion'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, assertion=None):
        self.original_tagname_ = None
        if assertion is None:
            self.assertion = []
        else:
            self.assertion = assertion
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, assertions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if assertions.subclass:
            return assertions.subclass(*args_, **kwargs_)
        else:
            return assertions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assertion(self): return self.assertion
    def set_assertion(self, assertion): self.assertion = assertion
    def add_assertion(self, value): self.assertion.append(value)
    def insert_assertion_at(self, index, value): self.assertion.insert(index, value)
    def replace_assertion_at(self, index, value): self.assertion[index] = value
    def hasContent_(self):
        if (
            self.assertion
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='assertions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('assertions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='assertions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='assertions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='assertions'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='assertions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for assertion_ in self.assertion:
            assertion_.export(outfile, level, namespace_='ipxact:', name_='assertion', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'assertion':
            obj_ = assertion.factory()
            obj_.build(child_)
            self.assertion.append(obj_)
            obj_.original_tagname_ = 'assertion'
# end class assertions


class parameters(GeneratedsSuper):
    """A collection of parameters and associated value assertions."""
    member_data_items_ = [
        MemberSpec_('parameter', 'parameterType', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'parameter', 'name': 'parameter', 'type': 'parameterType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, parameter=None):
        self.original_tagname_ = None
        if parameter is None:
            self.parameter = []
        else:
            self.parameter = parameter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parameters.subclass:
            return parameters.subclass(*args_, **kwargs_)
        else:
            return parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parameter(self): return self.parameter
    def set_parameter(self, parameter): self.parameter = parameter
    def add_parameter(self, value): self.parameter.append(value)
    def insert_parameter_at(self, index, value): self.parameter.insert(index, value)
    def replace_parameter_at(self, index, value): self.parameter[index] = value
    def hasContent_(self):
        if (
            self.parameter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='parameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='parameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='parameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for parameter_ in self.parameter:
            parameter_.export(outfile, level, namespace_='ipxact:', name_='parameter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameter':
            class_obj_ = self.get_class_obj_(child_, parameterType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.parameter.append(obj_)
            obj_.original_tagname_ = 'parameter'
# end class parameters


class vendorExtensions(GeneratedsSuper):
    """Container for vendor specific extensions."""
    member_data_items_ = [
        MemberSpec_('__ANY__', '__ANY__', 1, 0, {'processContents': 'lax', 'namespace': '##any', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vendorExtensions)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vendorExtensions.subclass:
            return vendorExtensions.subclass(*args_, **kwargs_)
        else:
            return vendorExtensions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='vendorExtensions', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vendorExtensions')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vendorExtensions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='vendorExtensions'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='vendorExtensions', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'vendorExtensions')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class vendorExtensions


class leafAccessHandle(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('force', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'viewRef', 'type': 'viewRefType'}, None),
        MemberSpec_('indices', 'indicesType2', 0, 1, {'minOccurs': '0', 'type': 'indicesType2', 'name': 'indices'}, None),
        MemberSpec_('slices', 'slicesType', 0, 0, {'type': 'slicesType', 'name': 'slices'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, force=True, id=None, viewRef=None, indices=None, slices=None):
        self.original_tagname_ = None
        self.force = _cast(bool, force)
        self.id = _cast(None, id)
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.indices = indices
        self.slices = slices
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, leafAccessHandle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if leafAccessHandle.subclass:
            return leafAccessHandle.subclass(*args_, **kwargs_)
        else:
            return leafAccessHandle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_viewRef(self): return self.viewRef
    def set_viewRef(self, viewRef): self.viewRef = viewRef
    def add_viewRef(self, value): self.viewRef.append(value)
    def insert_viewRef_at(self, index, value): self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value): self.viewRef[index] = value
    def get_indices(self): return self.indices
    def set_indices(self, indices): self.indices = indices
    def get_slices(self): return self.slices
    def set_slices(self, slices): self.slices = slices
    def get_force(self): return self.force
    def set_force(self, force): self.force = force
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.viewRef or
            self.indices is not None or
            self.slices is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='leafAccessHandle', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('leafAccessHandle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='leafAccessHandle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='leafAccessHandle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='leafAccessHandle'):
        if not self.force and 'force' not in already_processed:
            already_processed.add('force')
            outfile.write(' force="%s"' % self.gds_format_boolean(self.force, input_name='force'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='leafAccessHandle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for viewRef_ in self.viewRef:
            viewRef_.export(outfile, level, namespace_, name_='viewRef', pretty_print=pretty_print)
        if self.indices is not None:
            self.indices.export(outfile, level, namespace_, name_='indices', pretty_print=pretty_print)
        if self.slices is not None:
            self.slices.export(outfile, level, namespace_, name_='slices', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('force', node)
        if value is not None and 'force' not in already_processed:
            already_processed.add('force')
            if value in ('true', '1'):
                self.force = True
            elif value in ('false', '0'):
                self.force = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'viewRef':
            obj_ = viewRefType.factory()
            obj_.build(child_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
        elif nodeName_ == 'indices':
            obj_ = indicesType2.factory()
            obj_.build(child_)
            self.indices = obj_
            obj_.original_tagname_ = 'indices'
        elif nodeName_ == 'slices':
            obj_ = slicesType.factory()
            obj_.build(child_)
            self.slices = obj_
            obj_.original_tagname_ = 'slices'
# end class leafAccessHandle


class nonIndexedLeafAccessHandle(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('force', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'viewRef', 'type': 'viewRefType3'}, None),
        MemberSpec_('slices', 'slicesType', 0, 0, {'type': 'slicesType', 'name': 'slices'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, force=True, id=None, viewRef=None, slices=None):
        self.original_tagname_ = None
        self.force = _cast(bool, force)
        self.id = _cast(None, id)
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.slices = slices
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nonIndexedLeafAccessHandle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nonIndexedLeafAccessHandle.subclass:
            return nonIndexedLeafAccessHandle.subclass(*args_, **kwargs_)
        else:
            return nonIndexedLeafAccessHandle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_viewRef(self): return self.viewRef
    def set_viewRef(self, viewRef): self.viewRef = viewRef
    def add_viewRef(self, value): self.viewRef.append(value)
    def insert_viewRef_at(self, index, value): self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value): self.viewRef[index] = value
    def get_slices(self): return self.slices
    def set_slices(self, slices): self.slices = slices
    def get_force(self): return self.force
    def set_force(self, force): self.force = force
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.viewRef or
            self.slices is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='nonIndexedLeafAccessHandle', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nonIndexedLeafAccessHandle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nonIndexedLeafAccessHandle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='nonIndexedLeafAccessHandle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='nonIndexedLeafAccessHandle'):
        if not self.force and 'force' not in already_processed:
            already_processed.add('force')
            outfile.write(' force="%s"' % self.gds_format_boolean(self.force, input_name='force'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='nonIndexedLeafAccessHandle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for viewRef_ in self.viewRef:
            viewRef_.export(outfile, level, namespace_, name_='viewRef', pretty_print=pretty_print)
        if self.slices is not None:
            self.slices.export(outfile, level, namespace_, name_='slices', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('force', node)
        if value is not None and 'force' not in already_processed:
            already_processed.add('force')
            if value in ('true', '1'):
                self.force = True
            elif value in ('false', '0'):
                self.force = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'viewRef':
            obj_ = viewRefType3.factory()
            obj_.build(child_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
        elif nodeName_ == 'slices':
            obj_ = slicesType.factory()
            obj_.build(child_)
            self.slices = obj_
            obj_.original_tagname_ = 'slices'
# end class nonIndexedLeafAccessHandle


class indexedAccessHandle(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'viewRef', 'type': 'viewRefType4'}, None),
        MemberSpec_('indices', 'indicesType5', 0, 1, {'minOccurs': '0', 'type': 'indicesType5', 'name': 'indices'}, None),
        MemberSpec_('pathSegments', 'pathSegmentsType', 0, 0, {'type': 'pathSegmentsType', 'name': 'pathSegments'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, viewRef=None, indices=None, pathSegments=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.indices = indices
        self.pathSegments = pathSegments
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indexedAccessHandle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indexedAccessHandle.subclass:
            return indexedAccessHandle.subclass(*args_, **kwargs_)
        else:
            return indexedAccessHandle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_viewRef(self): return self.viewRef
    def set_viewRef(self, viewRef): self.viewRef = viewRef
    def add_viewRef(self, value): self.viewRef.append(value)
    def insert_viewRef_at(self, index, value): self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value): self.viewRef[index] = value
    def get_indices(self): return self.indices
    def set_indices(self, indices): self.indices = indices
    def get_pathSegments(self): return self.pathSegments
    def set_pathSegments(self, pathSegments): self.pathSegments = pathSegments
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.viewRef or
            self.indices is not None or
            self.pathSegments is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='indexedAccessHandle', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indexedAccessHandle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indexedAccessHandle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='indexedAccessHandle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='indexedAccessHandle'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='indexedAccessHandle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for viewRef_ in self.viewRef:
            viewRef_.export(outfile, level, namespace_, name_='viewRef', pretty_print=pretty_print)
        if self.indices is not None:
            self.indices.export(outfile, level, namespace_, name_='indices', pretty_print=pretty_print)
        if self.pathSegments is not None:
            self.pathSegments.export(outfile, level, namespace_, name_='pathSegments', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'viewRef':
            obj_ = viewRefType4.factory()
            obj_.build(child_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
        elif nodeName_ == 'indices':
            obj_ = indicesType5.factory()
            obj_.build(child_)
            self.indices = obj_
            obj_.original_tagname_ = 'indices'
        elif nodeName_ == 'pathSegments':
            obj_ = pathSegmentsType.factory()
            obj_.build(child_)
            self.pathSegments = obj_
            obj_.original_tagname_ = 'pathSegments'
# end class indexedAccessHandle


class simpleAccessHandle(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'viewRef', 'type': 'viewRefType6'}, None),
        MemberSpec_('pathSegments', 'pathSegmentsType7', 0, 0, {'type': 'pathSegmentsType7', 'name': 'pathSegments'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, viewRef=None, pathSegments=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.pathSegments = pathSegments
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, simpleAccessHandle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if simpleAccessHandle.subclass:
            return simpleAccessHandle.subclass(*args_, **kwargs_)
        else:
            return simpleAccessHandle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_viewRef(self): return self.viewRef
    def set_viewRef(self, viewRef): self.viewRef = viewRef
    def add_viewRef(self, value): self.viewRef.append(value)
    def insert_viewRef_at(self, index, value): self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value): self.viewRef[index] = value
    def get_pathSegments(self): return self.pathSegments
    def set_pathSegments(self, pathSegments): self.pathSegments = pathSegments
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.viewRef or
            self.pathSegments is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='simpleAccessHandle', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('simpleAccessHandle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='simpleAccessHandle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='simpleAccessHandle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='simpleAccessHandle'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='simpleAccessHandle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for viewRef_ in self.viewRef:
            viewRef_.export(outfile, level, namespace_, name_='viewRef', pretty_print=pretty_print)
        if self.pathSegments is not None:
            self.pathSegments.export(outfile, level, namespace_, name_='pathSegments', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'viewRef':
            obj_ = viewRefType6.factory()
            obj_.build(child_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
        elif nodeName_ == 'pathSegments':
            obj_ = pathSegmentsType7.factory()
            obj_.build(child_)
            self.pathSegments = obj_
            obj_.original_tagname_ = 'pathSegments'
# end class simpleAccessHandle


class slicesType(GeneratedsSuper):
    """Each slice specifies the HDL path for part of the parent IP-XACT
    object. The slices must be concatenated to calculate the entire
    path. If there is only one slice, it is assumed to be the path
    for the entire IP-XACT object."""
    member_data_items_ = [
        MemberSpec_('slice', 'sliceType', 1, 0, {'type': 'sliceType', 'name': 'slice', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, slice=None):
        self.original_tagname_ = None
        if slice is None:
            self.slice = []
        else:
            self.slice = slice
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, slicesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if slicesType.subclass:
            return slicesType.subclass(*args_, **kwargs_)
        else:
            return slicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_slice(self): return self.slice
    def set_slice(self, slice): self.slice = slice
    def add_slice(self, value): self.slice.append(value)
    def insert_slice_at(self, index, value): self.slice.insert(index, value)
    def replace_slice_at(self, index, value): self.slice[index] = value
    def hasContent_(self):
        if (
            self.slice
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='slicesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('slicesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='slicesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='slicesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='slicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='slicesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for slice_ in self.slice:
            slice_.export(outfile, level, namespace_, name_='slice', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'slice':
            obj_ = sliceType.factory()
            obj_.build(child_)
            self.slice.append(obj_)
            obj_.original_tagname_ = 'slice'
# end class slicesType


class sliceType(GeneratedsSuper):
    """Contains the HDL path information for a slice of the IP-XACT object."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('pathSegments', 'pathSegmentsType8', 0, 0, {'type': 'pathSegmentsType8', 'name': 'pathSegments'}, None),
        MemberSpec_('Range', 'range', 0, 1, {'minOccurs': '0', 'type': 'range', 'ref': 'range', 'name': 'range'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, pathSegments=None, Range=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.pathSegments = pathSegments
        self.Range = Range
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sliceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sliceType.subclass:
            return sliceType.subclass(*args_, **kwargs_)
        else:
            return sliceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pathSegments(self): return self.pathSegments
    def set_pathSegments(self, pathSegments): self.pathSegments = pathSegments
    def get_range(self): return self.Range
    def set_range(self, Range): self.Range = Range
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.pathSegments is not None or
            self.Range is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='sliceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sliceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sliceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='sliceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='sliceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='sliceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pathSegments is not None:
            self.pathSegments.export(outfile, level, namespace_, name_='pathSegments', pretty_print=pretty_print)
        if self.Range is not None:
            self.Range.export(outfile, level, namespace_='ipxact:', name_='range', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pathSegments':
            obj_ = pathSegmentsType8.factory()
            obj_.build(child_)
            self.pathSegments = obj_
            obj_.original_tagname_ = 'pathSegments'
        elif nodeName_ == 'range':
            obj_ = Range.factory()
            obj_.build(child_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
# end class sliceType


class pathSegmentType(GeneratedsSuper):
    """Identifies one level of hierarchy in the view specifed by
    viewNameRef. This is a simple name and optionally some indices
    into a multi dimensional element."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('pathSegmentName', 'xs:string', 0, 0, {'type': 'xs:string', 'name': 'pathSegmentName'}, None),
        MemberSpec_('indices', 'indicesType', 0, 1, {'minOccurs': '0', 'type': 'indicesType', 'name': 'indices'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, pathSegmentName=None, indices=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.pathSegmentName = pathSegmentName
        self.indices = indices
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathSegmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathSegmentType.subclass:
            return pathSegmentType.subclass(*args_, **kwargs_)
        else:
            return pathSegmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pathSegmentName(self): return self.pathSegmentName
    def set_pathSegmentName(self, pathSegmentName): self.pathSegmentName = pathSegmentName
    def get_indices(self): return self.indices
    def set_indices(self, indices): self.indices = indices
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.pathSegmentName is not None or
            self.indices is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='pathSegmentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pathSegmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pathSegmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='pathSegmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='pathSegmentType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='pathSegmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pathSegmentName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:pathSegmentName>%s</ipxact:pathSegmentName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.pathSegmentName), input_name='pathSegmentName')), eol_))
        if self.indices is not None:
            self.indices.export(outfile, level, namespace_, name_='indices', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pathSegmentName':
            pathSegmentName_ = child_.text
            pathSegmentName_ = self.gds_validate_string(pathSegmentName_, node, 'pathSegmentName')
            self.pathSegmentName = pathSegmentName_
        elif nodeName_ == 'indices':
            obj_ = indicesType.factory()
            obj_.build(child_)
            self.indices = obj_
            obj_.original_tagname_ = 'indices'
# end class pathSegmentType


class parameterBaseType(GeneratedsSuper):
    """Name and value type for use in resolvable elementsID attribute for
    uniquely identifying a parameter within its document. Attribute
    is used to refer to this from a configurable element.Provides a
    string used to prompt the user for user-resolved property
    values.For user defined properties, refers the choice element
    enumerating the values to choose from.For components with auto-
    generated configuration forms, the user-resolved properties with
    order attibutes will be presented in ascending order.Tags
    configurable properties so that they may be grouped together.
    Configurable properties with matching values for this attribute
    are contained in the same group. The format of this attribute is
    a string. There is no semantic meaning to this attribute.For
    user-resolved properties with numeric values, this indicates the
    minimum value allowed. Only valid for the types: byte, shortint,
    int, longint, shortreal and real. The type of this value is the
    same as the type of the parameter-value, which is specified by
    the parameter-type attribute.For user-resolved properties with
    numeric values, this indicates the maximum value allowed. Only
    valid for the types: byte, shortint, int, longint, shortreal and
    real. The type of this value is the same as the type of the
    parameter-value, which is specified by the parameter-type
    attribute.Specifies the type of the value of the parameter. A
    parameter of type byte is resolved to an 8-bit integer value,
    shortint is resolved to a 16-bit integer value, int is resolved
    to a 32-bit integer value, longint is resolved to a 64-bit
    integer value, shortreal is resolved to a 32-bit floating point
    value, real is resolved to a 64-bit floating point value, bit is
    by default resolved to a one bit value, unless a vector size has
    been specified and the string type is resolved to a string
    value.Specify the signedness explicitly. The data types byte,
    shortint, int, longint default to signed. The data type bit
    defaults to unsigned. When setting this values for the data
    types string, real and shortreal the setting is ignored.Defines
    the prefix that precedes the unit of a value. The prefix is not
    applied to the value (e.g. in calculations).Defines the unit of
    the value."""
    member_data_items_ = [
        MemberSpec_('parameterId', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('prompt', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('choiceRef', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('order', 'xs:float', 0, 1, {'use': 'optional'}),
        MemberSpec_('configGroups', 'xs:NMTOKENS', 0, 1, {'use': 'optional'}),
        MemberSpec_('minimum', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('maximum', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('type_', 'ipxact:formatType', 0, 1, {'use': 'optional'}),
        MemberSpec_('sign', 'ipxact:signType', 0, 1, {'use': 'optional'}),
        MemberSpec_('prefix', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('unit', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:string', 0, 0, {'type': 'xs:string', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('Vectors', 'vectors', 0, 1, {'minOccurs': '0', 'type': 'vectors', 'ref': 'vectors', 'name': 'vectors'}, None),
        MemberSpec_('arrays', 'configurableArrays', 0, 1, {'minOccurs': '0', 'type': 'configurableArrays', 'name': 'arrays'}, None),
        MemberSpec_('value', 'stringExpression', 0, 0, {'type': 'complexBaseExpression', 'name': 'value'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, parameterId=None, prompt=None, choiceRef=None, order=None, configGroups=None, minimum=None, maximum=None, type_='string', sign=None, prefix=None, unit=None, name=None, displayName=None, description=None, Vectors=None, arrays=None, value=None, vendorExtensions=None, extensiontype_=None):
        self.original_tagname_ = None
        self.parameterId = _cast(None, parameterId)
        self.prompt = _cast(None, prompt)
        self.choiceRef = _cast(None, choiceRef)
        self.order = _cast(float, order)
        self.configGroups = _cast(None, configGroups)
        self.minimum = _cast(None, minimum)
        self.maximum = _cast(None, maximum)
        self.type_ = _cast(None, type_)
        self.sign = _cast(None, sign)
        self.prefix = _cast(None, prefix)
        self.unit = _cast(None, unit)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.Vectors = Vectors
        self.arrays = arrays
        self.value = value
        self.vendorExtensions = vendorExtensions
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parameterBaseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parameterBaseType.subclass:
            return parameterBaseType.subclass(*args_, **kwargs_)
        else:
            return parameterBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_vectors(self): return self.Vectors
    def set_vectors(self, Vectors): self.Vectors = Vectors
    def get_arrays(self): return self.arrays
    def set_arrays(self, arrays): self.arrays = arrays
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_parameterId(self): return self.parameterId
    def set_parameterId(self, parameterId): self.parameterId = parameterId
    def get_prompt(self): return self.prompt
    def set_prompt(self, prompt): self.prompt = prompt
    def get_choiceRef(self): return self.choiceRef
    def set_choiceRef(self, choiceRef): self.choiceRef = choiceRef
    def get_order(self): return self.order
    def set_order(self, order): self.order = order
    def get_configGroups(self): return self.configGroups
    def set_configGroups(self, configGroups): self.configGroups = configGroups
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_sign(self): return self.sign
    def set_sign(self, sign): self.sign = sign
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.Vectors is not None or
            self.arrays is not None or
            self.value is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='parameterBaseType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parameterBaseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parameterBaseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='parameterBaseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='parameterBaseType'):
        if self.parameterId is not None and 'parameterId' not in already_processed:
            already_processed.add('parameterId')
            outfile.write(' parameterId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.parameterId), input_name='parameterId')), ))
        if self.prompt is not None and 'prompt' not in already_processed:
            already_processed.add('prompt')
            outfile.write(' prompt=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prompt), input_name='prompt')), ))
        if self.choiceRef is not None and 'choiceRef' not in already_processed:
            already_processed.add('choiceRef')
            outfile.write(' choiceRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.choiceRef), input_name='choiceRef')), ))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_float(self.order, input_name='order'))
        if self.configGroups is not None and 'configGroups' not in already_processed:
            already_processed.add('configGroups')
            outfile.write(' configGroups=%s' % (quote_attrib(self.configGroups), ))
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.minimum), input_name='minimum')), ))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.maximum), input_name='maximum')), ))
        if self.type_ != "string" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.sign is not None and 'sign' not in already_processed:
            already_processed.add('sign')
            outfile.write(' sign=%s' % (quote_attrib(self.sign), ))
        if self.prefix is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            outfile.write(' prefix=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.prefix), input_name='prefix')), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.unit), input_name='unit')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='parameterBaseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.Vectors is not None:
            self.Vectors.export(outfile, level, namespace_='ipxact:', name_='vectors', pretty_print=pretty_print)
        if self.arrays is not None:
            self.arrays.export(outfile, level, namespace_, name_='arrays', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parameterId', node)
        if value is not None and 'parameterId' not in already_processed:
            already_processed.add('parameterId')
            self.parameterId = value
        value = find_attr_value_('prompt', node)
        if value is not None and 'prompt' not in already_processed:
            already_processed.add('prompt')
            self.prompt = value
        value = find_attr_value_('choiceRef', node)
        if value is not None and 'choiceRef' not in already_processed:
            already_processed.add('choiceRef')
            self.choiceRef = value
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            try:
                self.order = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (order): %s' % exp)
        value = find_attr_value_('configGroups', node)
        if value is not None and 'configGroups' not in already_processed:
            already_processed.add('configGroups')
            self.configGroups = value
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            self.minimum = value
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            self.maximum = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('sign', node)
        if value is not None and 'sign' not in already_processed:
            already_processed.add('sign')
            self.sign = value
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            self.prefix = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'vectors':
            obj_ = Vectors.factory()
            obj_.build(child_)
            self.Vectors = obj_
            obj_.original_tagname_ = 'vectors'
        elif nodeName_ == 'arrays':
            obj_ = configurableArrays.factory()
            obj_.build(child_)
            self.arrays = obj_
            obj_.original_tagname_ = 'arrays'
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class parameterBaseType


class parameterType(parameterBaseType):
    """Determines how a property value can be configured.Determines how a
    parameter is resolved. User means the value must be obtained
    from the user. Generated means the value will be provided by a
    generator.Property content cannot be modified through
    configuration.Property content can be modified through
    configuration. Modifications will be saved with the
    design.Generators may modify this property. Modifications get
    saved with the design."""
    member_data_items_ = [
        MemberSpec_('resolve', 'xs:token', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = parameterBaseType
    def __init__(self, parameterId=None, prompt=None, choiceRef=None, order=None, configGroups=None, minimum=None, maximum=None, type_='string', sign=None, prefix=None, unit=None, name=None, displayName=None, description=None, Vectors=None, arrays=None, value=None, vendorExtensions=None, resolve='immediate', extensiontype_=None):
        self.original_tagname_ = None
        super(parameterType, self).__init__(parameterId, prompt, choiceRef, order, configGroups, minimum, maximum, type_, sign, prefix, unit, name, displayName, description, Vectors, arrays, value, vendorExtensions, extensiontype_, )
        self.resolve = _cast(None, resolve)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, parameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if parameterType.subclass:
            return parameterType.subclass(*args_, **kwargs_)
        else:
            return parameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resolve(self): return self.resolve
    def set_resolve(self, resolve): self.resolve = resolve
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(parameterType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='parameterType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('parameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='parameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='parameterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='parameterType'):
        super(parameterType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='parameterType')
        if self.resolve != "immediate" and 'resolve' not in already_processed:
            already_processed.add('resolve')
            outfile.write(' resolve=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.resolve), input_name='resolve')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='parameterType', fromsubclass_=False, pretty_print=True):
        super(parameterType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resolve', node)
        if value is not None and 'resolve' not in already_processed:
            already_processed.add('resolve')
            self.resolve = value
            self.resolve = ' '.join(self.resolve.split())
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(parameterType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(parameterType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class parameterType


class nameValuePairType(GeneratedsSuper):
    """Name and value type for use in resolvable elements"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:string', 0, 0, {'type': 'xs:string', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('value', 'stringExpression', 0, 0, {'type': 'complexBaseExpression', 'ref': 'value', 'name': 'value'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, value=None, vendorExtensions=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.value = value
        self.vendorExtensions = vendorExtensions
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nameValuePairType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nameValuePairType.subclass:
            return nameValuePairType.subclass(*args_, **kwargs_)
        else:
            return nameValuePairType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.value is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='nameValuePairType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nameValuePairType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nameValuePairType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='nameValuePairType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='nameValuePairType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='nameValuePairType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.value is not None:
            self.value.export(outfile, level, namespace_='ipxact:', name_='value', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class nameValuePairType


class Vector(GeneratedsSuper):
    """Left and right ranges of the vector."""
    member_data_items_ = [
        MemberSpec_('left', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'ref': 'left', 'name': 'left'}, None),
        MemberSpec_('right', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'ref': 'right', 'name': 'right'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, left=None, right=None):
        self.original_tagname_ = None
        self.left = left
        self.right = right
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Vector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Vector.subclass:
            return Vector.subclass(*args_, **kwargs_)
        else:
            return Vector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_left(self): return self.left
    def set_left(self, left): self.left = left
    def get_right(self): return self.right
    def set_right(self, right): self.right = right
    def hasContent_(self):
        if (
            self.left is not None or
            self.right is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='vector', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='vector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='vector'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='vector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left is not None:
            self.left.export(outfile, level, namespace_='ipxact:', name_='left', pretty_print=pretty_print)
        if self.right is not None:
            self.right.export(outfile, level, namespace_='ipxact:', name_='right', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'left':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.left = obj_
            obj_.original_tagname_ = 'left'
        elif nodeName_ == 'right':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.right = obj_
            obj_.original_tagname_ = 'right'
# end class Vector


class Vectors(GeneratedsSuper):
    """Vectored information."""
    member_data_items_ = [
        MemberSpec_('Vector', 'vector', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'vector', 'name': 'vector', 'type': 'vector'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, Vector=None):
        self.original_tagname_ = None
        if Vector is None:
            self.Vector = []
        else:
            self.Vector = Vector
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Vectors)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Vectors.subclass:
            return Vectors.subclass(*args_, **kwargs_)
        else:
            return Vectors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vector(self): return self.Vector
    def set_vector(self, Vector): self.Vector = Vector
    def add_vector(self, value): self.Vector.append(value)
    def insert_vector_at(self, index, value): self.Vector.insert(index, value)
    def replace_vector_at(self, index, value): self.Vector[index] = value
    def hasContent_(self):
        if (
            self.Vector
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='vectors', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vectors')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vectors')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='vectors', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='vectors'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='vectors', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vector_ in self.Vector:
            vector_.export(outfile, level, namespace_='ipxact:', name_='vector', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vector':
            obj_ = Vector.factory()
            obj_.build(child_)
            self.Vector.append(obj_)
            obj_.original_tagname_ = 'vector'
# end class Vectors


class Range(GeneratedsSuper):
    """Left and right bound of a reference into a vector."""
    member_data_items_ = [
        MemberSpec_('left', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'ref': 'left', 'name': 'left'}, None),
        MemberSpec_('right', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'ref': 'right', 'name': 'right'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, left=None, right=None):
        self.original_tagname_ = None
        self.left = left
        self.right = right
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Range)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Range.subclass:
            return Range.subclass(*args_, **kwargs_)
        else:
            return Range(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_left(self): return self.left
    def set_left(self, left): self.left = left
    def get_right(self): return self.right
    def set_right(self, right): self.right = right
    def hasContent_(self):
        if (
            self.left is not None or
            self.right is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='range', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('range')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='range')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='range', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='range'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='range', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left is not None:
            self.left.export(outfile, level, namespace_='ipxact:', name_='left', pretty_print=pretty_print)
        if self.right is not None:
            self.right.export(outfile, level, namespace_='ipxact:', name_='right', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'left':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.left = obj_
            obj_.original_tagname_ = 'left'
        elif nodeName_ == 'right':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.right = obj_
            obj_.original_tagname_ = 'right'
# end class Range


class PartSelect(GeneratedsSuper):
    """Bit range definition."""
    member_data_items_ = [
        MemberSpec_('indices', 'indicesType', 0, 0, {'type': 'indicesType', 'name': 'indices'}, 5),
        MemberSpec_('Range', 'range', 0, 1, {'minOccurs': '0', 'type': 'range', 'ref': 'range', 'name': 'range'}, 5),
    ]
    subclass = None
    superclass = None
    def __init__(self, indices=None, Range=None):
        self.original_tagname_ = None
        self.indices = indices
        self.Range = Range
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PartSelect)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PartSelect.subclass:
            return PartSelect.subclass(*args_, **kwargs_)
        else:
            return PartSelect(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indices(self): return self.indices
    def set_indices(self, indices): self.indices = indices
    def get_range(self): return self.Range
    def set_range(self, Range): self.Range = Range
    def hasContent_(self):
        if (
            self.indices is not None or
            self.Range is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='partSelect', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('partSelect')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='partSelect')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='partSelect', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='partSelect'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='partSelect', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indices is not None:
            self.indices.export(outfile, level, namespace_, name_='indices', pretty_print=pretty_print)
        if self.Range is not None:
            self.Range.export(outfile, level, namespace_='ipxact:', name_='range', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indices':
            obj_ = indicesType.factory()
            obj_.build(child_)
            self.indices = obj_
            obj_.original_tagname_ = 'indices'
        elif nodeName_ == 'range':
            obj_ = Range.factory()
            obj_.build(child_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
# end class PartSelect


class configurableArrays(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('array', 'arrayType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'array', 'type': 'arrayType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, array=None):
        self.original_tagname_ = None
        if array is None:
            self.array = []
        else:
            self.array = array
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, configurableArrays)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if configurableArrays.subclass:
            return configurableArrays.subclass(*args_, **kwargs_)
        else:
            return configurableArrays(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_array(self): return self.array
    def set_array(self, array): self.array = array
    def add_array(self, value): self.array.append(value)
    def insert_array_at(self, index, value): self.array.insert(index, value)
    def replace_array_at(self, index, value): self.array[index] = value
    def hasContent_(self):
        if (
            self.array
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='configurableArrays', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('configurableArrays')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='configurableArrays')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='configurableArrays', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='configurableArrays'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='configurableArrays', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for array_ in self.array:
            array_.export(outfile, level, namespace_, name_='array', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'array':
            obj_ = arrayType.factory()
            obj_.build(child_)
            self.array.append(obj_)
            obj_.original_tagname_ = 'array'
# end class configurableArrays


class indicesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('index', 'unsignedIntExpression', 1, 0, {'type': 'unsignedIntExpression', 'name': 'index', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, index=None):
        self.original_tagname_ = None
        if index is None:
            self.index = []
        else:
            self.index = index
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indicesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indicesType.subclass:
            return indicesType.subclass(*args_, **kwargs_)
        else:
            return indicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def add_index(self, value): self.index.append(value)
    def insert_index_at(self, index, value): self.index.insert(index, value)
    def replace_index_at(self, index, value): self.index[index] = value
    def hasContent_(self):
        if (
            self.index
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='indicesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indicesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indicesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='indicesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='indicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='indicesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for index_ in self.index:
            index_.export(outfile, level, namespace_, name_='index', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'index':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.index.append(obj_)
            obj_.original_tagname_ = 'index'
# end class indicesType


class Port(GeneratedsSuper):
    """A port description, giving a name and an access type for high level
    ports. Port style"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', ['portName', 'xs:string'], 0, 0, {'type': 'xs:string', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('wire', 'portWireType', 0, 0, {'type': 'portWireType', 'name': 'wire'}, 6),
        MemberSpec_('transactional', 'portTransactionalType', 0, 0, {'type': 'portTransactionalType', 'name': 'transactional'}, 6),
        MemberSpec_('arrays', 'configurableArrays', 0, 1, {'minOccurs': '0', 'type': 'configurableArrays', 'ref': 'arrays', 'name': 'arrays'}, None),
        MemberSpec_('access', 'xs:token', 0, 1, {'minOccurs': '0', 'type': 'portAccessType', 'name': 'access'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, wire=None, transactional=None, arrays=None, access=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.validate_portName(self.name)
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        self.wire = wire
        self.transactional = transactional
        self.arrays = arrays
        self.access = access
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Port)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Port.subclass:
            return Port.subclass(*args_, **kwargs_)
        else:
            return Port(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_wire(self): return self.wire
    def set_wire(self, wire): self.wire = wire
    def get_transactional(self): return self.transactional
    def set_transactional(self, transactional): self.transactional = transactional
    def get_arrays(self): return self.arrays
    def set_arrays(self, arrays): self.arrays = arrays
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_portName(self, value):
        # Validate type portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_portName_patterns_, ))
    validate_portName_patterns_ = [['^[A-Za-z0-9\\.\\-:_]*$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.wire is not None or
            self.transactional is not None or
            self.arrays is not None or
            self.access is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='portType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='portType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='portType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='portType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.wire is not None:
            self.wire.export(outfile, level, namespace_, name_='wire', pretty_print=pretty_print)
        if self.transactional is not None:
            self.transactional.export(outfile, level, namespace_, name_='transactional', pretty_print=pretty_print)
        if self.arrays is not None:
            self.arrays.export(outfile, level, namespace_='ipxact:', name_='arrays', pretty_print=pretty_print)
        if self.access is not None:
            self.access.export(outfile, level, namespace_, name_='access', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type portName
            self.validate_portName(self.name)
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'wire':
            obj_ = PortWire.factory()
            obj_.build(child_)
            self.wire = obj_
            obj_.original_tagname_ = 'wire'
        elif nodeName_ == 'transactional':
            obj_ = portTransactionalType.factory()
            obj_.build(child_)
            self.transactional = obj_
            obj_.original_tagname_ = 'transactional'
        elif nodeName_ == 'arrays':
            obj_ = configurableArrays.factory()
            obj_.build(child_)
            self.arrays = obj_
            obj_.original_tagname_ = 'arrays'
        elif nodeName_ == 'access':
            obj_ = xs_token.factory()
            obj_.build(child_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class Port


class abstractorPortType(GeneratedsSuper):
    """A port description, giving a name and an access type for high level
    ports. Port style"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', ['portName', 'xs:string'], 0, 0, {'type': 'xs:string', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('wire', 'abstractorPortWireType', 0, 0, {'type': 'abstractorPortWireType', 'name': 'wire'}, 7),
        MemberSpec_('transactional', 'portTransactionalType', 0, 0, {'type': 'portTransactionalType', 'name': 'transactional'}, 7),
        MemberSpec_('access', 'xs:token', 0, 1, {'minOccurs': '0', 'type': 'portAccessType', 'name': 'access'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, wire=None, transactional=None, access=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.validate_portName(self.name)
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        self.wire = wire
        self.transactional = transactional
        self.access = access
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorPortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorPortType.subclass:
            return abstractorPortType.subclass(*args_, **kwargs_)
        else:
            return abstractorPortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_wire(self): return self.wire
    def set_wire(self, wire): self.wire = wire
    def get_transactional(self): return self.transactional
    def set_transactional(self, transactional): self.transactional = transactional
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_portName(self, value):
        # Validate type portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_portName_patterns_, ))
    validate_portName_patterns_ = [['^[A-Za-z0-9\\.\\-:_]*$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.wire is not None or
            self.transactional is not None or
            self.access is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractorPortType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorPortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractorPortType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractorPortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractorPortType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractorPortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.wire is not None:
            self.wire.export(outfile, level, namespace_, name_='wire', pretty_print=pretty_print)
        if self.transactional is not None:
            self.transactional.export(outfile, level, namespace_, name_='transactional', pretty_print=pretty_print)
        if self.access is not None:
            self.access.export(outfile, level, namespace_, name_='access', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type portName
            self.validate_portName(self.name)
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'wire':
            obj_ = abstractorPortWireType.factory()
            obj_.build(child_)
            self.wire = obj_
            obj_.original_tagname_ = 'wire'
        elif nodeName_ == 'transactional':
            obj_ = portTransactionalType.factory()
            obj_.build(child_)
            self.transactional = obj_
            obj_.original_tagname_ = 'transactional'
        elif nodeName_ == 'access':
            obj_ = xs_token.factory()
            obj_.build(child_)
            self.access = obj_
            obj_.original_tagname_ = 'access'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class abstractorPortType


class protocol(GeneratedsSuper):
    """defines the protocol type. Defaults to tlm_base_protocol_type for
    TLM sockets"""
    member_data_items_ = [
        MemberSpec_('protocolType', 'protocolTypeType9', 0, 0, {'type': 'protocolTypeType9', 'name': 'protocolType'}, None),
        MemberSpec_('payload', 'payload', 0, 1, {'minOccurs': '0', 'type': 'payload', 'ref': 'payload', 'name': 'payload'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, protocolType=None, payload=None):
        self.original_tagname_ = None
        self.protocolType = protocolType
        self.payload = payload
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocol)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocol.subclass:
            return protocol.subclass(*args_, **kwargs_)
        else:
            return protocol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocolType(self): return self.protocolType
    def set_protocolType(self, protocolType): self.protocolType = protocolType
    def get_payload(self): return self.payload
    def set_payload(self, payload): self.payload = payload
    def hasContent_(self):
        if (
            self.protocolType is not None or
            self.payload is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='protocol', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('protocol')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='protocol')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='protocol', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='protocol'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='protocol', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.protocolType is not None:
            self.protocolType.export(outfile, level, namespace_, name_='protocolType', pretty_print=pretty_print)
        if self.payload is not None:
            self.payload.export(outfile, level, namespace_='ipxact:', name_='payload', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocolType':
            obj_ = protocolTypeType9.factory()
            obj_.build(child_)
            self.protocolType = obj_
            obj_.original_tagname_ = 'protocolType'
        elif nodeName_ == 'payload':
            obj_ = payload.factory()
            obj_.build(child_)
            self.payload = obj_
            obj_.original_tagname_ = 'payload'
# end class protocol


class kind(GeneratedsSuper):
    """Defines the protocol type. Defaults to tlm_base_protocol_type for
    TLM sockets"""
    member_data_items_ = [
        MemberSpec_('custom', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['kindType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, custom=None, valueOf_=None):
        self.original_tagname_ = None
        self.custom = _cast(None, custom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, kind)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if kind.subclass:
            return kind.subclass(*args_, **kwargs_)
        else:
            return kind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_custom(self): return self.custom
    def set_custom(self, custom): self.custom = custom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='kind', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('kind')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='kind')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='kind', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='kind'):
        if self.custom is not None and 'custom' not in already_processed:
            already_processed.add('custom')
            outfile.write(' custom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.custom), input_name='custom')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='kind', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('custom', node)
        if value is not None and 'custom' not in already_processed:
            already_processed.add('custom')
            self.custom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class kind


class payload(GeneratedsSuper):
    """defines the structure of data transported by this port"""
    member_data_items_ = [
        MemberSpec_('name', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'name': 'name'}, None),
        MemberSpec_('type_', ['typeType', 'xs:string'], 0, 0, {'type': 'xs:string', 'name': 'type'}, None),
        MemberSpec_('extension', 'extensionType', 0, 1, {'minOccurs': '0', 'type': 'extensionType', 'name': 'extension'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, type_=None, extension=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.name = name
        self.type_ = type_
        self.validate_typeType(self.type_)
        self.extension = extension
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, payload)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if payload.subclass:
            return payload.subclass(*args_, **kwargs_)
        else:
            return payload(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def validate_typeType(self, value):
        # Validate type typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['generic', 'specific']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.type_ is not None or
            self.extension is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='payload', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('payload')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='payload')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='payload', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='payload'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='payload', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:type>%s</ipxact:type>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), eol_))
        if self.extension is not None:
            self.extension.export(outfile, level, namespace_, name_='extension', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type typeType
            self.validate_typeType(self.type_)
        elif nodeName_ == 'extension':
            obj_ = extensionType.factory()
            obj_.build(child_)
            self.extension = obj_
            obj_.original_tagname_ = 'extension'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class payload


class typeParameters(GeneratedsSuper):
    """list of port type parameters (e.g. template or constructor
    parameters for a systemC port or socket)"""
    member_data_items_ = [
        MemberSpec_('typeParameter', 'moduleParameterType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'typeParameter', 'name': 'typeParameter', 'type': 'typeParameter'}, None),
        MemberSpec_('serviceTypeDef', 'serviceTypeDef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'serviceTypeDef', 'name': 'serviceTypeDef', 'type': 'serviceTypeDef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, typeParameter=None, serviceTypeDef=None):
        self.original_tagname_ = None
        if typeParameter is None:
            self.typeParameter = []
        else:
            self.typeParameter = typeParameter
        if serviceTypeDef is None:
            self.serviceTypeDef = []
        else:
            self.serviceTypeDef = serviceTypeDef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeParameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeParameters.subclass:
            return typeParameters.subclass(*args_, **kwargs_)
        else:
            return typeParameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_typeParameter(self): return self.typeParameter
    def set_typeParameter(self, typeParameter): self.typeParameter = typeParameter
    def add_typeParameter(self, value): self.typeParameter.append(value)
    def insert_typeParameter_at(self, index, value): self.typeParameter.insert(index, value)
    def replace_typeParameter_at(self, index, value): self.typeParameter[index] = value
    def get_serviceTypeDef(self): return self.serviceTypeDef
    def set_serviceTypeDef(self, serviceTypeDef): self.serviceTypeDef = serviceTypeDef
    def add_serviceTypeDef(self, value): self.serviceTypeDef.append(value)
    def insert_serviceTypeDef_at(self, index, value): self.serviceTypeDef.insert(index, value)
    def replace_serviceTypeDef_at(self, index, value): self.serviceTypeDef[index] = value
    def hasContent_(self):
        if (
            self.typeParameter or
            self.serviceTypeDef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='typeParameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeParameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typeParameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='typeParameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='typeParameters'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='typeParameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for typeParameter_ in self.typeParameter:
            typeParameter_.export(outfile, level, namespace_='ipxact:', name_='typeParameter', pretty_print=pretty_print)
        for serviceTypeDef_ in self.serviceTypeDef:
            serviceTypeDef_.export(outfile, level, namespace_='ipxact:', name_='serviceTypeDef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'typeParameter':
            obj_ = moduleParameterType.factory()
            obj_.build(child_)
            self.typeParameter.append(obj_)
            obj_.original_tagname_ = 'typeParameter'
        elif nodeName_ == 'serviceTypeDef':
            obj_ = serviceTypeDef.factory()
            obj_.build(child_)
            self.serviceTypeDef.append(obj_)
            obj_.original_tagname_ = 'serviceTypeDef'
# end class typeParameters


class transTypeDef(GeneratedsSuper):
    """Definition of a single transactional type defintion"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('typeName', 'typeNameType', 0, 1, {'minOccurs': '0', 'type': 'typeNameType', 'name': 'typeName'}, None),
        MemberSpec_('typeDefinition', 'typeDefinitionType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'typeDefinition', 'type': 'typeDefinitionType'}, None),
        MemberSpec_('typeParameters', 'typeParameters', 0, 1, {'minOccurs': '0', 'type': 'typeParameters', 'ref': 'typeParameters', 'name': 'typeParameters'}, None),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'viewRef', 'type': 'viewRefType10'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, typeName=None, typeDefinition=None, typeParameters=None, viewRef=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.typeName = typeName
        if typeDefinition is None:
            self.typeDefinition = []
        else:
            self.typeDefinition = typeDefinition
        self.typeParameters = typeParameters
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transTypeDef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transTypeDef.subclass:
            return transTypeDef.subclass(*args_, **kwargs_)
        else:
            return transTypeDef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_typeName(self): return self.typeName
    def set_typeName(self, typeName): self.typeName = typeName
    def get_typeDefinition(self): return self.typeDefinition
    def set_typeDefinition(self, typeDefinition): self.typeDefinition = typeDefinition
    def add_typeDefinition(self, value): self.typeDefinition.append(value)
    def insert_typeDefinition_at(self, index, value): self.typeDefinition.insert(index, value)
    def replace_typeDefinition_at(self, index, value): self.typeDefinition[index] = value
    def get_typeParameters(self): return self.typeParameters
    def set_typeParameters(self, typeParameters): self.typeParameters = typeParameters
    def get_viewRef(self): return self.viewRef
    def set_viewRef(self, viewRef): self.viewRef = viewRef
    def add_viewRef(self, value): self.viewRef.append(value)
    def insert_viewRef_at(self, index, value): self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value): self.viewRef[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.typeName is not None or
            self.typeDefinition or
            self.typeParameters is not None or
            self.viewRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='transTypeDef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transTypeDef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transTypeDef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='transTypeDef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='transTypeDef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='transTypeDef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.typeName is not None:
            self.typeName.export(outfile, level, namespace_, name_='typeName', pretty_print=pretty_print)
        for typeDefinition_ in self.typeDefinition:
            typeDefinition_.export(outfile, level, namespace_, name_='typeDefinition', pretty_print=pretty_print)
        if self.typeParameters is not None:
            self.typeParameters.export(outfile, level, namespace_='ipxact:', name_='typeParameters', pretty_print=pretty_print)
        for viewRef_ in self.viewRef:
            viewRef_.export(outfile, level, namespace_, name_='viewRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'typeName':
            obj_ = typeNameType.factory()
            obj_.build(child_)
            self.typeName = obj_
            obj_.original_tagname_ = 'typeName'
        elif nodeName_ == 'typeDefinition':
            obj_ = typeDefinitionType.factory()
            obj_.build(child_)
            self.typeDefinition.append(obj_)
            obj_.original_tagname_ = 'typeDefinition'
        elif nodeName_ == 'typeParameters':
            obj_ = typeParameters.factory()
            obj_.build(child_)
            self.typeParameters = obj_
            obj_.original_tagname_ = 'typeParameters'
        elif nodeName_ == 'viewRef':
            obj_ = viewRefType10.factory()
            obj_.build(child_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
# end class transTypeDef


class serviceTypeDef(GeneratedsSuper):
    """Definition of a single service type defintion"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('typeName', 'typeNameType11', 0, 0, {'type': 'typeNameType11', 'name': 'typeName'}, None),
        MemberSpec_('typeDefinition', 'typeDefinitionType12', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'typeDefinition', 'type': 'typeDefinitionType12'}, None),
        MemberSpec_('typeParameters', 'typeParameters', 0, 1, {'minOccurs': '0', 'type': 'typeParameters', 'ref': 'typeParameters', 'name': 'typeParameters'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, typeName=None, typeDefinition=None, typeParameters=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.typeName = typeName
        if typeDefinition is None:
            self.typeDefinition = []
        else:
            self.typeDefinition = typeDefinition
        self.typeParameters = typeParameters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serviceTypeDef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serviceTypeDef.subclass:
            return serviceTypeDef.subclass(*args_, **kwargs_)
        else:
            return serviceTypeDef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_typeName(self): return self.typeName
    def set_typeName(self, typeName): self.typeName = typeName
    def get_typeDefinition(self): return self.typeDefinition
    def set_typeDefinition(self, typeDefinition): self.typeDefinition = typeDefinition
    def add_typeDefinition(self, value): self.typeDefinition.append(value)
    def insert_typeDefinition_at(self, index, value): self.typeDefinition.insert(index, value)
    def replace_typeDefinition_at(self, index, value): self.typeDefinition[index] = value
    def get_typeParameters(self): return self.typeParameters
    def set_typeParameters(self, typeParameters): self.typeParameters = typeParameters
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.typeName is not None or
            self.typeDefinition or
            self.typeParameters is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='serviceTypeDef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serviceTypeDef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='serviceTypeDef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='serviceTypeDef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='serviceTypeDef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='serviceTypeDef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.typeName is not None:
            self.typeName.export(outfile, level, namespace_, name_='typeName', pretty_print=pretty_print)
        for typeDefinition_ in self.typeDefinition:
            typeDefinition_.export(outfile, level, namespace_, name_='typeDefinition', pretty_print=pretty_print)
        if self.typeParameters is not None:
            self.typeParameters.export(outfile, level, namespace_='ipxact:', name_='typeParameters', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'typeName':
            obj_ = typeNameType11.factory()
            obj_.build(child_)
            self.typeName = obj_
            obj_.original_tagname_ = 'typeName'
        elif nodeName_ == 'typeDefinition':
            obj_ = typeDefinitionType12.factory()
            obj_.build(child_)
            self.typeDefinition.append(obj_)
            obj_.original_tagname_ = 'typeDefinition'
        elif nodeName_ == 'typeParameters':
            obj_ = typeParameters.factory()
            obj_.build(child_)
            self.typeParameters = obj_
            obj_.original_tagname_ = 'typeParameters'
# end class serviceTypeDef


class wireTypeDef(GeneratedsSuper):
    """Definition of a single wire type defintion that can relate to
    multiple views."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('typeName', 'typeNameType13', 0, 1, {'minOccurs': '0', 'type': 'typeNameType13', 'name': 'typeName'}, None),
        MemberSpec_('typeDefinition', 'typeDefinitionType14', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'typeDefinition', 'type': 'typeDefinitionType14'}, None),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'viewRef', 'type': 'viewRefType15'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, typeName=None, typeDefinition=None, viewRef=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.typeName = typeName
        if typeDefinition is None:
            self.typeDefinition = []
        else:
            self.typeDefinition = typeDefinition
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, wireTypeDef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if wireTypeDef.subclass:
            return wireTypeDef.subclass(*args_, **kwargs_)
        else:
            return wireTypeDef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_typeName(self): return self.typeName
    def set_typeName(self, typeName): self.typeName = typeName
    def get_typeDefinition(self): return self.typeDefinition
    def set_typeDefinition(self, typeDefinition): self.typeDefinition = typeDefinition
    def add_typeDefinition(self, value): self.typeDefinition.append(value)
    def insert_typeDefinition_at(self, index, value): self.typeDefinition.insert(index, value)
    def replace_typeDefinition_at(self, index, value): self.typeDefinition[index] = value
    def get_viewRef(self): return self.viewRef
    def set_viewRef(self, viewRef): self.viewRef = viewRef
    def add_viewRef(self, value): self.viewRef.append(value)
    def insert_viewRef_at(self, index, value): self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value): self.viewRef[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.typeName is not None or
            self.typeDefinition or
            self.viewRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='wireTypeDef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('wireTypeDef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wireTypeDef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='wireTypeDef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='wireTypeDef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='wireTypeDef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.typeName is not None:
            self.typeName.export(outfile, level, namespace_, name_='typeName', pretty_print=pretty_print)
        for typeDefinition_ in self.typeDefinition:
            typeDefinition_.export(outfile, level, namespace_, name_='typeDefinition', pretty_print=pretty_print)
        for viewRef_ in self.viewRef:
            viewRef_.export(outfile, level, namespace_, name_='viewRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'typeName':
            obj_ = typeNameType13.factory()
            obj_.build(child_)
            self.typeName = obj_
            obj_.original_tagname_ = 'typeName'
        elif nodeName_ == 'typeDefinition':
            obj_ = typeDefinitionType14.factory()
            obj_.build(child_)
            self.typeDefinition.append(obj_)
            obj_.original_tagname_ = 'typeDefinition'
        elif nodeName_ == 'viewRef':
            obj_ = viewRefType15.factory()
            obj_.build(child_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
# end class wireTypeDef


class serviceTypeDefs(GeneratedsSuper):
    """The group of type definitions. If no match to a viewName is found
    then the default language types are to be used. See the User
    Guide for these default types."""
    member_data_items_ = [
        MemberSpec_('serviceTypeDef', 'serviceTypeDef', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'serviceTypeDef', 'name': 'serviceTypeDef', 'type': 'serviceTypeDef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, serviceTypeDef=None):
        self.original_tagname_ = None
        if serviceTypeDef is None:
            self.serviceTypeDef = []
        else:
            self.serviceTypeDef = serviceTypeDef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, serviceTypeDefs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if serviceTypeDefs.subclass:
            return serviceTypeDefs.subclass(*args_, **kwargs_)
        else:
            return serviceTypeDefs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_serviceTypeDef(self): return self.serviceTypeDef
    def set_serviceTypeDef(self, serviceTypeDef): self.serviceTypeDef = serviceTypeDef
    def add_serviceTypeDef(self, value): self.serviceTypeDef.append(value)
    def insert_serviceTypeDef_at(self, index, value): self.serviceTypeDef.insert(index, value)
    def replace_serviceTypeDef_at(self, index, value): self.serviceTypeDef[index] = value
    def hasContent_(self):
        if (
            self.serviceTypeDef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='serviceTypeDefs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('serviceTypeDefs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='serviceTypeDefs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='serviceTypeDefs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='serviceTypeDefs'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='serviceTypeDefs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for serviceTypeDef_ in self.serviceTypeDef:
            serviceTypeDef_.export(outfile, level, namespace_='ipxact:', name_='serviceTypeDef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'serviceTypeDef':
            obj_ = serviceTypeDef.factory()
            obj_.build(child_)
            self.serviceTypeDef.append(obj_)
            obj_.original_tagname_ = 'serviceTypeDef'
# end class serviceTypeDefs


class wireTypeDefs(GeneratedsSuper):
    """The group of wire type definitions. If no match to a viewName is
    found then the default language types are to be used. See the
    User Guide for these default types."""
    member_data_items_ = [
        MemberSpec_('wireTypeDef', 'wireTypeDef', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'wireTypeDef', 'name': 'wireTypeDef', 'type': 'wireTypeDef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, wireTypeDef=None):
        self.original_tagname_ = None
        if wireTypeDef is None:
            self.wireTypeDef = []
        else:
            self.wireTypeDef = wireTypeDef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, wireTypeDefs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if wireTypeDefs.subclass:
            return wireTypeDefs.subclass(*args_, **kwargs_)
        else:
            return wireTypeDefs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_wireTypeDef(self): return self.wireTypeDef
    def set_wireTypeDef(self, wireTypeDef): self.wireTypeDef = wireTypeDef
    def add_wireTypeDef(self, value): self.wireTypeDef.append(value)
    def insert_wireTypeDef_at(self, index, value): self.wireTypeDef.insert(index, value)
    def replace_wireTypeDef_at(self, index, value): self.wireTypeDef[index] = value
    def hasContent_(self):
        if (
            self.wireTypeDef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='wireTypeDefs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('wireTypeDefs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wireTypeDefs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='wireTypeDefs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='wireTypeDefs'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='wireTypeDefs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for wireTypeDef_ in self.wireTypeDef:
            wireTypeDef_.export(outfile, level, namespace_='ipxact:', name_='wireTypeDef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'wireTypeDef':
            obj_ = wireTypeDef.factory()
            obj_.build(child_)
            self.wireTypeDef.append(obj_)
            obj_.original_tagname_ = 'wireTypeDef'
# end class wireTypeDefs


class transTypeDefs(GeneratedsSuper):
    """The group of transactional type definitions. If no match to a
    viewName is found then the default language types are to be
    used. See the User Guide for these default types."""
    member_data_items_ = [
        MemberSpec_('transTypeDef', 'transTypeDef', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'transTypeDef', 'name': 'transTypeDef', 'type': 'transTypeDef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, transTypeDef=None):
        self.original_tagname_ = None
        if transTypeDef is None:
            self.transTypeDef = []
        else:
            self.transTypeDef = transTypeDef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transTypeDefs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transTypeDefs.subclass:
            return transTypeDefs.subclass(*args_, **kwargs_)
        else:
            return transTypeDefs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transTypeDef(self): return self.transTypeDef
    def set_transTypeDef(self, transTypeDef): self.transTypeDef = transTypeDef
    def add_transTypeDef(self, value): self.transTypeDef.append(value)
    def insert_transTypeDef_at(self, index, value): self.transTypeDef.insert(index, value)
    def replace_transTypeDef_at(self, index, value): self.transTypeDef[index] = value
    def hasContent_(self):
        if (
            self.transTypeDef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='transTypeDefs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transTypeDefs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transTypeDefs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='transTypeDefs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='transTypeDefs'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='transTypeDefs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for transTypeDef_ in self.transTypeDef:
            transTypeDef_.export(outfile, level, namespace_='ipxact:', name_='transTypeDef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'transTypeDef':
            obj_ = transTypeDef.factory()
            obj_.build(child_)
            self.transTypeDef.append(obj_)
            obj_.original_tagname_ = 'transTypeDef'
# end class transTypeDefs


class PortWire(GeneratedsSuper):
    """Wire port type for a component.True if logical ports with different
    directions from the physical port direction may be mapped onto
    this port. Forbidden for phantom ports, which always allow
    logical ports with all direction value to be mapped onto the
    physical port. Also ignored for inout ports, since any logical
    port maybe mapped to a physical inout port."""
    member_data_items_ = [
        MemberSpec_('allLogicalDirectionsAllowed', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('direction', ['componentPortDirectionType', 'xs:token'], 0, 0, {'type': 'xs:token', 'name': 'direction'}, None),
        MemberSpec_('Vectors', 'vectors', 0, 1, {'minOccurs': '0', 'type': 'vectors', 'ref': 'vectors', 'name': 'vectors'}, None),
        MemberSpec_('wireTypeDefs', 'wireTypeDefs', 0, 1, {'minOccurs': '0', 'type': 'wireTypeDefs', 'ref': 'wireTypeDefs', 'name': 'wireTypeDefs'}, None),
        MemberSpec_('drivers', 'drivers', 0, 1, {'minOccurs': '0', 'type': 'drivers', 'ref': 'drivers', 'name': 'drivers'}, None),
        MemberSpec_('constraintSets', 'constraintSets', 0, 1, {'minOccurs': '0', 'type': 'constraintSets', 'ref': 'constraintSets', 'name': 'constraintSets'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, allLogicalDirectionsAllowed=False, direction=None, Vectors=None, wireTypeDefs=None, drivers=None, constraintSets=None):
        self.original_tagname_ = None
        self.allLogicalDirectionsAllowed = _cast(bool, allLogicalDirectionsAllowed)
        self.direction = direction
        self.validate_componentPortDirectionType(self.direction)
        self.Vectors = Vectors
        self.wireTypeDefs = wireTypeDefs
        self.drivers = drivers
        self.constraintSets = constraintSets
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortWire)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortWire.subclass:
            return PortWire.subclass(*args_, **kwargs_)
        else:
            return PortWire(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_vectors(self): return self.Vectors
    def set_vectors(self, Vectors): self.Vectors = Vectors
    def get_wireTypeDefs(self): return self.wireTypeDefs
    def set_wireTypeDefs(self, wireTypeDefs): self.wireTypeDefs = wireTypeDefs
    def get_drivers(self): return self.drivers
    def set_drivers(self, drivers): self.drivers = drivers
    def get_constraintSets(self): return self.constraintSets
    def set_constraintSets(self, constraintSets): self.constraintSets = constraintSets
    def get_allLogicalDirectionsAllowed(self): return self.allLogicalDirectionsAllowed
    def set_allLogicalDirectionsAllowed(self, allLogicalDirectionsAllowed): self.allLogicalDirectionsAllowed = allLogicalDirectionsAllowed
    def validate_componentPortDirectionType(self, value):
        # Validate type componentPortDirectionType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['in', 'out', 'inout', 'phantom']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on componentPortDirectionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.direction is not None or
            self.Vectors is not None or
            self.wireTypeDefs is not None or
            self.drivers is not None or
            self.constraintSets is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='portWireType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portWireType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portWireType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='portWireType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='portWireType'):
        if self.allLogicalDirectionsAllowed and 'allLogicalDirectionsAllowed' not in already_processed:
            already_processed.add('allLogicalDirectionsAllowed')
            outfile.write(' allLogicalDirectionsAllowed="%s"' % self.gds_format_boolean(self.allLogicalDirectionsAllowed, input_name='allLogicalDirectionsAllowed'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='portWireType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:direction>%s</ipxact:direction>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), eol_))
        if self.Vectors is not None:
            self.Vectors.export(outfile, level, namespace_='ipxact:', name_='vectors', pretty_print=pretty_print)
        if self.wireTypeDefs is not None:
            self.wireTypeDefs.export(outfile, level, namespace_='ipxact:', name_='wireTypeDefs', pretty_print=pretty_print)
        if self.drivers is not None:
            self.drivers.export(outfile, level, namespace_='ipxact:', name_='drivers', pretty_print=pretty_print)
        if self.constraintSets is not None:
            self.constraintSets.export(outfile, level, namespace_='ipxact:', name_='constraintSets', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('allLogicalDirectionsAllowed', node)
        if value is not None and 'allLogicalDirectionsAllowed' not in already_processed:
            already_processed.add('allLogicalDirectionsAllowed')
            if value in ('true', '1'):
                self.allLogicalDirectionsAllowed = True
            elif value in ('false', '0'):
                self.allLogicalDirectionsAllowed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'direction':
            direction_ = child_.text
            if direction_:
                direction_ = re_.sub(String_cleanup_pat_, " ", direction_).strip()
            else:
                direction_ = ""
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
            # validate type componentPortDirectionType
            self.validate_componentPortDirectionType(self.direction)
        elif nodeName_ == 'vectors':
            obj_ = Vectors.factory()
            obj_.build(child_)
            self.Vectors = obj_
            obj_.original_tagname_ = 'vectors'
        elif nodeName_ == 'wireTypeDefs':
            obj_ = wireTypeDefs.factory()
            obj_.build(child_)
            self.wireTypeDefs = obj_
            obj_.original_tagname_ = 'wireTypeDefs'
        elif nodeName_ == 'drivers':
            obj_ = drivers.factory()
            obj_.build(child_)
            self.drivers = obj_
            obj_.original_tagname_ = 'drivers'
        elif nodeName_ == 'constraintSets':
            obj_ = constraintSets.factory()
            obj_.build(child_)
            self.constraintSets = obj_
            obj_.original_tagname_ = 'constraintSets'
# end class PortWire


class portTransactionalType(GeneratedsSuper):
    """Transactional port type.True if logical ports with different
    initiatives from the physical port initiative may be mapped onto
    this port. Forbidden for phantom ports, which always allow
    logical ports with all initiatives value to be mapped onto the
    physical port. Also ignored for "both" ports, since any logical
    port may be mapped to a physical "both" port."""
    member_data_items_ = [
        MemberSpec_('allLogicalInitiativesAllowed', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('initiative', ['initiativeType', 'xs:string'], 0, 0, {'type': 'xs:string', 'ref': 'initiative', 'name': 'initiative'}, None),
        MemberSpec_('kind', 'kind', 0, 1, {'minOccurs': '0', 'type': 'kind', 'ref': 'kind', 'name': 'kind'}, None),
        MemberSpec_('busWidth', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedIntExpression', 'ref': 'busWidth', 'name': 'busWidth'}, None),
        MemberSpec_('protocol', 'protocol', 0, 1, {'minOccurs': '0', 'type': 'protocol', 'ref': 'protocol', 'name': 'protocol'}, None),
        MemberSpec_('transTypeDefs', 'transTypeDefs', 0, 1, {'minOccurs': '0', 'type': 'transTypeDefs', 'ref': 'transTypeDefs', 'name': 'transTypeDefs'}, None),
        MemberSpec_('connection', 'connectionType', 0, 1, {'minOccurs': '0', 'type': 'connectionType', 'name': 'connection'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, allLogicalInitiativesAllowed=False, initiative=None, kind=None, busWidth=None, protocol=None, transTypeDefs=None, connection=None):
        self.original_tagname_ = None
        self.allLogicalInitiativesAllowed = _cast(bool, allLogicalInitiativesAllowed)
        self.initiative = initiative
        self.validate_initiativeType(self.initiative)
        self.kind = kind
        self.busWidth = busWidth
        self.protocol = protocol
        self.transTypeDefs = transTypeDefs
        self.connection = connection
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portTransactionalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portTransactionalType.subclass:
            return portTransactionalType.subclass(*args_, **kwargs_)
        else:
            return portTransactionalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_initiative(self): return self.initiative
    def set_initiative(self, initiative): self.initiative = initiative
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_busWidth(self): return self.busWidth
    def set_busWidth(self, busWidth): self.busWidth = busWidth
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_transTypeDefs(self): return self.transTypeDefs
    def set_transTypeDefs(self, transTypeDefs): self.transTypeDefs = transTypeDefs
    def get_connection(self): return self.connection
    def set_connection(self, connection): self.connection = connection
    def get_allLogicalInitiativesAllowed(self): return self.allLogicalInitiativesAllowed
    def set_allLogicalInitiativesAllowed(self, allLogicalInitiativesAllowed): self.allLogicalInitiativesAllowed = allLogicalInitiativesAllowed
    def validate_initiativeType(self, value):
        # Validate type initiativeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['requires', 'provides', 'both', 'phantom']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on initiativeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.initiative is not None or
            self.kind is not None or
            self.busWidth is not None or
            self.protocol is not None or
            self.transTypeDefs is not None or
            self.connection is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='portTransactionalType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portTransactionalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portTransactionalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='portTransactionalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='portTransactionalType'):
        if self.allLogicalInitiativesAllowed and 'allLogicalInitiativesAllowed' not in already_processed:
            already_processed.add('allLogicalInitiativesAllowed')
            outfile.write(' allLogicalInitiativesAllowed="%s"' % self.gds_format_boolean(self.allLogicalInitiativesAllowed, input_name='allLogicalInitiativesAllowed'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='portTransactionalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.initiative is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:initiative>%s</ipxact:initiative>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.initiative), input_name='initiative')), eol_))
        if self.kind is not None:
            self.kind.export(outfile, level, namespace_='ipxact:', name_='kind', pretty_print=pretty_print)
        if self.busWidth is not None:
            self.busWidth.export(outfile, level, namespace_='ipxact:', name_='busWidth', pretty_print=pretty_print)
        if self.protocol is not None:
            self.protocol.export(outfile, level, namespace_='ipxact:', name_='protocol', pretty_print=pretty_print)
        if self.transTypeDefs is not None:
            self.transTypeDefs.export(outfile, level, namespace_='ipxact:', name_='transTypeDefs', pretty_print=pretty_print)
        if self.connection is not None:
            self.connection.export(outfile, level, namespace_, name_='connection', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('allLogicalInitiativesAllowed', node)
        if value is not None and 'allLogicalInitiativesAllowed' not in already_processed:
            already_processed.add('allLogicalInitiativesAllowed')
            if value in ('true', '1'):
                self.allLogicalInitiativesAllowed = True
            elif value in ('false', '0'):
                self.allLogicalInitiativesAllowed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'initiative':
            initiative_ = child_.text
            initiative_ = self.gds_validate_string(initiative_, node, 'initiative')
            self.initiative = initiative_
            # validate type initiativeType
            self.validate_initiativeType(self.initiative)
        elif nodeName_ == 'kind':
            obj_ = kind.factory()
            obj_.build(child_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'busWidth':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.busWidth = obj_
            obj_.original_tagname_ = 'busWidth'
        elif nodeName_ == 'protocol':
            obj_ = protocol.factory()
            obj_.build(child_)
            self.protocol = obj_
            obj_.original_tagname_ = 'protocol'
        elif nodeName_ == 'transTypeDefs':
            obj_ = transTypeDefs.factory()
            obj_.build(child_)
            self.transTypeDefs = obj_
            obj_.original_tagname_ = 'transTypeDefs'
        elif nodeName_ == 'connection':
            obj_ = connectionType.factory()
            obj_.build(child_)
            self.connection = obj_
            obj_.original_tagname_ = 'connection'
# end class portTransactionalType


class abstractorPortWireType(GeneratedsSuper):
    """Wire port type for an abstractor."""
    member_data_items_ = [
        MemberSpec_('direction', ['componentPortDirectionType', 'xs:token'], 0, 0, {'type': 'xs:token', 'name': 'direction'}, None),
        MemberSpec_('Vectors', 'vectors', 0, 1, {'minOccurs': '0', 'type': 'vectors', 'ref': 'vectors', 'name': 'vectors'}, None),
        MemberSpec_('wireTypeDefs', 'wireTypeDefs', 0, 1, {'minOccurs': '0', 'type': 'wireTypeDefs', 'ref': 'wireTypeDefs', 'name': 'wireTypeDefs'}, None),
        MemberSpec_('drivers', 'drivers', 0, 1, {'minOccurs': '0', 'type': 'drivers', 'ref': 'drivers', 'name': 'drivers'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, direction=None, Vectors=None, wireTypeDefs=None, drivers=None):
        self.original_tagname_ = None
        self.direction = direction
        self.validate_componentPortDirectionType(self.direction)
        self.Vectors = Vectors
        self.wireTypeDefs = wireTypeDefs
        self.drivers = drivers
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorPortWireType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorPortWireType.subclass:
            return abstractorPortWireType.subclass(*args_, **kwargs_)
        else:
            return abstractorPortWireType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_vectors(self): return self.Vectors
    def set_vectors(self, Vectors): self.Vectors = Vectors
    def get_wireTypeDefs(self): return self.wireTypeDefs
    def set_wireTypeDefs(self, wireTypeDefs): self.wireTypeDefs = wireTypeDefs
    def get_drivers(self): return self.drivers
    def set_drivers(self, drivers): self.drivers = drivers
    def validate_componentPortDirectionType(self, value):
        # Validate type componentPortDirectionType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['in', 'out', 'inout', 'phantom']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on componentPortDirectionType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.direction is not None or
            self.Vectors is not None or
            self.wireTypeDefs is not None or
            self.drivers is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractorPortWireType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorPortWireType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractorPortWireType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractorPortWireType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractorPortWireType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractorPortWireType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:direction>%s</ipxact:direction>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), eol_))
        if self.Vectors is not None:
            self.Vectors.export(outfile, level, namespace_='ipxact:', name_='vectors', pretty_print=pretty_print)
        if self.wireTypeDefs is not None:
            self.wireTypeDefs.export(outfile, level, namespace_='ipxact:', name_='wireTypeDefs', pretty_print=pretty_print)
        if self.drivers is not None:
            self.drivers.export(outfile, level, namespace_='ipxact:', name_='drivers', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'direction':
            direction_ = child_.text
            if direction_:
                direction_ = re_.sub(String_cleanup_pat_, " ", direction_).strip()
            else:
                direction_ = ""
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
            # validate type componentPortDirectionType
            self.validate_componentPortDirectionType(self.direction)
        elif nodeName_ == 'vectors':
            obj_ = Vectors.factory()
            obj_.build(child_)
            self.Vectors = obj_
            obj_.original_tagname_ = 'vectors'
        elif nodeName_ == 'wireTypeDefs':
            obj_ = wireTypeDefs.factory()
            obj_.build(child_)
            self.wireTypeDefs = obj_
            obj_.original_tagname_ = 'wireTypeDefs'
        elif nodeName_ == 'drivers':
            obj_ = drivers.factory()
            obj_.build(child_)
            self.drivers = obj_
            obj_.original_tagname_ = 'drivers'
# end class abstractorPortWireType


class portAccessType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('portAccessType', 'portAccessType', 0, 1, {'minOccurs': '0', 'type': 'portAccessType', 'ref': 'portAccessType', 'name': 'portAccessType'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType', 'name': 'accessHandles'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, portAccessType_member=None, accessHandles=None):
        self.original_tagname_ = None
        self.portAccessType = portAccessType_member
        self.accessHandles = accessHandles
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portAccessType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portAccessType.subclass:
            return portAccessType.subclass(*args_, **kwargs_)
        else:
            return portAccessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_portAccessType(self): return self.portAccessType
    def set_portAccessType(self, portAccessType): self.portAccessType = portAccessType
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def hasContent_(self):
        if (
            self.portAccessType is not None or
            self.accessHandles is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='portAccessType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portAccessType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portAccessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='portAccessType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='portAccessType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='portAccessType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.portAccessType is not None:
            self.portAccessType.export(outfile, level, namespace_='ipxact:', name_='portAccessType', pretty_print=pretty_print)
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'portAccessType':
            obj_ = portAccessType.factory()
            obj_.build(child_)
            self.portAccessType = obj_
            obj_.original_tagname_ = 'portAccessType'
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
# end class portAccessType


class otherClocks(GeneratedsSuper):
    """List of clocks associated with the component that are not associated
    with ports. Set the clockSource attribute on the clockDriver to
    indicate the source of a clock not associated with a particular
    component port."""
    member_data_items_ = [
        MemberSpec_('otherClockDriver', 'otherClockDriver', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'otherClockDriver', 'name': 'otherClockDriver', 'type': 'otherClockDriver'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, otherClockDriver=None):
        self.original_tagname_ = None
        if otherClockDriver is None:
            self.otherClockDriver = []
        else:
            self.otherClockDriver = otherClockDriver
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, otherClocks)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if otherClocks.subclass:
            return otherClocks.subclass(*args_, **kwargs_)
        else:
            return otherClocks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_otherClockDriver(self): return self.otherClockDriver
    def set_otherClockDriver(self, otherClockDriver): self.otherClockDriver = otherClockDriver
    def add_otherClockDriver(self, value): self.otherClockDriver.append(value)
    def insert_otherClockDriver_at(self, index, value): self.otherClockDriver.insert(index, value)
    def replace_otherClockDriver_at(self, index, value): self.otherClockDriver[index] = value
    def hasContent_(self):
        if (
            self.otherClockDriver
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='otherClocks', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('otherClocks')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='otherClocks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='otherClocks', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='otherClocks'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='otherClocks', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for otherClockDriver_ in self.otherClockDriver:
            otherClockDriver_.export(outfile, level, namespace_='ipxact:', name_='otherClockDriver', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'otherClockDriver':
            obj_ = otherClockDriver.factory()
            obj_.build(child_)
            self.otherClockDriver.append(obj_)
            obj_.original_tagname_ = 'otherClockDriver'
# end class otherClocks


class cellSpecification(GeneratedsSuper):
    """Used to provide a generic description of a technology library
    cell.Indicates the desired strength of the specified cell."""
    member_data_items_ = [
        MemberSpec_('cellStrength', 'ipxact:cellStrengthValueType', 0, 1, {'use': 'optional'}),
        MemberSpec_('cellFunction', 'cellFunctionType', 0, 0, {'type': 'cellFunctionType', 'name': 'cellFunction'}, 8),
        MemberSpec_('cellClass', ['cellClassValueType', 'xs:token'], 0, 0, {'type': 'xs:token', 'name': 'cellClass'}, 8),
    ]
    subclass = None
    superclass = None
    def __init__(self, cellStrength=None, cellFunction=None, cellClass=None):
        self.original_tagname_ = None
        self.cellStrength = _cast(None, cellStrength)
        self.cellFunction = cellFunction
        self.cellClass = cellClass
        self.validate_cellClassValueType(self.cellClass)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cellSpecification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cellSpecification.subclass:
            return cellSpecification.subclass(*args_, **kwargs_)
        else:
            return cellSpecification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cellFunction(self): return self.cellFunction
    def set_cellFunction(self, cellFunction): self.cellFunction = cellFunction
    def get_cellClass(self): return self.cellClass
    def set_cellClass(self, cellClass): self.cellClass = cellClass
    def get_cellStrength(self): return self.cellStrength
    def set_cellStrength(self, cellStrength): self.cellStrength = cellStrength
    def validate_cellClassValueType(self, value):
        # Validate type cellClassValueType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['combinational', 'sequential']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cellClassValueType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cellFunction is not None or
            self.cellClass is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='cellSpecification', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cellSpecification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cellSpecification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='cellSpecification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='cellSpecification'):
        if self.cellStrength is not None and 'cellStrength' not in already_processed:
            already_processed.add('cellStrength')
            outfile.write(' cellStrength=%s' % (quote_attrib(self.cellStrength), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='cellSpecification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cellFunction is not None:
            self.cellFunction.export(outfile, level, namespace_, name_='cellFunction', pretty_print=pretty_print)
        if self.cellClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:cellClass>%s</ipxact:cellClass>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.cellClass), input_name='cellClass')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cellStrength', node)
        if value is not None and 'cellStrength' not in already_processed:
            already_processed.add('cellStrength')
            self.cellStrength = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cellFunction':
            obj_ = cellFunctionType.factory()
            obj_.build(child_)
            self.cellFunction = obj_
            obj_.original_tagname_ = 'cellFunction'
        elif nodeName_ == 'cellClass':
            cellClass_ = child_.text
            if cellClass_:
                cellClass_ = re_.sub(String_cleanup_pat_, " ", cellClass_).strip()
            else:
                cellClass_ = ""
            cellClass_ = self.gds_validate_string(cellClass_, node, 'cellClass')
            self.cellClass = cellClass_
            # validate type cellClassValueType
            self.validate_cellClassValueType(self.cellClass)
# end class cellSpecification


class timingConstraint(GeneratedsSuper):
    """Defines a timing constraint for the associated port. The constraint
    is relative to the clock specified by the clockName attribute.
    The clockEdge indicates which clock edge the constraint is
    associated with (default is rising edge). The delayType
    attribute can be specified to further refine the
    constraint.Indicates the clock edge that a timing constraint is
    relative to.Indicates the type of delay in a timing constraint -
    minimum or maximum.Indicates the name of the clock to which this
    constraint applies."""
    member_data_items_ = [
        MemberSpec_('clockEdge', 'ipxact:edgeValueType', 0, 1, {'use': 'optional'}),
        MemberSpec_('delayType', 'ipxact:delayValueType', 0, 1, {'use': 'optional'}),
        MemberSpec_('clockName', 'ipxact:portName', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['delayPercentageType', 'xs:float'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, clockEdge=None, delayType=None, clockName=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.clockEdge = _cast(None, clockEdge)
        self.delayType = _cast(None, delayType)
        self.clockName = _cast(None, clockName)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, timingConstraint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if timingConstraint.subclass:
            return timingConstraint.subclass(*args_, **kwargs_)
        else:
            return timingConstraint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clockEdge(self): return self.clockEdge
    def set_clockEdge(self, clockEdge): self.clockEdge = clockEdge
    def get_delayType(self): return self.delayType
    def set_delayType(self, delayType): self.delayType = delayType
    def get_clockName(self): return self.clockName
    def set_clockName(self, clockName): self.clockName = clockName
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='timingConstraint', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('timingConstraint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='timingConstraint')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='timingConstraint', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='timingConstraint'):
        if self.clockEdge is not None and 'clockEdge' not in already_processed:
            already_processed.add('clockEdge')
            outfile.write(' clockEdge=%s' % (quote_attrib(self.clockEdge), ))
        if self.delayType is not None and 'delayType' not in already_processed:
            already_processed.add('delayType')
            outfile.write(' delayType=%s' % (quote_attrib(self.delayType), ))
        if self.clockName is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            outfile.write(' clockName=%s' % (quote_attrib(self.clockName), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='timingConstraint', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clockEdge', node)
        if value is not None and 'clockEdge' not in already_processed:
            already_processed.add('clockEdge')
            self.clockEdge = value
        value = find_attr_value_('delayType', node)
        if value is not None and 'delayType' not in already_processed:
            already_processed.add('delayType')
            self.delayType = value
        value = find_attr_value_('clockName', node)
        if value is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            self.clockName = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class timingConstraint


class driveConstraint(GeneratedsSuper):
    """Defines a constraint indicating how an input is to be driven. The
    preferred methodology is to specify a library cell in technology
    independent fashion. The implemention tool should assume that
    the associated port is driven by the specified cell, or that the
    drive strength of the input port is indicated by the specified
    resistance value."""
    member_data_items_ = [
        MemberSpec_('cellSpecification', 'cellSpecification', 0, 0, {'type': 'cellSpecification', 'ref': 'cellSpecification', 'name': 'cellSpecification'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cellSpecification=None):
        self.original_tagname_ = None
        self.cellSpecification = cellSpecification
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, driveConstraint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if driveConstraint.subclass:
            return driveConstraint.subclass(*args_, **kwargs_)
        else:
            return driveConstraint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cellSpecification(self): return self.cellSpecification
    def set_cellSpecification(self, cellSpecification): self.cellSpecification = cellSpecification
    def hasContent_(self):
        if (
            self.cellSpecification is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='driveConstraint', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('driveConstraint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='driveConstraint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='driveConstraint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='driveConstraint'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='driveConstraint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cellSpecification is not None:
            self.cellSpecification.export(outfile, level, namespace_='ipxact:', name_='cellSpecification', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cellSpecification':
            obj_ = cellSpecification.factory()
            obj_.build(child_)
            self.cellSpecification = obj_
            obj_.original_tagname_ = 'cellSpecification'
# end class driveConstraint


class loadConstraint(GeneratedsSuper):
    """Defines a constraint indicating the type of load on an output port."""
    member_data_items_ = [
        MemberSpec_('cellSpecification', 'cellSpecification', 0, 0, {'type': 'cellSpecification', 'ref': 'cellSpecification', 'name': 'cellSpecification'}, None),
        MemberSpec_('count', 'unsignedPositiveIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedPositiveIntExpression', 'default': '3', 'name': 'count'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cellSpecification=None, count=None):
        self.original_tagname_ = None
        self.cellSpecification = cellSpecification
        if count is None:
            self.count = globals()['unsignedPositiveIntExpression']('3')
        else:
            self.count = count
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, loadConstraint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if loadConstraint.subclass:
            return loadConstraint.subclass(*args_, **kwargs_)
        else:
            return loadConstraint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cellSpecification(self): return self.cellSpecification
    def set_cellSpecification(self, cellSpecification): self.cellSpecification = cellSpecification
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.cellSpecification is not None or
            self.count != 3
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='loadConstraint', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('loadConstraint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='loadConstraint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='loadConstraint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='loadConstraint'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='loadConstraint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cellSpecification is not None:
            self.cellSpecification.export(outfile, level, namespace_='ipxact:', name_='cellSpecification', pretty_print=pretty_print)
        if self.count is not None:
            self.count.export(outfile, level, namespace_, name_='count', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cellSpecification':
            obj_ = cellSpecification.factory()
            obj_.build(child_)
            self.cellSpecification = obj_
            obj_.original_tagname_ = 'cellSpecification'
        elif nodeName_ == 'count':
            obj_ = unsignedPositiveIntExpression.factory()
            obj_.build(child_)
            self.count = obj_
            obj_.original_tagname_ = 'count'
# end class loadConstraint


class constraintSet(GeneratedsSuper):
    """Defines constraints that apply to a component port. If multiple
    constraintSet elements are used, each must have a unique value
    for the constraintSetId attribute.Indicates a name for this set
    of constraints. Constraints are tied to a view using this name
    in the constraintSetRef element."""
    member_data_items_ = [
        MemberSpec_('constraintSetId', 'xs:NMTOKEN', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('Vector', 'vectorType', 0, 1, {'minOccurs': '0', 'type': 'vectorType', 'name': 'vector'}, None),
        MemberSpec_('driveConstraint', 'driveConstraint', 0, 1, {'minOccurs': '0', 'type': 'driveConstraint', 'ref': 'driveConstraint', 'name': 'driveConstraint'}, None),
        MemberSpec_('loadConstraint', 'loadConstraint', 0, 1, {'minOccurs': '0', 'type': 'loadConstraint', 'ref': 'loadConstraint', 'name': 'loadConstraint'}, None),
        MemberSpec_('timingConstraint', 'timingConstraint', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'timingConstraint', 'name': 'timingConstraint', 'type': 'timingConstraint'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, constraintSetId='default', id=None, name=None, displayName=None, description=None, Vector=None, driveConstraint=None, loadConstraint=None, timingConstraint=None):
        self.original_tagname_ = None
        self.constraintSetId = _cast(None, constraintSetId)
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.Vector = Vector
        self.driveConstraint = driveConstraint
        self.loadConstraint = loadConstraint
        if timingConstraint is None:
            self.timingConstraint = []
        else:
            self.timingConstraint = timingConstraint
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, constraintSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if constraintSet.subclass:
            return constraintSet.subclass(*args_, **kwargs_)
        else:
            return constraintSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_vector(self): return self.Vector
    def set_vector(self, Vector): self.Vector = Vector
    def get_driveConstraint(self): return self.driveConstraint
    def set_driveConstraint(self, driveConstraint): self.driveConstraint = driveConstraint
    def get_loadConstraint(self): return self.loadConstraint
    def set_loadConstraint(self, loadConstraint): self.loadConstraint = loadConstraint
    def get_timingConstraint(self): return self.timingConstraint
    def set_timingConstraint(self, timingConstraint): self.timingConstraint = timingConstraint
    def add_timingConstraint(self, value): self.timingConstraint.append(value)
    def insert_timingConstraint_at(self, index, value): self.timingConstraint.insert(index, value)
    def replace_timingConstraint_at(self, index, value): self.timingConstraint[index] = value
    def get_constraintSetId(self): return self.constraintSetId
    def set_constraintSetId(self, constraintSetId): self.constraintSetId = constraintSetId
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.Vector is not None or
            self.driveConstraint is not None or
            self.loadConstraint is not None or
            self.timingConstraint
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='constraintSet', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('constraintSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='constraintSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='constraintSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='constraintSet'):
        if self.constraintSetId != "default" and 'constraintSetId' not in already_processed:
            already_processed.add('constraintSetId')
            outfile.write(' constraintSetId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.constraintSetId), input_name='constraintSetId')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='constraintSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.Vector is not None:
            self.Vector.export(outfile, level, namespace_, name_='vector', pretty_print=pretty_print)
        if self.driveConstraint is not None:
            self.driveConstraint.export(outfile, level, namespace_='ipxact:', name_='driveConstraint', pretty_print=pretty_print)
        if self.loadConstraint is not None:
            self.loadConstraint.export(outfile, level, namespace_='ipxact:', name_='loadConstraint', pretty_print=pretty_print)
        for timingConstraint_ in self.timingConstraint:
            timingConstraint_.export(outfile, level, namespace_='ipxact:', name_='timingConstraint', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('constraintSetId', node)
        if value is not None and 'constraintSetId' not in already_processed:
            already_processed.add('constraintSetId')
            self.constraintSetId = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'vector':
            obj_ = vectorType.factory()
            obj_.build(child_)
            self.Vector = obj_
            obj_.original_tagname_ = 'vector'
        elif nodeName_ == 'driveConstraint':
            obj_ = driveConstraint.factory()
            obj_.build(child_)
            self.driveConstraint = obj_
            obj_.original_tagname_ = 'driveConstraint'
        elif nodeName_ == 'loadConstraint':
            obj_ = loadConstraint.factory()
            obj_.build(child_)
            self.loadConstraint = obj_
            obj_.original_tagname_ = 'loadConstraint'
        elif nodeName_ == 'timingConstraint':
            obj_ = timingConstraint.factory()
            obj_.build(child_)
            self.timingConstraint.append(obj_)
            obj_.original_tagname_ = 'timingConstraint'
# end class constraintSet


class constraintSets(GeneratedsSuper):
    """List of constraintSet elements for a component port."""
    member_data_items_ = [
        MemberSpec_('constraintSet', 'constraintSet', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'constraintSet', 'name': 'constraintSet', 'type': 'constraintSet'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, constraintSet=None):
        self.original_tagname_ = None
        if constraintSet is None:
            self.constraintSet = []
        else:
            self.constraintSet = constraintSet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, constraintSets)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if constraintSets.subclass:
            return constraintSets.subclass(*args_, **kwargs_)
        else:
            return constraintSets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constraintSet(self): return self.constraintSet
    def set_constraintSet(self, constraintSet): self.constraintSet = constraintSet
    def add_constraintSet(self, value): self.constraintSet.append(value)
    def insert_constraintSet_at(self, index, value): self.constraintSet.insert(index, value)
    def replace_constraintSet_at(self, index, value): self.constraintSet[index] = value
    def hasContent_(self):
        if (
            self.constraintSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='constraintSets', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('constraintSets')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='constraintSets')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='constraintSets', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='constraintSets'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='constraintSets', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for constraintSet_ in self.constraintSet:
            constraintSet_.export(outfile, level, namespace_='ipxact:', name_='constraintSet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'constraintSet':
            obj_ = constraintSet.factory()
            obj_.build(child_)
            self.constraintSet.append(obj_)
            obj_.original_tagname_ = 'constraintSet'
# end class constraintSets


class constraintSetRef(GeneratedsSuper):
    """A reference to a set of port constraints."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('localName', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'localName'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, localName=None, isPresent=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.localName = localName
        self.isPresent = isPresent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, constraintSetRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if constraintSetRef.subclass:
            return constraintSetRef.subclass(*args_, **kwargs_)
        else:
            return constraintSetRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_localName(self): return self.localName
    def set_localName(self, localName): self.localName = localName
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.localName is not None or
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='constraintSetRef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('constraintSetRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='constraintSetRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='constraintSetRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='constraintSetRef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='constraintSetRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.localName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:localName>%s</ipxact:localName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.localName), input_name='localName')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'localName':
            localName_ = child_.text
            localName_ = self.gds_validate_string(localName_, node, 'localName')
            self.localName = localName_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class constraintSetRef


class abstractionDefPortConstraintsType(GeneratedsSuper):
    """Defines constraints that apply to a wire type port in an abstraction
    definition."""
    member_data_items_ = [
        MemberSpec_('timingConstraint', 'timingConstraint', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'timingConstraint', 'name': 'timingConstraint', 'type': 'timingConstraint'}, 9),
        MemberSpec_('driveConstraint', 'driveConstraint', 0, 0, {'type': 'driveConstraint', 'ref': 'driveConstraint', 'name': 'driveConstraint'}, 9),
        MemberSpec_('loadConstraint', 'loadConstraint', 0, 1, {'minOccurs': '0', 'type': 'loadConstraint', 'ref': 'loadConstraint', 'name': 'loadConstraint'}, 9),
        MemberSpec_('loadConstraint', 'loadConstraint', 0, 0, {'type': 'loadConstraint', 'ref': 'loadConstraint', 'name': 'loadConstraint'}, 9),
    ]
    subclass = None
    superclass = None
    def __init__(self, timingConstraint=None, driveConstraint=None, loadConstraint=None):
        self.original_tagname_ = None
        if timingConstraint is None:
            self.timingConstraint = []
        else:
            self.timingConstraint = timingConstraint
        self.driveConstraint = driveConstraint
        self.loadConstraint = loadConstraint
        self.loadConstraint = loadConstraint
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractionDefPortConstraintsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractionDefPortConstraintsType.subclass:
            return abstractionDefPortConstraintsType.subclass(*args_, **kwargs_)
        else:
            return abstractionDefPortConstraintsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timingConstraint(self): return self.timingConstraint
    def set_timingConstraint(self, timingConstraint): self.timingConstraint = timingConstraint
    def add_timingConstraint(self, value): self.timingConstraint.append(value)
    def insert_timingConstraint_at(self, index, value): self.timingConstraint.insert(index, value)
    def replace_timingConstraint_at(self, index, value): self.timingConstraint[index] = value
    def get_driveConstraint(self): return self.driveConstraint
    def set_driveConstraint(self, driveConstraint): self.driveConstraint = driveConstraint
    def get_loadConstraint(self): return self.loadConstraint
    def set_loadConstraint(self, loadConstraint): self.loadConstraint = loadConstraint
    def get_loadConstraint(self): return self.loadConstraint
    def set_loadConstraint(self, loadConstraint): self.loadConstraint = loadConstraint
    def hasContent_(self):
        if (
            self.timingConstraint or
            self.driveConstraint is not None or
            self.loadConstraint is not None or
            self.loadConstraint is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractionDefPortConstraintsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractionDefPortConstraintsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractionDefPortConstraintsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractionDefPortConstraintsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractionDefPortConstraintsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractionDefPortConstraintsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for timingConstraint_ in self.timingConstraint:
            timingConstraint_.export(outfile, level, namespace_='ipxact:', name_='timingConstraint', pretty_print=pretty_print)
        if self.driveConstraint is not None:
            self.driveConstraint.export(outfile, level, namespace_='ipxact:', name_='driveConstraint', pretty_print=pretty_print)
        if self.loadConstraint is not None:
            self.loadConstraint.export(outfile, level, namespace_='ipxact:', name_='loadConstraint', pretty_print=pretty_print)
        if self.loadConstraint is not None:
            self.loadConstraint.export(outfile, level, namespace_='ipxact:', name_='loadConstraint', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'timingConstraint':
            obj_ = timingConstraint.factory()
            obj_.build(child_)
            self.timingConstraint.append(obj_)
            obj_.original_tagname_ = 'timingConstraint'
        elif nodeName_ == 'driveConstraint':
            obj_ = driveConstraint.factory()
            obj_.build(child_)
            self.driveConstraint = obj_
            obj_.original_tagname_ = 'driveConstraint'
        elif nodeName_ == 'loadConstraint':
            obj_ = loadConstraint.factory()
            obj_.build(child_)
            self.loadConstraint = obj_
            obj_.original_tagname_ = 'loadConstraint'
        elif nodeName_ == 'loadConstraint':
            obj_ = loadConstraint.factory()
            obj_.build(child_)
            self.loadConstraint = obj_
            obj_.original_tagname_ = 'loadConstraint'
# end class abstractionDefPortConstraintsType


class singleShotDriver(GeneratedsSuper):
    """Describes a driven one-shot port."""
    member_data_items_ = [
        MemberSpec_('singleShotOffset', 'realExpression', 0, 0, {'type': 'realExpression', 'name': 'singleShotOffset'}, None),
        MemberSpec_('singleShotValue', 'unsignedBitVectorExpression', 0, 0, {'type': 'unsignedBitVectorExpression', 'name': 'singleShotValue'}, None),
        MemberSpec_('singleShotDuration', 'realExpression', 0, 0, {'type': 'realExpression', 'name': 'singleShotDuration'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, singleShotOffset=None, singleShotValue=None, singleShotDuration=None):
        self.original_tagname_ = None
        self.singleShotOffset = singleShotOffset
        self.singleShotValue = singleShotValue
        self.singleShotDuration = singleShotDuration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, singleShotDriver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if singleShotDriver.subclass:
            return singleShotDriver.subclass(*args_, **kwargs_)
        else:
            return singleShotDriver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_singleShotOffset(self): return self.singleShotOffset
    def set_singleShotOffset(self, singleShotOffset): self.singleShotOffset = singleShotOffset
    def get_singleShotValue(self): return self.singleShotValue
    def set_singleShotValue(self, singleShotValue): self.singleShotValue = singleShotValue
    def get_singleShotDuration(self): return self.singleShotDuration
    def set_singleShotDuration(self, singleShotDuration): self.singleShotDuration = singleShotDuration
    def hasContent_(self):
        if (
            self.singleShotOffset is not None or
            self.singleShotValue is not None or
            self.singleShotDuration is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='singleShotDriver', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('singleShotDriver')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='singleShotDriver')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='singleShotDriver', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='singleShotDriver'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='singleShotDriver', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.singleShotOffset is not None:
            self.singleShotOffset.export(outfile, level, namespace_, name_='singleShotOffset', pretty_print=pretty_print)
        if self.singleShotValue is not None:
            self.singleShotValue.export(outfile, level, namespace_, name_='singleShotValue', pretty_print=pretty_print)
        if self.singleShotDuration is not None:
            self.singleShotDuration.export(outfile, level, namespace_, name_='singleShotDuration', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'singleShotOffset':
            class_obj_ = self.get_class_obj_(child_, realExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.singleShotOffset = obj_
            obj_.original_tagname_ = 'singleShotOffset'
        elif nodeName_ == 'singleShotValue':
            obj_ = unsignedBitVectorExpression.factory()
            obj_.build(child_)
            self.singleShotValue = obj_
            obj_.original_tagname_ = 'singleShotValue'
        elif nodeName_ == 'singleShotDuration':
            class_obj_ = self.get_class_obj_(child_, realExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.singleShotDuration = obj_
            obj_.original_tagname_ = 'singleShotDuration'
# end class singleShotDriver


class requiresDriver(GeneratedsSuper):
    """Specifies if a port requires a driver. Default is false. The
    attribute driverType can further qualify what type of driver is
    required. Undefined behaviour if direction is not input or
    inout. Driver type any indicates that any unspecified type of
    driver must be connectedDefines the type of driver that is
    required. The default is any type of driver. The 2 other options
    are a clock type driver or a singleshot type driver."""
    member_data_items_ = [
        MemberSpec_('driverType', 'xs:token', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:boolean', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, driverType='any', valueOf_=None):
        self.original_tagname_ = None
        self.driverType = _cast(None, driverType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, requiresDriver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if requiresDriver.subclass:
            return requiresDriver.subclass(*args_, **kwargs_)
        else:
            return requiresDriver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_driverType(self): return self.driverType
    def set_driverType(self, driverType): self.driverType = driverType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='requiresDriver', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('requiresDriver')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='requiresDriver')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='requiresDriver', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='requiresDriver'):
        if self.driverType != "any" and 'driverType' not in already_processed:
            already_processed.add('driverType')
            outfile.write(' driverType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.driverType), input_name='driverType')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='requiresDriver', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('driverType', node)
        if value is not None and 'driverType' not in already_processed:
            already_processed.add('driverType')
            self.driverType = value
            self.driverType = ' '.join(self.driverType.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class requiresDriver


class driverType(GeneratedsSuper):
    """Wire port driver type."""
    member_data_items_ = [
        MemberSpec_('Range', 'range', 0, 1, {'minOccurs': '0', 'type': 'range', 'ref': 'range', 'name': 'range'}, None),
        MemberSpec_('defaultValue', 'unsignedBitVectorExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitVectorExpression', 'ref': 'defaultValue', 'name': 'defaultValue'}, 10),
        MemberSpec_('clockDriver', 'clockDriver', 0, 1, {'minOccurs': '0', 'type': 'clockDriver', 'ref': 'clockDriver', 'name': 'clockDriver'}, 10),
        MemberSpec_('singleShotDriver', 'singleShotDriver', 0, 1, {'minOccurs': '0', 'type': 'singleShotDriver', 'ref': 'singleShotDriver', 'name': 'singleShotDriver'}, 10),
    ]
    subclass = None
    superclass = None
    def __init__(self, Range=None, defaultValue=None, clockDriver=None, singleShotDriver=None):
        self.original_tagname_ = None
        self.Range = Range
        self.defaultValue = defaultValue
        self.clockDriver = clockDriver
        self.singleShotDriver = singleShotDriver
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, driverType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if driverType.subclass:
            return driverType.subclass(*args_, **kwargs_)
        else:
            return driverType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_range(self): return self.Range
    def set_range(self, Range): self.Range = Range
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def get_clockDriver(self): return self.clockDriver
    def set_clockDriver(self, clockDriver): self.clockDriver = clockDriver
    def get_singleShotDriver(self): return self.singleShotDriver
    def set_singleShotDriver(self, singleShotDriver): self.singleShotDriver = singleShotDriver
    def hasContent_(self):
        if (
            self.Range is not None or
            self.defaultValue is not None or
            self.clockDriver is not None or
            self.singleShotDriver is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='driverType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('driverType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='driverType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='driverType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='driverType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='driverType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Range is not None:
            self.Range.export(outfile, level, namespace_='ipxact:', name_='range', pretty_print=pretty_print)
        if self.defaultValue is not None:
            self.defaultValue.export(outfile, level, namespace_='ipxact:', name_='defaultValue', pretty_print=pretty_print)
        if self.clockDriver is not None:
            self.clockDriver.export(outfile, level, namespace_='ipxact:', name_='clockDriver', pretty_print=pretty_print)
        if self.singleShotDriver is not None:
            self.singleShotDriver.export(outfile, level, namespace_='ipxact:', name_='singleShotDriver', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'range':
            obj_ = Range.factory()
            obj_.build(child_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
        elif nodeName_ == 'defaultValue':
            obj_ = unsignedBitVectorExpression.factory()
            obj_.build(child_)
            self.defaultValue = obj_
            obj_.original_tagname_ = 'defaultValue'
        elif nodeName_ == 'clockDriver':
            obj_ = clockDriver.factory()
            obj_.build(child_)
            self.clockDriver = obj_
            obj_.original_tagname_ = 'clockDriver'
        elif nodeName_ == 'singleShotDriver':
            obj_ = singleShotDriver.factory()
            obj_.build(child_)
            self.singleShotDriver = obj_
            obj_.original_tagname_ = 'singleShotDriver'
# end class driverType


class drivers(GeneratedsSuper):
    """Container for wire port driver elements."""
    member_data_items_ = [
        MemberSpec_('driver', 'driverType', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'driver', 'name': 'driver', 'type': 'driver'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, driver=None):
        self.original_tagname_ = None
        if driver is None:
            self.driver = []
        else:
            self.driver = driver
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, drivers)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if drivers.subclass:
            return drivers.subclass(*args_, **kwargs_)
        else:
            return drivers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_driver(self): return self.driver
    def set_driver(self, driver): self.driver = driver
    def add_driver(self, value): self.driver.append(value)
    def insert_driver_at(self, index, value): self.driver.insert(index, value)
    def replace_driver_at(self, index, value): self.driver[index] = value
    def hasContent_(self):
        if (
            self.driver
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='drivers', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('drivers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='drivers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='drivers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='drivers'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='drivers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for driver_ in self.driver:
            driver_.export(outfile, level, namespace_='ipxact:', name_='driver', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'driver':
            obj_ = driverType.factory()
            obj_.build(child_)
            self.driver.append(obj_)
            obj_.original_tagname_ = 'driver'
# end class drivers


class clockDriverType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('clockPeriod', 'clockPeriodType', 0, 0, {'type': 'clockPeriodType', 'name': 'clockPeriod'}, None),
        MemberSpec_('clockPulseOffset', 'clockPulseOffsetType', 0, 0, {'type': 'clockPulseOffsetType', 'name': 'clockPulseOffset'}, None),
        MemberSpec_('clockPulseValue', 'unsignedBitVectorExpression', 0, 0, {'type': 'unsignedBitVectorExpression', 'name': 'clockPulseValue'}, None),
        MemberSpec_('clockPulseDuration', 'clockPulseDurationType', 0, 0, {'type': 'clockPulseDurationType', 'name': 'clockPulseDuration'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, clockPeriod=None, clockPulseOffset=None, clockPulseValue=None, clockPulseDuration=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.clockPeriod = clockPeriod
        self.clockPulseOffset = clockPulseOffset
        self.clockPulseValue = clockPulseValue
        self.clockPulseDuration = clockPulseDuration
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clockDriverType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clockDriverType.subclass:
            return clockDriverType.subclass(*args_, **kwargs_)
        else:
            return clockDriverType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clockPeriod(self): return self.clockPeriod
    def set_clockPeriod(self, clockPeriod): self.clockPeriod = clockPeriod
    def get_clockPulseOffset(self): return self.clockPulseOffset
    def set_clockPulseOffset(self, clockPulseOffset): self.clockPulseOffset = clockPulseOffset
    def get_clockPulseValue(self): return self.clockPulseValue
    def set_clockPulseValue(self, clockPulseValue): self.clockPulseValue = clockPulseValue
    def get_clockPulseDuration(self): return self.clockPulseDuration
    def set_clockPulseDuration(self, clockPulseDuration): self.clockPulseDuration = clockPulseDuration
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.clockPeriod is not None or
            self.clockPulseOffset is not None or
            self.clockPulseValue is not None or
            self.clockPulseDuration is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='clockDriverType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clockDriverType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='clockDriverType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='clockDriverType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='clockDriverType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='clockDriverType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.clockPeriod is not None:
            self.clockPeriod.export(outfile, level, namespace_, name_='clockPeriod', pretty_print=pretty_print)
        if self.clockPulseOffset is not None:
            self.clockPulseOffset.export(outfile, level, namespace_, name_='clockPulseOffset', pretty_print=pretty_print)
        if self.clockPulseValue is not None:
            self.clockPulseValue.export(outfile, level, namespace_, name_='clockPulseValue', pretty_print=pretty_print)
        if self.clockPulseDuration is not None:
            self.clockPulseDuration.export(outfile, level, namespace_, name_='clockPulseDuration', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'clockPeriod':
            obj_ = clockPeriodType.factory()
            obj_.build(child_)
            self.clockPeriod = obj_
            obj_.original_tagname_ = 'clockPeriod'
        elif nodeName_ == 'clockPulseOffset':
            obj_ = clockPulseOffsetType.factory()
            obj_.build(child_)
            self.clockPulseOffset = obj_
            obj_.original_tagname_ = 'clockPulseOffset'
        elif nodeName_ == 'clockPulseValue':
            obj_ = unsignedBitVectorExpression.factory()
            obj_.build(child_)
            self.clockPulseValue = obj_
            obj_.original_tagname_ = 'clockPulseValue'
        elif nodeName_ == 'clockPulseDuration':
            obj_ = clockPulseDurationType.factory()
            obj_.build(child_)
            self.clockPulseDuration = obj_
            obj_.original_tagname_ = 'clockPulseDuration'
# end class clockDriverType


class otherClockDriver(clockDriverType):
    """Describes a clock not directly associated with an input port. The
    clockSource attribute can be used on these clocks to indicate
    the actual clock source (e.g. an output port of a clock
    generator cell).Indicates the name of the clock.Indicates the
    name of the actual clock source (e.g. an output pin of a clock
    generator cell)."""
    member_data_items_ = [
        MemberSpec_('clockName', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('clockSource', 'xs:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = clockDriverType
    def __init__(self, id=None, clockPeriod=None, clockPulseOffset=None, clockPulseValue=None, clockPulseDuration=None, clockName=None, clockSource=None):
        self.original_tagname_ = None
        super(otherClockDriver, self).__init__(id, clockPeriod, clockPulseOffset, clockPulseValue, clockPulseDuration, )
        self.clockName = _cast(None, clockName)
        self.clockSource = _cast(None, clockSource)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, otherClockDriver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if otherClockDriver.subclass:
            return otherClockDriver.subclass(*args_, **kwargs_)
        else:
            return otherClockDriver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clockName(self): return self.clockName
    def set_clockName(self, clockName): self.clockName = clockName
    def get_clockSource(self): return self.clockSource
    def set_clockSource(self, clockSource): self.clockSource = clockSource
    def hasContent_(self):
        if (
            super(otherClockDriver, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='otherClockDriver', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('otherClockDriver')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='otherClockDriver')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='otherClockDriver', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='otherClockDriver'):
        super(otherClockDriver, self).exportAttributes(outfile, level, already_processed, namespace_, name_='otherClockDriver')
        if self.clockName is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            outfile.write(' clockName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clockName), input_name='clockName')), ))
        if self.clockSource is not None and 'clockSource' not in already_processed:
            already_processed.add('clockSource')
            outfile.write(' clockSource=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clockSource), input_name='clockSource')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='otherClockDriver', fromsubclass_=False, pretty_print=True):
        super(otherClockDriver, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clockName', node)
        if value is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            self.clockName = value
        value = find_attr_value_('clockSource', node)
        if value is not None and 'clockSource' not in already_processed:
            already_processed.add('clockSource')
            self.clockSource = value
        super(otherClockDriver, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(otherClockDriver, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class otherClockDriver


class file(GeneratedsSuper):
    """IP-XACT reference to a file or directory.Unique ID for this file,
    referenced in fileSet/function/fileRef"""
    member_data_items_ = [
        MemberSpec_('fileId', 'xs:token', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'stringURIExpression', 0, 0, {'type': 'stringURIExpression', 'name': 'name'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('fileType', 'fileType', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'fileType', 'name': 'fileType', 'type': 'fileType'}, None),
        MemberSpec_('isStructural', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'default': 'false', 'name': 'isStructural'}, None),
        MemberSpec_('isIncludeFile', 'isIncludeFileType', 0, 1, {'minOccurs': '0', 'type': 'isIncludeFileType', 'name': 'isIncludeFile'}, None),
        MemberSpec_('logicalName', 'logicalNameType', 0, 1, {'minOccurs': '0', 'type': 'logicalNameType', 'name': 'logicalName'}, None),
        MemberSpec_('exportedName', 'exportedNameType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'exportedName', 'type': 'exportedNameType'}, None),
        MemberSpec_('buildCommand', 'buildCommandType', 0, 1, {'minOccurs': '0', 'type': 'buildCommandType', 'name': 'buildCommand'}, None),
        MemberSpec_('dependency', 'dependency', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'dependency', 'name': 'dependency', 'type': 'dependency'}, None),
        MemberSpec_('define', 'nameValuePairType', 1, 1, {'minOccurs': '0', 'type': 'nameValuePairType', 'name': 'define', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('imageType', 'imageTypeType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'imageType', 'type': 'imageTypeType'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'name': 'description'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, fileId=None, id=None, name=None, isPresent=None, fileType=None, isStructural=False, isIncludeFile=None, logicalName=None, exportedName=None, buildCommand=None, dependency=None, define=None, imageType=None, description=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.fileId = _cast(None, fileId)
        self.id = _cast(None, id)
        self.name = name
        self.isPresent = isPresent
        if fileType is None:
            self.fileType = []
        else:
            self.fileType = fileType
        self.isStructural = isStructural
        self.isIncludeFile = isIncludeFile
        self.logicalName = logicalName
        if exportedName is None:
            self.exportedName = []
        else:
            self.exportedName = exportedName
        self.buildCommand = buildCommand
        if dependency is None:
            self.dependency = []
        else:
            self.dependency = dependency
        if define is None:
            self.define = []
        else:
            self.define = define
        if imageType is None:
            self.imageType = []
        else:
            self.imageType = imageType
        self.description = description
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, file)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if file.subclass:
            return file.subclass(*args_, **kwargs_)
        else:
            return file(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_fileType(self): return self.fileType
    def set_fileType(self, fileType): self.fileType = fileType
    def add_fileType(self, value): self.fileType.append(value)
    def insert_fileType_at(self, index, value): self.fileType.insert(index, value)
    def replace_fileType_at(self, index, value): self.fileType[index] = value
    def get_isStructural(self): return self.isStructural
    def set_isStructural(self, isStructural): self.isStructural = isStructural
    def get_isIncludeFile(self): return self.isIncludeFile
    def set_isIncludeFile(self, isIncludeFile): self.isIncludeFile = isIncludeFile
    def get_logicalName(self): return self.logicalName
    def set_logicalName(self, logicalName): self.logicalName = logicalName
    def get_exportedName(self): return self.exportedName
    def set_exportedName(self, exportedName): self.exportedName = exportedName
    def add_exportedName(self, value): self.exportedName.append(value)
    def insert_exportedName_at(self, index, value): self.exportedName.insert(index, value)
    def replace_exportedName_at(self, index, value): self.exportedName[index] = value
    def get_buildCommand(self): return self.buildCommand
    def set_buildCommand(self, buildCommand): self.buildCommand = buildCommand
    def get_dependency(self): return self.dependency
    def set_dependency(self, dependency): self.dependency = dependency
    def add_dependency(self, value): self.dependency.append(value)
    def insert_dependency_at(self, index, value): self.dependency.insert(index, value)
    def replace_dependency_at(self, index, value): self.dependency[index] = value
    def get_define(self): return self.define
    def set_define(self, define): self.define = define
    def add_define(self, value): self.define.append(value)
    def insert_define_at(self, index, value): self.define.insert(index, value)
    def replace_define_at(self, index, value): self.define[index] = value
    def get_imageType(self): return self.imageType
    def set_imageType(self, imageType): self.imageType = imageType
    def add_imageType(self, value): self.imageType.append(value)
    def insert_imageType_at(self, index, value): self.imageType.insert(index, value)
    def replace_imageType_at(self, index, value): self.imageType[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_fileId(self): return self.fileId
    def set_fileId(self, fileId): self.fileId = fileId
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.isPresent is not None or
            self.fileType or
            self.isStructural or
            self.isIncludeFile is not None or
            self.logicalName is not None or
            self.exportedName or
            self.buildCommand is not None or
            self.dependency or
            self.define or
            self.imageType or
            self.description is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='file', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('file')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='file')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='file', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='file'):
        if self.fileId is not None and 'fileId' not in already_processed:
            already_processed.add('fileId')
            outfile.write(' fileId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fileId), input_name='fileId')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='file', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for fileType_ in self.fileType:
            fileType_.export(outfile, level, namespace_='ipxact:', name_='fileType', pretty_print=pretty_print)
        if self.isStructural:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:isStructural>%s</ipxact:isStructural>%s' % (self.gds_format_boolean(self.isStructural, input_name='isStructural'), eol_))
        if self.isIncludeFile is not None:
            self.isIncludeFile.export(outfile, level, namespace_, name_='isIncludeFile', pretty_print=pretty_print)
        if self.logicalName is not None:
            self.logicalName.export(outfile, level, namespace_, name_='logicalName', pretty_print=pretty_print)
        for exportedName_ in self.exportedName:
            exportedName_.export(outfile, level, namespace_, name_='exportedName', pretty_print=pretty_print)
        if self.buildCommand is not None:
            self.buildCommand.export(outfile, level, namespace_, name_='buildCommand', pretty_print=pretty_print)
        for dependency_ in self.dependency:
            dependency_.export(outfile, level, namespace_='ipxact:', name_='dependency', pretty_print=pretty_print)
        for define_ in self.define:
            define_.export(outfile, level, namespace_, name_='define', pretty_print=pretty_print)
        for imageType_ in self.imageType:
            imageType_.export(outfile, level, namespace_, name_='imageType', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fileId', node)
        if value is not None and 'fileId' not in already_processed:
            already_processed.add('fileId')
            self.fileId = value
            self.fileId = ' '.join(self.fileId.split())
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = stringURIExpression.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'fileType':
            obj_ = fileType.factory()
            obj_.build(child_)
            self.fileType.append(obj_)
            obj_.original_tagname_ = 'fileType'
        elif nodeName_ == 'isStructural':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isStructural')
            self.isStructural = ival_
        elif nodeName_ == 'isIncludeFile':
            obj_ = isIncludeFileType.factory()
            obj_.build(child_)
            self.isIncludeFile = obj_
            obj_.original_tagname_ = 'isIncludeFile'
        elif nodeName_ == 'logicalName':
            obj_ = logicalNameType.factory()
            obj_.build(child_)
            self.logicalName = obj_
            obj_.original_tagname_ = 'logicalName'
        elif nodeName_ == 'exportedName':
            obj_ = exportedNameType.factory()
            obj_.build(child_)
            self.exportedName.append(obj_)
            obj_.original_tagname_ = 'exportedName'
        elif nodeName_ == 'buildCommand':
            obj_ = buildCommandType.factory()
            obj_.build(child_)
            self.buildCommand = obj_
            obj_.original_tagname_ = 'buildCommand'
        elif nodeName_ == 'dependency':
            obj_ = dependency.factory()
            obj_.build(child_)
            self.dependency.append(obj_)
            obj_.original_tagname_ = 'dependency'
        elif nodeName_ == 'define':
            class_obj_ = self.get_class_obj_(child_, nameValuePairType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.define.append(obj_)
            obj_.original_tagname_ = 'define'
        elif nodeName_ == 'imageType':
            obj_ = imageTypeType.factory()
            obj_.build(child_)
            self.imageType.append(obj_)
            obj_.original_tagname_ = 'imageType'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class file


class executableImage(GeneratedsSuper):
    """Specifies an executable software image to be loaded into a
    processors address space. The format of the image is not
    specified. It could, for example, be an ELF loadfile, or it
    could be raw binary or ascii hex data for loading directly into
    a memory model instance.Unique ID for the executableImage,
    referenced in fileSet/function/fileRefOpen element to describe
    the type of image. The contents is model and/or generator
    specific."""
    member_data_items_ = [
        MemberSpec_('imageId', 'xs:token', 0, 0, {'use': 'required'}),
        MemberSpec_('imageType', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('languageTools', 'languageToolsType', 0, 1, {'minOccurs': '0', 'type': 'languageToolsType', 'name': 'languageTools'}, None),
        MemberSpec_('fileSetRefGroup', 'fileSetRefGroupType', 0, 1, {'minOccurs': '0', 'type': 'fileSetRefGroupType', 'name': 'fileSetRefGroup'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, imageId=None, imageType=None, id=None, name=None, displayName=None, description=None, parameters=None, languageTools=None, fileSetRefGroup=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.imageId = _cast(None, imageId)
        self.imageType = _cast(None, imageType)
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.parameters = parameters
        self.languageTools = languageTools
        self.fileSetRefGroup = fileSetRefGroup
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, executableImage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if executableImage.subclass:
            return executableImage.subclass(*args_, **kwargs_)
        else:
            return executableImage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_languageTools(self): return self.languageTools
    def set_languageTools(self, languageTools): self.languageTools = languageTools
    def get_fileSetRefGroup(self): return self.fileSetRefGroup
    def set_fileSetRefGroup(self, fileSetRefGroup): self.fileSetRefGroup = fileSetRefGroup
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_imageId(self): return self.imageId
    def set_imageId(self, imageId): self.imageId = imageId
    def get_imageType(self): return self.imageType
    def set_imageType(self, imageType): self.imageType = imageType
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.parameters is not None or
            self.languageTools is not None or
            self.fileSetRefGroup is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='executableImage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('executableImage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='executableImage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='executableImage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='executableImage'):
        if self.imageId is not None and 'imageId' not in already_processed:
            already_processed.add('imageId')
            outfile.write(' imageId=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageId), input_name='imageId')), ))
        if self.imageType is not None and 'imageType' not in already_processed:
            already_processed.add('imageType')
            outfile.write(' imageType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageType), input_name='imageType')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='executableImage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.languageTools is not None:
            self.languageTools.export(outfile, level, namespace_, name_='languageTools', pretty_print=pretty_print)
        if self.fileSetRefGroup is not None:
            self.fileSetRefGroup.export(outfile, level, namespace_, name_='fileSetRefGroup', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('imageId', node)
        if value is not None and 'imageId' not in already_processed:
            already_processed.add('imageId')
            self.imageId = value
            self.imageId = ' '.join(self.imageId.split())
        value = find_attr_value_('imageType', node)
        if value is not None and 'imageType' not in already_processed:
            already_processed.add('imageType')
            self.imageType = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'languageTools':
            obj_ = languageToolsType.factory()
            obj_.build(child_)
            self.languageTools = obj_
            obj_.original_tagname_ = 'languageTools'
        elif nodeName_ == 'fileSetRefGroup':
            obj_ = fileSetRefGroupType.factory()
            obj_.build(child_)
            self.fileSetRefGroup = obj_
            obj_.original_tagname_ = 'fileSetRefGroup'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class executableImage


class linkerCommandFile(GeneratedsSuper):
    """Specifies a linker command file."""
    member_data_items_ = [
        MemberSpec_('name', 'stringURIExpression', 0, 0, {'type': 'stringURIExpression', 'name': 'name'}, None),
        MemberSpec_('commandLineSwitch', 'stringExpression', 0, 0, {'type': 'stringExpression', 'name': 'commandLineSwitch'}, None),
        MemberSpec_('enable', 'unsignedBitExpression', 0, 0, {'type': 'unsignedBitExpression', 'name': 'enable'}, None),
        MemberSpec_('generatorRef', 'generatorRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'generatorRef', 'name': 'generatorRef', 'type': 'generatorRef'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, commandLineSwitch=None, enable=None, generatorRef=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.name = name
        self.commandLineSwitch = commandLineSwitch
        self.enable = enable
        if generatorRef is None:
            self.generatorRef = []
        else:
            self.generatorRef = generatorRef
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, linkerCommandFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if linkerCommandFile.subclass:
            return linkerCommandFile.subclass(*args_, **kwargs_)
        else:
            return linkerCommandFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_commandLineSwitch(self): return self.commandLineSwitch
    def set_commandLineSwitch(self, commandLineSwitch): self.commandLineSwitch = commandLineSwitch
    def get_enable(self): return self.enable
    def set_enable(self, enable): self.enable = enable
    def get_generatorRef(self): return self.generatorRef
    def set_generatorRef(self, generatorRef): self.generatorRef = generatorRef
    def add_generatorRef(self, value): self.generatorRef.append(value)
    def insert_generatorRef_at(self, index, value): self.generatorRef.insert(index, value)
    def replace_generatorRef_at(self, index, value): self.generatorRef[index] = value
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def hasContent_(self):
        if (
            self.name is not None or
            self.commandLineSwitch is not None or
            self.enable is not None or
            self.generatorRef or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='linkerCommandFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('linkerCommandFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='linkerCommandFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='linkerCommandFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='linkerCommandFile'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='linkerCommandFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        if self.commandLineSwitch is not None:
            self.commandLineSwitch.export(outfile, level, namespace_, name_='commandLineSwitch', pretty_print=pretty_print)
        if self.enable is not None:
            self.enable.export(outfile, level, namespace_, name_='enable', pretty_print=pretty_print)
        for generatorRef_ in self.generatorRef:
            generatorRef_.export(outfile, level, namespace_='ipxact:', name_='generatorRef', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = stringURIExpression.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'commandLineSwitch':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.commandLineSwitch = obj_
            obj_.original_tagname_ = 'commandLineSwitch'
        elif nodeName_ == 'enable':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.enable = obj_
            obj_.original_tagname_ = 'enable'
        elif nodeName_ == 'generatorRef':
            obj_ = generatorRef.factory()
            obj_.build(child_)
            self.generatorRef.append(obj_)
            obj_.original_tagname_ = 'generatorRef'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class linkerCommandFile


class fileSetRef(GeneratedsSuper):
    """A reference to a fileSet."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('localName', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'localName'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, localName=None, isPresent=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.localName = localName
        self.isPresent = isPresent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSetRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSetRef.subclass:
            return fileSetRef.subclass(*args_, **kwargs_)
        else:
            return fileSetRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_localName(self): return self.localName
    def set_localName(self, localName): self.localName = localName
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.localName is not None or
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='fileSetRef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSetRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileSetRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='fileSetRef', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='fileSetRef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='fileSetRef', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.localName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:localName>%s</ipxact:localName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.localName), input_name='localName')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'localName':
            localName_ = child_.text
            localName_ = self.gds_validate_string(localName_, node, 'localName')
            self.localName = localName_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class fileSetRef


class fileSets(GeneratedsSuper):
    """List of file sets associated with component."""
    member_data_items_ = [
        MemberSpec_('fileSet', 'fileSetType', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'fileSet', 'name': 'fileSet', 'type': 'fileSetType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, fileSet=None):
        self.original_tagname_ = None
        if fileSet is None:
            self.fileSet = []
        else:
            self.fileSet = fileSet
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSets)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSets.subclass:
            return fileSets.subclass(*args_, **kwargs_)
        else:
            return fileSets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileSet(self): return self.fileSet
    def set_fileSet(self, fileSet): self.fileSet = fileSet
    def add_fileSet(self, value): self.fileSet.append(value)
    def insert_fileSet_at(self, index, value): self.fileSet.insert(index, value)
    def replace_fileSet_at(self, index, value): self.fileSet[index] = value
    def hasContent_(self):
        if (
            self.fileSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='fileSets', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSets')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileSets')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='fileSets', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='fileSets'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='fileSets', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fileSet_ in self.fileSet:
            fileSet_.export(outfile, level, namespace_='ipxact:', name_='fileSet', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileSet':
            obj_ = fileSetType.factory()
            obj_.build(child_)
            self.fileSet.append(obj_)
            obj_.original_tagname_ = 'fileSet'
# end class fileSets


class fileBuilderType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('fileType', 'fileType', 0, 0, {'type': 'fileType', 'ref': 'fileType', 'name': 'fileType'}, None),
        MemberSpec_('command', 'stringExpression', 0, 1, {'minOccurs': '0', 'type': 'stringExpression', 'name': 'command'}, None),
        MemberSpec_('flags', 'stringExpression', 0, 1, {'minOccurs': '0', 'type': 'stringExpression', 'name': 'flags'}, None),
        MemberSpec_('replaceDefaultFlags', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'name': 'replaceDefaultFlags'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, fileType=None, command=None, flags=None, replaceDefaultFlags=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.fileType = fileType
        self.command = command
        self.flags = flags
        self.replaceDefaultFlags = replaceDefaultFlags
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileBuilderType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileBuilderType.subclass:
            return fileBuilderType.subclass(*args_, **kwargs_)
        else:
            return fileBuilderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileType(self): return self.fileType
    def set_fileType(self, fileType): self.fileType = fileType
    def get_command(self): return self.command
    def set_command(self, command): self.command = command
    def get_flags(self): return self.flags
    def set_flags(self, flags): self.flags = flags
    def get_replaceDefaultFlags(self): return self.replaceDefaultFlags
    def set_replaceDefaultFlags(self, replaceDefaultFlags): self.replaceDefaultFlags = replaceDefaultFlags
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.fileType is not None or
            self.command is not None or
            self.flags is not None or
            self.replaceDefaultFlags is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='fileBuilderType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileBuilderType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileBuilderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='fileBuilderType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='fileBuilderType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='fileBuilderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fileType is not None:
            self.fileType.export(outfile, level, namespace_='ipxact:', name_='fileType', pretty_print=pretty_print)
        if self.command is not None:
            self.command.export(outfile, level, namespace_, name_='command', pretty_print=pretty_print)
        if self.flags is not None:
            self.flags.export(outfile, level, namespace_, name_='flags', pretty_print=pretty_print)
        if self.replaceDefaultFlags is not None:
            self.replaceDefaultFlags.export(outfile, level, namespace_, name_='replaceDefaultFlags', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileType':
            obj_ = fileType.factory()
            obj_.build(child_)
            self.fileType = obj_
            obj_.original_tagname_ = 'fileType'
        elif nodeName_ == 'command':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.command = obj_
            obj_.original_tagname_ = 'command'
        elif nodeName_ == 'flags':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.flags = obj_
            obj_.original_tagname_ = 'flags'
        elif nodeName_ == 'replaceDefaultFlags':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.replaceDefaultFlags = obj_
            obj_.original_tagname_ = 'replaceDefaultFlags'
# end class fileBuilderType


class fileSetType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('group', 'xs:Name', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'group', 'type': 'groupType'}, None),
        MemberSpec_('file', 'file', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'file', 'name': 'file', 'type': 'file'}, None),
        MemberSpec_('defaultFileBuilder', 'fileBuilderType', 1, 1, {'minOccurs': '0', 'type': 'fileBuilderType', 'name': 'defaultFileBuilder', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('dependency', 'dependency', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'dependency', 'name': 'dependency', 'type': 'dependency'}, None),
        MemberSpec_('function', 'functionType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'function', 'type': 'functionType'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, group=None, file=None, defaultFileBuilder=None, dependency=None, function=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        if group is None:
            self.group = []
        else:
            self.group = group
        if file is None:
            self.file = []
        else:
            self.file = file
        if defaultFileBuilder is None:
            self.defaultFileBuilder = []
        else:
            self.defaultFileBuilder = defaultFileBuilder
        if dependency is None:
            self.dependency = []
        else:
            self.dependency = dependency
        if function is None:
            self.function = []
        else:
            self.function = function
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSetType.subclass:
            return fileSetType.subclass(*args_, **kwargs_)
        else:
            return fileSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def add_group(self, value): self.group.append(value)
    def insert_group_at(self, index, value): self.group.insert(index, value)
    def replace_group_at(self, index, value): self.group[index] = value
    def get_file(self): return self.file
    def set_file(self, file): self.file = file
    def add_file(self, value): self.file.append(value)
    def insert_file_at(self, index, value): self.file.insert(index, value)
    def replace_file_at(self, index, value): self.file[index] = value
    def get_defaultFileBuilder(self): return self.defaultFileBuilder
    def set_defaultFileBuilder(self, defaultFileBuilder): self.defaultFileBuilder = defaultFileBuilder
    def add_defaultFileBuilder(self, value): self.defaultFileBuilder.append(value)
    def insert_defaultFileBuilder_at(self, index, value): self.defaultFileBuilder.insert(index, value)
    def replace_defaultFileBuilder_at(self, index, value): self.defaultFileBuilder[index] = value
    def get_dependency(self): return self.dependency
    def set_dependency(self, dependency): self.dependency = dependency
    def add_dependency(self, value): self.dependency.append(value)
    def insert_dependency_at(self, index, value): self.dependency.insert(index, value)
    def replace_dependency_at(self, index, value): self.dependency[index] = value
    def get_function(self): return self.function
    def set_function(self, function): self.function = function
    def add_function(self, value): self.function.append(value)
    def insert_function_at(self, index, value): self.function.insert(index, value)
    def replace_function_at(self, index, value): self.function[index] = value
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.group or
            self.file or
            self.defaultFileBuilder or
            self.dependency or
            self.function or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='fileSetType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='fileSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='fileSetType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='fileSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        for group_ in self.group:
            group_.export(outfile, level, namespace_, name_='group', pretty_print=pretty_print)
        for file_ in self.file:
            file_.export(outfile, level, namespace_='ipxact:', name_='file', pretty_print=pretty_print)
        for defaultFileBuilder_ in self.defaultFileBuilder:
            defaultFileBuilder_.export(outfile, level, namespace_, name_='defaultFileBuilder', pretty_print=pretty_print)
        for dependency_ in self.dependency:
            dependency_.export(outfile, level, namespace_='ipxact:', name_='dependency', pretty_print=pretty_print)
        for function_ in self.function:
            function_.export(outfile, level, namespace_, name_='function', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'group':
            obj_ = xs_Name.factory()
            obj_.build(child_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
        elif nodeName_ == 'file':
            obj_ = file.factory()
            obj_.build(child_)
            self.file.append(obj_)
            obj_.original_tagname_ = 'file'
        elif nodeName_ == 'defaultFileBuilder':
            obj_ = fileBuilderType.factory()
            obj_.build(child_)
            self.defaultFileBuilder.append(obj_)
            obj_.original_tagname_ = 'defaultFileBuilder'
        elif nodeName_ == 'dependency':
            obj_ = dependency.factory()
            obj_.build(child_)
            self.dependency.append(obj_)
            obj_.original_tagname_ = 'dependency'
        elif nodeName_ == 'function':
            obj_ = functionType.factory()
            obj_.build(child_)
            self.function.append(obj_)
            obj_.original_tagname_ = 'function'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class fileSetType


class generatorRef(GeneratedsSuper):
    """A reference to a generator element."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generatorRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generatorRef.subclass:
            return generatorRef.subclass(*args_, **kwargs_)
        else:
            return generatorRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='generatorRef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generatorRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='generatorRef')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='generatorRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='generatorRef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='generatorRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class generatorRef


class ipxactURI(GeneratedsSuper):
    """IP-XACT URI, like a standard xs:anyURI except that it can contain
    environment variables in the ${ } form, to be replaced by their
    value to provide the underlying URI"""
    member_data_items_ = [
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ipxactURI)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ipxactURI.subclass:
            return ipxactURI.subclass(*args_, **kwargs_)
        else:
            return ipxactURI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='ipxactURI', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ipxactURI')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ipxactURI')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='ipxactURI', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='ipxactURI'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='ipxactURI', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ipxactURI


class fileType(GeneratedsSuper):
    """Enumerated file types known by IP-XACT."""
    member_data_items_ = [
        MemberSpec_('user', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['simpleFileType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, user=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.user = _cast(None, user)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileType.subclass:
            return fileType.subclass(*args_, **kwargs_)
        else:
            return fileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='fileType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='fileType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='fileType'):
        if self.user is not None and 'user' not in already_processed:
            already_processed.add('user')
            outfile.write(' user=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.user), input_name='user')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='fileType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('user', node)
        if value is not None and 'user' not in already_processed:
            already_processed.add('user')
            self.user = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fileType


class generatorChain(GeneratedsSuper):
    """If this attribute is true then the generator should not be presented
    to the user, it may be part of a chain and has no useful meaning
    when invoked standalone."""
    member_data_items_ = [
        MemberSpec_('hidden', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'vendor'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'library'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'version'}, None),
        MemberSpec_('generatorChainSelector', 'generatorChainSelectorType', 1, 0, {'type': 'generatorChainSelectorType', 'name': 'generatorChainSelector'}, 11),
        MemberSpec_('componentGeneratorSelector', 'generatorSelectorType', 1, 0, {'type': 'generatorSelectorType', 'name': 'componentGeneratorSelector'}, 11),
        MemberSpec_('generator', 'generator', 1, 0, {'type': 'generator', 'ref': 'generator', 'name': 'generator'}, 11),
        MemberSpec_('chainGroup', 'chainGroupType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'chainGroup', 'type': 'chainGroupType'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('choices', 'choices', 0, 1, {'minOccurs': '0', 'type': 'choices', 'ref': 'choices', 'name': 'choices'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'type': 'assertions', 'ref': 'assertions', 'name': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, hidden=False, id=None, vendor=None, library=None, name=None, version=None, generatorChainSelector=None, componentGeneratorSelector=None, generator=None, chainGroup=None, displayName=None, description=None, choices=None, parameters=None, assertions=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.hidden = _cast(bool, hidden)
        self.id = _cast(None, id)
        self.vendor = vendor
        self.library = library
        self.name = name
        self.version = version
        if generatorChainSelector is None:
            self.generatorChainSelector = []
        else:
            self.generatorChainSelector = generatorChainSelector
        if componentGeneratorSelector is None:
            self.componentGeneratorSelector = []
        else:
            self.componentGeneratorSelector = componentGeneratorSelector
        if generator is None:
            self.generator = []
        else:
            self.generator = generator
        if chainGroup is None:
            self.chainGroup = []
        else:
            self.chainGroup = chainGroup
        self.displayName = displayName
        self.description = description
        self.choices = choices
        self.parameters = parameters
        self.assertions = assertions
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generatorChain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generatorChain.subclass:
            return generatorChain.subclass(*args_, **kwargs_)
        else:
            return generatorChain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_generatorChainSelector(self): return self.generatorChainSelector
    def set_generatorChainSelector(self, generatorChainSelector): self.generatorChainSelector = generatorChainSelector
    def add_generatorChainSelector(self, value): self.generatorChainSelector.append(value)
    def insert_generatorChainSelector_at(self, index, value): self.generatorChainSelector.insert(index, value)
    def replace_generatorChainSelector_at(self, index, value): self.generatorChainSelector[index] = value
    def get_componentGeneratorSelector(self): return self.componentGeneratorSelector
    def set_componentGeneratorSelector(self, componentGeneratorSelector): self.componentGeneratorSelector = componentGeneratorSelector
    def add_componentGeneratorSelector(self, value): self.componentGeneratorSelector.append(value)
    def insert_componentGeneratorSelector_at(self, index, value): self.componentGeneratorSelector.insert(index, value)
    def replace_componentGeneratorSelector_at(self, index, value): self.componentGeneratorSelector[index] = value
    def get_generator(self): return self.generator
    def set_generator(self, generator): self.generator = generator
    def add_generator(self, value): self.generator.append(value)
    def insert_generator_at(self, index, value): self.generator.insert(index, value)
    def replace_generator_at(self, index, value): self.generator[index] = value
    def get_chainGroup(self): return self.chainGroup
    def set_chainGroup(self, chainGroup): self.chainGroup = chainGroup
    def add_chainGroup(self, value): self.chainGroup.append(value)
    def insert_chainGroup_at(self, index, value): self.chainGroup.insert(index, value)
    def replace_chainGroup_at(self, index, value): self.chainGroup[index] = value
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_choices(self): return self.choices
    def set_choices(self, choices): self.choices = choices
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_assertions(self): return self.assertions
    def set_assertions(self, assertions): self.assertions = assertions
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_hidden(self): return self.hidden
    def set_hidden(self, hidden): self.hidden = hidden
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.generatorChainSelector or
            self.componentGeneratorSelector or
            self.generator or
            self.chainGroup or
            self.displayName is not None or
            self.description is not None or
            self.choices is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='generatorChain', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generatorChain')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='generatorChain')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='generatorChain', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='generatorChain'):
        if self.hidden and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_boolean(self.hidden, input_name='hidden'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='generatorChain', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:vendor>%s</ipxact:vendor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), eol_))
        if self.library is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:library>%s</ipxact:library>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:version>%s</ipxact:version>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), eol_))
        for generatorChainSelector_ in self.generatorChainSelector:
            generatorChainSelector_.export(outfile, level, namespace_, name_='generatorChainSelector', pretty_print=pretty_print)
        for componentGeneratorSelector_ in self.componentGeneratorSelector:
            componentGeneratorSelector_.export(outfile, level, namespace_, name_='componentGeneratorSelector', pretty_print=pretty_print)
        for generator_ in self.generator:
            generator_.export(outfile, level, namespace_='ipxact:', name_='generator', pretty_print=pretty_print)
        for chainGroup_ in self.chainGroup:
            chainGroup_.export(outfile, level, namespace_, name_='chainGroup', pretty_print=pretty_print)
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.choices is not None:
            self.choices.export(outfile, level, namespace_='ipxact:', name_='choices', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            self.assertions.export(outfile, level, namespace_='ipxact:', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            if value in ('true', '1'):
                self.hidden = True
            elif value in ('false', '0'):
                self.hidden = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'library':
            library_ = child_.text
            library_ = self.gds_validate_string(library_, node, 'library')
            self.library = library_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'generatorChainSelector':
            obj_ = generatorChainSelectorType.factory()
            obj_.build(child_)
            self.generatorChainSelector.append(obj_)
            obj_.original_tagname_ = 'generatorChainSelector'
        elif nodeName_ == 'componentGeneratorSelector':
            obj_ = generatorSelectorType.factory()
            obj_.build(child_)
            self.componentGeneratorSelector.append(obj_)
            obj_.original_tagname_ = 'componentGeneratorSelector'
        elif nodeName_ == 'generator':
            obj_ = generator.factory()
            obj_.build(child_)
            self.generator.append(obj_)
            obj_.original_tagname_ = 'generator'
        elif nodeName_ == 'chainGroup':
            obj_ = chainGroupType.factory()
            obj_.build(child_)
            self.chainGroup.append(obj_)
            obj_.original_tagname_ = 'chainGroup'
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'choices':
            obj_ = choices.factory()
            obj_.build(child_)
            self.choices = obj_
            obj_.original_tagname_ = 'choices'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory()
            obj_.build(child_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class generatorChain


class groupSelector(GeneratedsSuper):
    """Specifies a set of group names used to select subsequent generators.
    The attribute "multipleGroupOperator" specifies the OR or AND
    selection operator if there is more than one group name
    (default=OR).Specifies the OR or AND selection operator if there
    is more than one group name."""
    member_data_items_ = [
        MemberSpec_('multipleGroupSelectionOperator', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'nameType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'name', 'type': 'nameType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, multipleGroupSelectionOperator='or', id=None, name=None):
        self.original_tagname_ = None
        self.multipleGroupSelectionOperator = _cast(None, multipleGroupSelectionOperator)
        self.id = _cast(None, id)
        if name is None:
            self.name = []
        else:
            self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupSelector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupSelector.subclass:
            return groupSelector.subclass(*args_, **kwargs_)
        else:
            return groupSelector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def add_name(self, value): self.name.append(value)
    def insert_name_at(self, index, value): self.name.insert(index, value)
    def replace_name_at(self, index, value): self.name[index] = value
    def get_multipleGroupSelectionOperator(self): return self.multipleGroupSelectionOperator
    def set_multipleGroupSelectionOperator(self, multipleGroupSelectionOperator): self.multipleGroupSelectionOperator = multipleGroupSelectionOperator
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='groupSelector', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('groupSelector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='groupSelector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='groupSelector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='groupSelector'):
        if self.multipleGroupSelectionOperator != "or" and 'multipleGroupSelectionOperator' not in already_processed:
            already_processed.add('multipleGroupSelectionOperator')
            outfile.write(' multipleGroupSelectionOperator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.multipleGroupSelectionOperator), input_name='multipleGroupSelectionOperator')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='groupSelector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for name_ in self.name:
            name_.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('multipleGroupSelectionOperator', node)
        if value is not None and 'multipleGroupSelectionOperator' not in already_processed:
            already_processed.add('multipleGroupSelectionOperator')
            self.multipleGroupSelectionOperator = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = nameType.factory()
            obj_.build(child_)
            self.name.append(obj_)
            obj_.original_tagname_ = 'name'
# end class groupSelector


class generatorSelectorType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('groupSelector', 'groupSelector', 0, 0, {'type': 'groupSelector', 'ref': 'groupSelector', 'name': 'groupSelector'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, groupSelector=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.groupSelector = groupSelector
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generatorSelectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generatorSelectorType.subclass:
            return generatorSelectorType.subclass(*args_, **kwargs_)
        else:
            return generatorSelectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_groupSelector(self): return self.groupSelector
    def set_groupSelector(self, groupSelector): self.groupSelector = groupSelector
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.groupSelector is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='generatorSelectorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generatorSelectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='generatorSelectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='generatorSelectorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='generatorSelectorType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='generatorSelectorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.groupSelector is not None:
            self.groupSelector.export(outfile, level, namespace_='ipxact:', name_='groupSelector', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'groupSelector':
            obj_ = groupSelector.factory()
            obj_.build(child_)
            self.groupSelector = obj_
            obj_.original_tagname_ = 'groupSelector'
# end class generatorSelectorType


class componentGenerators(GeneratedsSuper):
    """List of component generators."""
    member_data_items_ = [
        MemberSpec_('componentGenerator', 'instanceGeneratorType', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'componentGenerator', 'name': 'componentGenerator', 'type': 'instanceGeneratorType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentGenerator=None):
        self.original_tagname_ = None
        if componentGenerator is None:
            self.componentGenerator = []
        else:
            self.componentGenerator = componentGenerator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentGenerators)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentGenerators.subclass:
            return componentGenerators.subclass(*args_, **kwargs_)
        else:
            return componentGenerators(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentGenerator(self): return self.componentGenerator
    def set_componentGenerator(self, componentGenerator): self.componentGenerator = componentGenerator
    def add_componentGenerator(self, value): self.componentGenerator.append(value)
    def insert_componentGenerator_at(self, index, value): self.componentGenerator.insert(index, value)
    def replace_componentGenerator_at(self, index, value): self.componentGenerator[index] = value
    def hasContent_(self):
        if (
            self.componentGenerator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='componentGenerators', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentGenerators')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='componentGenerators')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='componentGenerators', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='componentGenerators'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='componentGenerators', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for componentGenerator_ in self.componentGenerator:
            componentGenerator_.export(outfile, level, namespace_='ipxact:', name_='componentGenerator', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'componentGenerator':
            obj_ = instanceGeneratorType.factory()
            obj_.build(child_)
            self.componentGenerator.append(obj_)
            obj_.original_tagname_ = 'componentGenerator'
# end class componentGenerators


class abstractorGenerators(GeneratedsSuper):
    """List of abstractor generators."""
    member_data_items_ = [
        MemberSpec_('abstractorGenerator', 'instanceGeneratorType', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'abstractorGenerator', 'name': 'abstractorGenerator', 'type': 'instanceGeneratorType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, abstractorGenerator=None):
        self.original_tagname_ = None
        if abstractorGenerator is None:
            self.abstractorGenerator = []
        else:
            self.abstractorGenerator = abstractorGenerator
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorGenerators)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorGenerators.subclass:
            return abstractorGenerators.subclass(*args_, **kwargs_)
        else:
            return abstractorGenerators(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_abstractorGenerator(self): return self.abstractorGenerator
    def set_abstractorGenerator(self, abstractorGenerator): self.abstractorGenerator = abstractorGenerator
    def add_abstractorGenerator(self, value): self.abstractorGenerator.append(value)
    def insert_abstractorGenerator_at(self, index, value): self.abstractorGenerator.insert(index, value)
    def replace_abstractorGenerator_at(self, index, value): self.abstractorGenerator[index] = value
    def hasContent_(self):
        if (
            self.abstractorGenerator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractorGenerators', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorGenerators')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractorGenerators')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractorGenerators', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractorGenerators'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractorGenerators', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for abstractorGenerator_ in self.abstractorGenerator:
            abstractorGenerator_.export(outfile, level, namespace_='ipxact:', name_='abstractorGenerator', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'abstractorGenerator':
            obj_ = instanceGeneratorType.factory()
            obj_.build(child_)
            self.abstractorGenerator.append(obj_)
            obj_.original_tagname_ = 'abstractorGenerator'
# end class abstractorGenerators


class generatorType(GeneratedsSuper):
    """Types of generatorsIf this attribute is true then the generator
    should not be presented to the user, it may be part of a chain
    and has no useful meaning when invoked standalone."""
    member_data_items_ = [
        MemberSpec_('hidden', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('phase', 'realExpression', 0, 1, {'minOccurs': '0', 'type': 'realExpression', 'ref': 'phase', 'name': 'phase'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('apiType', 'apiTypeType', 0, 1, {'minOccurs': '0', 'type': 'apiTypeType', 'name': 'apiType'}, None),
        MemberSpec_('transportMethods', 'transportMethodsType', 0, 1, {'minOccurs': '0', 'type': 'transportMethodsType', 'name': 'transportMethods'}, None),
        MemberSpec_('generatorExe', 'ipxactURI', 0, 0, {'type': 'ipxactURI', 'name': 'generatorExe'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, hidden=False, id=None, name=None, displayName=None, description=None, phase=None, parameters=None, apiType=None, transportMethods=None, generatorExe=None, vendorExtensions=None, extensiontype_=None):
        self.original_tagname_ = None
        self.hidden = _cast(bool, hidden)
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.phase = phase
        self.parameters = parameters
        self.apiType = apiType
        self.transportMethods = transportMethods
        self.generatorExe = generatorExe
        self.vendorExtensions = vendorExtensions
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generatorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generatorType.subclass:
            return generatorType.subclass(*args_, **kwargs_)
        else:
            return generatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_apiType(self): return self.apiType
    def set_apiType(self, apiType): self.apiType = apiType
    def get_transportMethods(self): return self.transportMethods
    def set_transportMethods(self, transportMethods): self.transportMethods = transportMethods
    def get_generatorExe(self): return self.generatorExe
    def set_generatorExe(self, generatorExe): self.generatorExe = generatorExe
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_hidden(self): return self.hidden
    def set_hidden(self, hidden): self.hidden = hidden
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.phase is not None or
            self.parameters is not None or
            self.apiType is not None or
            self.transportMethods is not None or
            self.generatorExe is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='generatorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generatorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='generatorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='generatorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='generatorType'):
        if self.hidden and 'hidden' not in already_processed:
            already_processed.add('hidden')
            outfile.write(' hidden="%s"' % self.gds_format_boolean(self.hidden, input_name='hidden'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='generatorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.phase is not None:
            self.phase.export(outfile, level, namespace_='ipxact:', name_='phase', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.apiType is not None:
            self.apiType.export(outfile, level, namespace_, name_='apiType', pretty_print=pretty_print)
        if self.transportMethods is not None:
            self.transportMethods.export(outfile, level, namespace_, name_='transportMethods', pretty_print=pretty_print)
        if self.generatorExe is not None:
            self.generatorExe.export(outfile, level, namespace_, name_='generatorExe', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('hidden', node)
        if value is not None and 'hidden' not in already_processed:
            already_processed.add('hidden')
            if value in ('true', '1'):
                self.hidden = True
            elif value in ('false', '0'):
                self.hidden = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'phase':
            class_obj_ = self.get_class_obj_(child_, realExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.phase = obj_
            obj_.original_tagname_ = 'phase'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'apiType':
            obj_ = apiTypeType.factory()
            obj_.build(child_)
            self.apiType = obj_
            obj_.original_tagname_ = 'apiType'
        elif nodeName_ == 'transportMethods':
            obj_ = transportMethodsType.factory()
            obj_.build(child_)
            self.transportMethods = obj_
            obj_.original_tagname_ = 'transportMethods'
        elif nodeName_ == 'generatorExe':
            class_obj_ = self.get_class_obj_(child_, ipxactURI)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.generatorExe = obj_
            obj_.original_tagname_ = 'generatorExe'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class generatorType


class Component(GeneratedsSuper):
    """Component-specific extension to componentType"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'vendor'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'library'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'version'}, None),
        MemberSpec_('BusInterfaces', 'busInterfaces', 0, 1, {'minOccurs': '0', 'type': 'busInterfaces', 'ref': 'busInterfaces', 'name': 'busInterfaces'}, None),
        MemberSpec_('indirectInterfaces', 'indirectInterfaces', 0, 1, {'minOccurs': '0', 'type': 'indirectInterfaces', 'ref': 'indirectInterfaces', 'name': 'indirectInterfaces'}, None),
        MemberSpec_('channels', 'channels', 0, 1, {'minOccurs': '0', 'type': 'channels', 'ref': 'channels', 'name': 'channels'}, None),
        MemberSpec_('remapStates', 'remapStates', 0, 1, {'minOccurs': '0', 'type': 'remapStates', 'ref': 'remapStates', 'name': 'remapStates'}, None),
        MemberSpec_('addressSpaces', 'addressSpaces', 0, 1, {'minOccurs': '0', 'type': 'addressSpaces', 'ref': 'addressSpaces', 'name': 'addressSpaces'}, None),
        MemberSpec_('memoryMaps', 'memoryMaps', 0, 1, {'minOccurs': '0', 'type': 'memoryMaps', 'ref': 'memoryMaps', 'name': 'memoryMaps'}, None),
        MemberSpec_('model', 'modelType', 0, 1, {'minOccurs': '0', 'type': 'model', 'ref': 'model', 'name': 'model'}, None),
        MemberSpec_('componentGenerators', 'componentGenerators', 0, 1, {'minOccurs': '0', 'type': 'componentGenerators', 'ref': 'componentGenerators', 'name': 'componentGenerators'}, None),
        MemberSpec_('choices', 'choices', 0, 1, {'minOccurs': '0', 'type': 'choices', 'ref': 'choices', 'name': 'choices'}, None),
        MemberSpec_('fileSets', 'fileSets', 0, 1, {'minOccurs': '0', 'type': 'fileSets', 'ref': 'fileSets', 'name': 'fileSets'}, None),
        MemberSpec_('whiteboxElements', 'whiteboxElementsType', 0, 1, {'minOccurs': '0', 'type': 'whiteboxElementsType', 'name': 'whiteboxElements'}, None),
        MemberSpec_('cpus', 'cpusType', 0, 1, {'minOccurs': '0', 'type': 'cpusType', 'name': 'cpus'}, None),
        MemberSpec_('otherClockDrivers', 'otherClocks', 0, 1, {'minOccurs': '0', 'type': 'otherClocks', 'name': 'otherClockDrivers'}, None),
        MemberSpec_('resetTypes', 'resetTypesType', 0, 1, {'minOccurs': '0', 'type': 'resetTypesType', 'name': 'resetTypes'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'type': 'assertions', 'ref': 'assertions', 'name': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, BusInterfaces=None, indirectInterfaces=None, channels=None, remapStates=None, addressSpaces=None, memoryMaps=None, model=None, componentGenerators=None, choices=None, fileSets=None, whiteboxElements=None, cpus=None, otherClockDrivers=None, resetTypes=None, description=None, parameters=None, assertions=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.vendor = vendor
        self.library = library
        self.name = name
        self.version = version
        self.BusInterfaces = BusInterfaces
        self.indirectInterfaces = indirectInterfaces
        self.channels = channels
        self.remapStates = remapStates
        self.addressSpaces = addressSpaces
        self.memoryMaps = memoryMaps
        self.model = model
        self.componentGenerators = componentGenerators
        self.choices = choices
        self.fileSets = fileSets
        self.whiteboxElements = whiteboxElements
        self.cpus = cpus
        self.otherClockDrivers = otherClockDrivers
        self.resetTypes = resetTypes
        self.description = description
        self.parameters = parameters
        self.assertions = assertions
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Component)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Component.subclass:
            return Component.subclass(*args_, **kwargs_)
        else:
            return Component(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_busInterfaces(self): return self.BusInterfaces
    def set_busInterfaces(self, BusInterfaces): self.BusInterfaces = BusInterfaces
    def get_indirectInterfaces(self): return self.indirectInterfaces
    def set_indirectInterfaces(self, indirectInterfaces): self.indirectInterfaces = indirectInterfaces
    def get_channels(self): return self.channels
    def set_channels(self, channels): self.channels = channels
    def get_remapStates(self): return self.remapStates
    def set_remapStates(self, remapStates): self.remapStates = remapStates
    def get_addressSpaces(self): return self.addressSpaces
    def set_addressSpaces(self, addressSpaces): self.addressSpaces = addressSpaces
    def get_memoryMaps(self): return self.memoryMaps
    def set_memoryMaps(self, memoryMaps): self.memoryMaps = memoryMaps
    def get_model(self): return self.model
    def set_model(self, model): self.model = model
    def get_componentGenerators(self): return self.componentGenerators
    def set_componentGenerators(self, componentGenerators): self.componentGenerators = componentGenerators
    def get_choices(self): return self.choices
    def set_choices(self, choices): self.choices = choices
    def get_fileSets(self): return self.fileSets
    def set_fileSets(self, fileSets): self.fileSets = fileSets
    def get_whiteboxElements(self): return self.whiteboxElements
    def set_whiteboxElements(self, whiteboxElements): self.whiteboxElements = whiteboxElements
    def get_cpus(self): return self.cpus
    def set_cpus(self, cpus): self.cpus = cpus
    def get_otherClockDrivers(self): return self.otherClockDrivers
    def set_otherClockDrivers(self, otherClockDrivers): self.otherClockDrivers = otherClockDrivers
    def get_resetTypes(self): return self.resetTypes
    def set_resetTypes(self, resetTypes): self.resetTypes = resetTypes
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_assertions(self): return self.assertions
    def set_assertions(self, assertions): self.assertions = assertions
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.BusInterfaces is not None or
            self.indirectInterfaces is not None or
            self.channels is not None or
            self.remapStates is not None or
            self.addressSpaces is not None or
            self.memoryMaps is not None or
            self.model is not None or
            self.componentGenerators is not None or
            self.choices is not None or
            self.fileSets is not None or
            self.whiteboxElements is not None or
            self.cpus is not None or
            self.otherClockDrivers is not None or
            self.resetTypes is not None or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='componentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='componentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='componentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='componentType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='componentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:vendor>%s</ipxact:vendor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), eol_))
        if self.library is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:library>%s</ipxact:library>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:version>%s</ipxact:version>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), eol_))
        if self.BusInterfaces is not None:
            self.BusInterfaces.export(outfile, level, namespace_='ipxact:', name_='busInterfaces', pretty_print=pretty_print)
        if self.indirectInterfaces is not None:
            self.indirectInterfaces.export(outfile, level, namespace_='ipxact:', name_='indirectInterfaces', pretty_print=pretty_print)
        if self.channels is not None:
            self.channels.export(outfile, level, namespace_='ipxact:', name_='channels', pretty_print=pretty_print)
        if self.remapStates is not None:
            self.remapStates.export(outfile, level, namespace_='ipxact:', name_='remapStates', pretty_print=pretty_print)
        if self.addressSpaces is not None:
            self.addressSpaces.export(outfile, level, namespace_='ipxact:', name_='addressSpaces', pretty_print=pretty_print)
        if self.memoryMaps is not None:
            self.memoryMaps.export(outfile, level, namespace_='ipxact:', name_='memoryMaps', pretty_print=pretty_print)
        if self.model is not None:
            self.model.export(outfile, level, namespace_='ipxact:', name_='model', pretty_print=pretty_print)
        if self.componentGenerators is not None:
            self.componentGenerators.export(outfile, level, namespace_='ipxact:', name_='componentGenerators', pretty_print=pretty_print)
        if self.choices is not None:
            self.choices.export(outfile, level, namespace_='ipxact:', name_='choices', pretty_print=pretty_print)
        if self.fileSets is not None:
            self.fileSets.export(outfile, level, namespace_='ipxact:', name_='fileSets', pretty_print=pretty_print)
        if self.whiteboxElements is not None:
            self.whiteboxElements.export(outfile, level, namespace_, name_='whiteboxElements', pretty_print=pretty_print)
        if self.cpus is not None:
            self.cpus.export(outfile, level, namespace_, name_='cpus', pretty_print=pretty_print)
        if self.otherClockDrivers is not None:
            self.otherClockDrivers.export(outfile, level, namespace_, name_='otherClockDrivers', pretty_print=pretty_print)
        if self.resetTypes is not None:
            self.resetTypes.export(outfile, level, namespace_, name_='resetTypes', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            self.assertions.export(outfile, level, namespace_='ipxact:', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'library':
            library_ = child_.text
            library_ = self.gds_validate_string(library_, node, 'library')
            self.library = library_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'busInterfaces':
            obj_ = BusInterfaces.factory()
            obj_.build(child_)
            self.BusInterfaces = obj_
            obj_.original_tagname_ = 'busInterfaces'
        elif nodeName_ == 'indirectInterfaces':
            obj_ = indirectInterfaces.factory()
            obj_.build(child_)
            self.indirectInterfaces = obj_
            obj_.original_tagname_ = 'indirectInterfaces'
        elif nodeName_ == 'channels':
            obj_ = channels.factory()
            obj_.build(child_)
            self.channels = obj_
            obj_.original_tagname_ = 'channels'
        elif nodeName_ == 'remapStates':
            obj_ = remapStates.factory()
            obj_.build(child_)
            self.remapStates = obj_
            obj_.original_tagname_ = 'remapStates'
        elif nodeName_ == 'addressSpaces':
            obj_ = addressSpaces.factory()
            obj_.build(child_)
            self.addressSpaces = obj_
            obj_.original_tagname_ = 'addressSpaces'
        elif nodeName_ == 'memoryMaps':
            obj_ = memoryMaps.factory()
            obj_.build(child_)
            self.memoryMaps = obj_
            obj_.original_tagname_ = 'memoryMaps'
        elif nodeName_ == 'model':
            obj_ = Model.factory()
            obj_.build(child_)
            self.model = obj_
            obj_.original_tagname_ = 'model'
        elif nodeName_ == 'componentGenerators':
            obj_ = componentGenerators.factory()
            obj_.build(child_)
            self.componentGenerators = obj_
            obj_.original_tagname_ = 'componentGenerators'
        elif nodeName_ == 'choices':
            obj_ = choices.factory()
            obj_.build(child_)
            self.choices = obj_
            obj_.original_tagname_ = 'choices'
        elif nodeName_ == 'fileSets':
            obj_ = fileSets.factory()
            obj_.build(child_)
            self.fileSets = obj_
            obj_.original_tagname_ = 'fileSets'
        elif nodeName_ == 'whiteboxElements':
            obj_ = whiteboxElementsType.factory()
            obj_.build(child_)
            self.whiteboxElements = obj_
            obj_.original_tagname_ = 'whiteboxElements'
        elif nodeName_ == 'cpus':
            obj_ = cpusType.factory()
            obj_.build(child_)
            self.cpus = obj_
            obj_.original_tagname_ = 'cpus'
        elif nodeName_ == 'otherClockDrivers':
            obj_ = otherClocks.factory()
            obj_.build(child_)
            self.otherClockDrivers = obj_
            obj_.original_tagname_ = 'otherClockDrivers'
        elif nodeName_ == 'resetTypes':
            obj_ = resetTypesType.factory()
            obj_.build(child_)
            self.resetTypes = obj_
            obj_.original_tagname_ = 'resetTypes'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory()
            obj_.build(child_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class Component


class whiteboxElementType(GeneratedsSuper):
    """Defines a white box reference point within the component."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('whiteboxType', ['simpleWhiteboxType', 'xs:token'], 0, 0, {'type': 'xs:token', 'name': 'whiteboxType'}, None),
        MemberSpec_('driveable', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'default': 'false', 'name': 'driveable'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, whiteboxType=None, driveable=False, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        self.whiteboxType = whiteboxType
        self.validate_simpleWhiteboxType(self.whiteboxType)
        self.driveable = driveable
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, whiteboxElementType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if whiteboxElementType.subclass:
            return whiteboxElementType.subclass(*args_, **kwargs_)
        else:
            return whiteboxElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_whiteboxType(self): return self.whiteboxType
    def set_whiteboxType(self, whiteboxType): self.whiteboxType = whiteboxType
    def get_driveable(self): return self.driveable
    def set_driveable(self, driveable): self.driveable = driveable
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_simpleWhiteboxType(self, value):
        # Validate type simpleWhiteboxType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['signal', 'pin', 'interface']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on simpleWhiteboxType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.whiteboxType is not None or
            self.driveable or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='whiteboxElementType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('whiteboxElementType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='whiteboxElementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='whiteboxElementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='whiteboxElementType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='whiteboxElementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.whiteboxType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:whiteboxType>%s</ipxact:whiteboxType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.whiteboxType), input_name='whiteboxType')), eol_))
        if self.driveable:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:driveable>%s</ipxact:driveable>%s' % (self.gds_format_boolean(self.driveable, input_name='driveable'), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'whiteboxType':
            whiteboxType_ = child_.text
            if whiteboxType_:
                whiteboxType_ = re_.sub(String_cleanup_pat_, " ", whiteboxType_).strip()
            else:
                whiteboxType_ = ""
            whiteboxType_ = self.gds_validate_string(whiteboxType_, node, 'whiteboxType')
            self.whiteboxType = whiteboxType_
            # validate type simpleWhiteboxType
            self.validate_simpleWhiteboxType(self.whiteboxType)
        elif nodeName_ == 'driveable':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'driveable')
            self.driveable = ival_
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class whiteboxElementType


class complexBitSteeringExpression(GeneratedsSuper):
    """Indicates whether bit steering should be used to map this interface
    onto a bus of different data width. Values are "on", "off" or an
    expression which resolves to an unsigned-bit where a '1'
    indicates "on" and a '0' indicates "off" (defaults to "off")."""
    member_data_items_ = [
        MemberSpec_('valueOf_', ['simpleBitSteeringExpression', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, complexBitSteeringExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if complexBitSteeringExpression.subclass:
            return complexBitSteeringExpression.subclass(*args_, **kwargs_)
        else:
            return complexBitSteeringExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='complexBitSteeringExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('complexBitSteeringExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='complexBitSteeringExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='complexBitSteeringExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='complexBitSteeringExpression'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='complexBitSteeringExpression', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class complexBitSteeringExpression


class viewRef(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:NMTOKEN', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRef.subclass:
            return viewRef.subclass(*args_, **kwargs_)
        else:
            return viewRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewRef', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewRef')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewRef'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class viewRef


class BusInterfaces(GeneratedsSuper):
    """A list of bus interfaces supported by this component."""
    member_data_items_ = [
        MemberSpec_('BusInterface', 'busInterfaceType', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'busInterface', 'name': 'busInterface', 'type': 'busInterfaceType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, BusInterface=None):
        self.original_tagname_ = None
        if BusInterface is None:
            self.BusInterface = []
        else:
            self.BusInterface = BusInterface
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusInterfaces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusInterfaces.subclass:
            return BusInterfaces.subclass(*args_, **kwargs_)
        else:
            return BusInterfaces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_busInterface(self): return self.BusInterface
    def set_busInterface(self, BusInterface): self.BusInterface = BusInterface
    def add_busInterface(self, value): self.BusInterface.append(value)
    def insert_busInterface_at(self, index, value): self.BusInterface.insert(index, value)
    def replace_busInterface_at(self, index, value): self.BusInterface[index] = value
    def hasContent_(self):
        if (
            self.BusInterface
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='busInterfaces', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('busInterfaces')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='busInterfaces')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='busInterfaces', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='busInterfaces'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='busInterfaces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for busInterface_ in self.BusInterface:
            busInterface_.export(outfile, level, namespace_='ipxact:', name_='busInterface', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'busInterface':
            obj_ = BusInterface.factory()
            obj_.build(child_)
            self.BusInterface.append(obj_)
            obj_.original_tagname_ = 'busInterface'
# end class BusInterfaces


class BusInterface(GeneratedsSuper):
    """Type definition for a busInterface in a component"""
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('busType', 'configurableLibraryRefType', 0, 0, {'type': 'configurableLibraryRefType', 'name': 'busType'}, None),
        MemberSpec_('AbstractionTypes', 'abstractionTypes', 0, 1, {'minOccurs': '0', 'type': 'abstractionTypes', 'ref': 'abstractionTypes', 'name': 'abstractionTypes'}, None),
        MemberSpec_('master', 'masterType', 0, 0, {'type': 'masterType', 'name': 'master'}, None),
        MemberSpec_('slave', 'slaveType', 0, 0, {'type': 'slaveType', 'name': 'slave'}, None),
        MemberSpec_('system', 'systemType', 0, 0, {'type': 'systemType', 'name': 'system'}, None),
        MemberSpec_('mirroredSlave', 'mirroredSlaveType', 0, 0, {'type': 'mirroredSlaveType', 'name': 'mirroredSlave'}, None),
        MemberSpec_('mirroredMaster', 'mirroredMasterType', 0, 0, {'type': 'mirroredMasterType', 'name': 'mirroredMaster'}, None),
        MemberSpec_('mirroredSystem', 'mirroredSystemType', 0, 0, {'type': 'mirroredSystemType', 'name': 'mirroredSystem'}, None),
        MemberSpec_('monitor', 'monitorType', 0, 0, {'type': 'monitorType', 'name': 'monitor'}, None),
        MemberSpec_('connectionRequired', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'default': 'false', 'name': 'connectionRequired'}, None),
        MemberSpec_('bitsInLau', 'unsignedPositiveLongintExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedPositiveLongintExpression', 'ref': 'bitsInLau', 'name': 'bitsInLau'}, None),
        MemberSpec_('bitSteering', 'complexBitSteeringExpression', 0, 1, {'minOccurs': '0', 'type': 'complexBitSteeringExpression', 'default': 'off', 'name': 'bitSteering'}, None),
        MemberSpec_('endianness', ['endianessType', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'name': 'endianness'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, isPresent=None, busType=None, AbstractionTypes=None, master=None, slave=None, system=None, mirroredSlave=None, mirroredMaster=None, mirroredSystem=None, monitor=None, connectionRequired=False, bitsInLau=None, bitSteering=None, endianness=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        self.busType = busType
        self.AbstractionTypes = AbstractionTypes
        self.master = master
        self.slave = slave
        self.system = system
        self.mirroredSlave = mirroredSlave
        self.mirroredMaster = mirroredMaster
        self.mirroredSystem = mirroredSystem
        self.monitor = monitor
        self.connectionRequired = connectionRequired
        self.bitsInLau = bitsInLau
        if bitSteering is None:
            self.bitSteering = globals()['complexBitSteeringExpression']('off')
        else:
            self.bitSteering = bitSteering
        self.endianness = endianness
        self.validate_endianessType(self.endianness)
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BusInterface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BusInterface.subclass:
            return BusInterface.subclass(*args_, **kwargs_)
        else:
            return BusInterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_busType(self): return self.busType
    def set_busType(self, busType): self.busType = busType
    def get_abstractionTypes(self): return self.AbstractionTypes
    def set_abstractionTypes(self, AbstractionTypes): self.AbstractionTypes = AbstractionTypes
    def get_master(self): return self.master
    def set_master(self, master): self.master = master
    def get_slave(self): return self.slave
    def set_slave(self, slave): self.slave = slave
    def get_system(self): return self.system
    def set_system(self, system): self.system = system
    def get_mirroredSlave(self): return self.mirroredSlave
    def set_mirroredSlave(self, mirroredSlave): self.mirroredSlave = mirroredSlave
    def get_mirroredMaster(self): return self.mirroredMaster
    def set_mirroredMaster(self, mirroredMaster): self.mirroredMaster = mirroredMaster
    def get_mirroredSystem(self): return self.mirroredSystem
    def set_mirroredSystem(self, mirroredSystem): self.mirroredSystem = mirroredSystem
    def get_monitor(self): return self.monitor
    def set_monitor(self, monitor): self.monitor = monitor
    def get_connectionRequired(self): return self.connectionRequired
    def set_connectionRequired(self, connectionRequired): self.connectionRequired = connectionRequired
    def get_bitsInLau(self): return self.bitsInLau
    def set_bitsInLau(self, bitsInLau): self.bitsInLau = bitsInLau
    def get_bitSteering(self): return self.bitSteering
    def set_bitSteering(self, bitSteering): self.bitSteering = bitSteering
    def get_endianness(self): return self.endianness
    def set_endianness(self, endianness): self.endianness = endianness
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def validate_endianessType(self, value):
        # Validate type endianessType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['big', 'little']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on endianessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.busType is not None or
            self.AbstractionTypes is not None or
            self.master is not None or
            self.slave is not None or
            self.system is not None or
            self.mirroredSlave is not None or
            self.mirroredMaster is not None or
            self.mirroredSystem is not None or
            self.monitor is not None or
            self.connectionRequired or
            self.bitsInLau is not None or
            self.bitSteering != off or
            self.endianness is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='busInterfaceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('busInterfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='busInterfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='busInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='busInterfaceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='busInterfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.busType is not None:
            self.busType.export(outfile, level, namespace_, name_='busType', pretty_print=pretty_print)
        if self.AbstractionTypes is not None:
            self.AbstractionTypes.export(outfile, level, namespace_='ipxact:', name_='abstractionTypes', pretty_print=pretty_print)
        if self.master is not None:
            self.master.export(outfile, level, namespace_, name_='master', pretty_print=pretty_print)
        if self.slave is not None:
            self.slave.export(outfile, level, namespace_, name_='slave', pretty_print=pretty_print)
        if self.system is not None:
            self.system.export(outfile, level, namespace_, name_='system', pretty_print=pretty_print)
        if self.mirroredSlave is not None:
            self.mirroredSlave.export(outfile, level, namespace_, name_='mirroredSlave', pretty_print=pretty_print)
        if self.mirroredMaster is not None:
            self.mirroredMaster.export(outfile, level, namespace_, name_='mirroredMaster', pretty_print=pretty_print)
        if self.mirroredSystem is not None:
            self.mirroredSystem.export(outfile, level, namespace_, name_='mirroredSystem', pretty_print=pretty_print)
        if self.monitor is not None:
            self.monitor.export(outfile, level, namespace_, name_='monitor', pretty_print=pretty_print)
        if self.connectionRequired:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:connectionRequired>%s</ipxact:connectionRequired>%s' % (self.gds_format_boolean(self.connectionRequired, input_name='connectionRequired'), eol_))
        if self.bitsInLau is not None:
            self.bitsInLau.export(outfile, level, namespace_='ipxact:', name_='bitsInLau', pretty_print=pretty_print)
        if self.bitSteering is not None:
            self.bitSteering.export(outfile, level, namespace_, name_='bitSteering', pretty_print=pretty_print)
        if self.endianness is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:endianness>%s</ipxact:endianness>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.endianness), input_name='endianness')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'busType':
            obj_ = ConfigurableLibraryRef.factory()
            obj_.build(child_)
            self.busType = obj_
            obj_.original_tagname_ = 'busType'
        elif nodeName_ == 'abstractionTypes':
            obj_ = AbstractionTypes.factory()
            obj_.build(child_)
            self.AbstractionTypes = obj_
            obj_.original_tagname_ = 'abstractionTypes'
        elif nodeName_ == 'master':
            obj_ = Master.factory()
            obj_.build(child_)
            self.master = obj_
            obj_.original_tagname_ = 'master'
        elif nodeName_ == 'slave':
            obj_ = Slave.factory()
            obj_.build(child_)
            self.slave = obj_
            obj_.original_tagname_ = 'slave'
        elif nodeName_ == 'system':
            obj_ = systemType.factory()
            obj_.build(child_)
            self.system = obj_
            obj_.original_tagname_ = 'system'
        elif nodeName_ == 'mirroredSlave':
            obj_ = mirroredSlaveType.factory()
            obj_.build(child_)
            self.mirroredSlave = obj_
            obj_.original_tagname_ = 'mirroredSlave'
        elif nodeName_ == 'mirroredMaster':
            obj_ = mirroredMasterType.factory()
            obj_.build(child_)
            self.mirroredMaster = obj_
            obj_.original_tagname_ = 'mirroredMaster'
        elif nodeName_ == 'mirroredSystem':
            obj_ = mirroredSystemType.factory()
            obj_.build(child_)
            self.mirroredSystem = obj_
            obj_.original_tagname_ = 'mirroredSystem'
        elif nodeName_ == 'monitor':
            obj_ = monitorType.factory()
            obj_.build(child_)
            self.monitor = obj_
            obj_.original_tagname_ = 'monitor'
        elif nodeName_ == 'connectionRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'connectionRequired')
            self.connectionRequired = ival_
        elif nodeName_ == 'bitsInLau':
            obj_ = unsignedPositiveLongintExpression.factory()
            obj_.build(child_)
            self.bitsInLau = obj_
            obj_.original_tagname_ = 'bitsInLau'
        elif nodeName_ == 'bitSteering':
            obj_ = complexBitSteeringExpression.factory()
            obj_.build(child_)
            self.bitSteering = obj_
            obj_.original_tagname_ = 'bitSteering'
        elif nodeName_ == 'endianness':
            endianness_ = child_.text
            endianness_ = self.gds_validate_string(endianness_, node, 'endianness')
            self.endianness = endianness_
            # validate type endianessType
            self.validate_endianessType(self.endianness)
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class BusInterface


class channels(GeneratedsSuper):
    """Lists all channel connections between mirror interfaces of this
    component."""
    member_data_items_ = [
        MemberSpec_('channel', 'channelType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'channel', 'type': 'channelType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, channel=None):
        self.original_tagname_ = None
        if channel is None:
            self.channel = []
        else:
            self.channel = channel
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, channels)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if channels.subclass:
            return channels.subclass(*args_, **kwargs_)
        else:
            return channels(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_channel(self): return self.channel
    def set_channel(self, channel): self.channel = channel
    def add_channel(self, value): self.channel.append(value)
    def insert_channel_at(self, index, value): self.channel.insert(index, value)
    def replace_channel_at(self, index, value): self.channel[index] = value
    def hasContent_(self):
        if (
            self.channel
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='channels', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('channels')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='channels')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='channels', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='channels'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='channels', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for channel_ in self.channel:
            channel_.export(outfile, level, namespace_, name_='channel', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'channel':
            obj_ = channelType.factory()
            obj_.build(child_)
            self.channel.append(obj_)
            obj_.original_tagname_ = 'channel'
# end class channels


class remapStates(GeneratedsSuper):
    """Contains a list of remap state names and associated port values"""
    member_data_items_ = [
        MemberSpec_('remapState', 'remapStateType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'remapState', 'type': 'remapStateType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, remapState=None):
        self.original_tagname_ = None
        if remapState is None:
            self.remapState = []
        else:
            self.remapState = remapState
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapStates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapStates.subclass:
            return remapStates.subclass(*args_, **kwargs_)
        else:
            return remapStates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_remapState(self): return self.remapState
    def set_remapState(self, remapState): self.remapState = remapState
    def add_remapState(self, value): self.remapState.append(value)
    def insert_remapState_at(self, index, value): self.remapState.insert(index, value)
    def replace_remapState_at(self, index, value): self.remapState[index] = value
    def hasContent_(self):
        if (
            self.remapState
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='remapStates', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapStates')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='remapStates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='remapStates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='remapStates'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='remapStates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remapState_ in self.remapState:
            remapState_.export(outfile, level, namespace_, name_='remapState', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'remapState':
            obj_ = remapStateType.factory()
            obj_.build(child_)
            self.remapState.append(obj_)
            obj_.original_tagname_ = 'remapState'
# end class remapStates


class transparentBridge(GeneratedsSuper):
    """If this element is present, it indicates that the bus interface
    provides a transparent bridge to another master bus interface on
    the same component. It has a masterRef attribute which contains
    the name of the other bus interface. Any slave interface can
    bridge to multiple master interfaces, and multiple slave
    interfaces can bridge to the same master interface.The name of
    the master bus interface to which this interface bridges."""
    member_data_items_ = [
        MemberSpec_('masterRef', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, masterRef=None, id=None, isPresent=None):
        self.original_tagname_ = None
        self.masterRef = _cast(None, masterRef)
        self.id = _cast(None, id)
        self.isPresent = isPresent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transparentBridge)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transparentBridge.subclass:
            return transparentBridge.subclass(*args_, **kwargs_)
        else:
            return transparentBridge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_masterRef(self): return self.masterRef
    def set_masterRef(self, masterRef): self.masterRef = masterRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='transparentBridge', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transparentBridge')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transparentBridge')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='transparentBridge', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='transparentBridge'):
        if self.masterRef is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            outfile.write(' masterRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.masterRef), input_name='masterRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='transparentBridge', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterRef', node)
        if value is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            self.masterRef = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class transparentBridge


class abstractorBusInterfaceType(GeneratedsSuper):
    """Type definition for a busInterface in a component"""
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('AbstractionTypes', 'abstractionTypes', 0, 1, {'minOccurs': '0', 'type': 'abstractionTypes', 'ref': 'abstractionTypes', 'name': 'abstractionTypes'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, AbstractionTypes=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.name = name
        self.displayName = displayName
        self.description = description
        self.AbstractionTypes = AbstractionTypes
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorBusInterfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorBusInterfaceType.subclass:
            return abstractorBusInterfaceType.subclass(*args_, **kwargs_)
        else:
            return abstractorBusInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_abstractionTypes(self): return self.AbstractionTypes
    def set_abstractionTypes(self, AbstractionTypes): self.AbstractionTypes = AbstractionTypes
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.AbstractionTypes is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractorBusInterfaceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorBusInterfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractorBusInterfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractorBusInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractorBusInterfaceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractorBusInterfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.AbstractionTypes is not None:
            self.AbstractionTypes.export(outfile, level, namespace_='ipxact:', name_='abstractionTypes', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'abstractionTypes':
            obj_ = AbstractionTypes.factory()
            obj_.build(child_)
            self.AbstractionTypes = obj_
            obj_.original_tagname_ = 'abstractionTypes'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class abstractorBusInterfaceType


class indirectInterfaces(GeneratedsSuper):
    """A list of bus interfaces supported by this component."""
    member_data_items_ = [
        MemberSpec_('indirectInterface', 'indirectInterfaceType', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'indirectInterface', 'name': 'indirectInterface', 'type': 'indirectInterfaceType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, indirectInterface=None):
        self.original_tagname_ = None
        if indirectInterface is None:
            self.indirectInterface = []
        else:
            self.indirectInterface = indirectInterface
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indirectInterfaces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indirectInterfaces.subclass:
            return indirectInterfaces.subclass(*args_, **kwargs_)
        else:
            return indirectInterfaces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indirectInterface(self): return self.indirectInterface
    def set_indirectInterface(self, indirectInterface): self.indirectInterface = indirectInterface
    def add_indirectInterface(self, value): self.indirectInterface.append(value)
    def insert_indirectInterface_at(self, index, value): self.indirectInterface.insert(index, value)
    def replace_indirectInterface_at(self, index, value): self.indirectInterface[index] = value
    def hasContent_(self):
        if (
            self.indirectInterface
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='indirectInterfaces', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indirectInterfaces')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indirectInterfaces')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='indirectInterfaces', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='indirectInterfaces'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='indirectInterfaces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for indirectInterface_ in self.indirectInterface:
            indirectInterface_.export(outfile, level, namespace_='ipxact:', name_='indirectInterface', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indirectInterface':
            obj_ = indirectInterfaceType.factory()
            obj_.build(child_)
            self.indirectInterface.append(obj_)
            obj_.original_tagname_ = 'indirectInterface'
# end class indirectInterfaces


class indirectInterfaceType(GeneratedsSuper):
    """Type definition for a indirectInterface in a component"""
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('indirectAddressRef', 'xs:Name', 0, 0, {'type': 'xs:Name', 'ref': 'indirectAddressRef', 'name': 'indirectAddressRef'}, None),
        MemberSpec_('indirectDataRef', 'xs:Name', 0, 0, {'type': 'xs:Name', 'ref': 'indirectDataRef', 'name': 'indirectDataRef'}, None),
        MemberSpec_('memoryMapRef', 'memoryMapRefType', 0, 0, {'type': 'xs:Name', 'name': 'memoryMapRef'}, 14),
        MemberSpec_('transparentBridge', 'transparentBridge', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'transparentBridge', 'name': 'transparentBridge', 'type': 'transparentBridge'}, 14),
        MemberSpec_('bitsInLau', 'unsignedPositiveLongintExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedPositiveLongintExpression', 'ref': 'bitsInLau', 'name': 'bitsInLau'}, None),
        MemberSpec_('endianness', ['endianessType', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'name': 'endianness'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, indirectAddressRef=None, indirectDataRef=None, memoryMapRef=None, transparentBridge=None, bitsInLau=None, endianness=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.name = name
        self.displayName = displayName
        self.description = description
        self.indirectAddressRef = indirectAddressRef
        self.indirectDataRef = indirectDataRef
        self.memoryMapRef = memoryMapRef
        if transparentBridge is None:
            self.transparentBridge = []
        else:
            self.transparentBridge = transparentBridge
        self.bitsInLau = bitsInLau
        self.endianness = endianness
        self.validate_endianessType(self.endianness)
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indirectInterfaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indirectInterfaceType.subclass:
            return indirectInterfaceType.subclass(*args_, **kwargs_)
        else:
            return indirectInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_indirectAddressRef(self): return self.indirectAddressRef
    def set_indirectAddressRef(self, indirectAddressRef): self.indirectAddressRef = indirectAddressRef
    def get_indirectDataRef(self): return self.indirectDataRef
    def set_indirectDataRef(self, indirectDataRef): self.indirectDataRef = indirectDataRef
    def get_memoryMapRef(self): return self.memoryMapRef
    def set_memoryMapRef(self, memoryMapRef): self.memoryMapRef = memoryMapRef
    def get_transparentBridge(self): return self.transparentBridge
    def set_transparentBridge(self, transparentBridge): self.transparentBridge = transparentBridge
    def add_transparentBridge(self, value): self.transparentBridge.append(value)
    def insert_transparentBridge_at(self, index, value): self.transparentBridge.insert(index, value)
    def replace_transparentBridge_at(self, index, value): self.transparentBridge[index] = value
    def get_bitsInLau(self): return self.bitsInLau
    def set_bitsInLau(self, bitsInLau): self.bitsInLau = bitsInLau
    def get_endianness(self): return self.endianness
    def set_endianness(self, endianness): self.endianness = endianness
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def validate_endianessType(self, value):
        # Validate type endianessType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['big', 'little']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on endianessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.indirectAddressRef is not None or
            self.indirectDataRef is not None or
            self.memoryMapRef is not None or
            self.transparentBridge or
            self.bitsInLau is not None or
            self.endianness is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='indirectInterfaceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indirectInterfaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indirectInterfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='indirectInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='indirectInterfaceType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='indirectInterfaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.indirectAddressRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:indirectAddressRef>%s</ipxact:indirectAddressRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indirectAddressRef), input_name='indirectAddressRef')), eol_))
        if self.indirectDataRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:indirectDataRef>%s</ipxact:indirectDataRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.indirectDataRef), input_name='indirectDataRef')), eol_))
        if self.memoryMapRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:memoryMapRef>%s</ipxact:memoryMapRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.memoryMapRef), input_name='memoryMapRef')), eol_))
        for transparentBridge_ in self.transparentBridge:
            transparentBridge_.export(outfile, level, namespace_='ipxact:', name_='transparentBridge', pretty_print=pretty_print)
        if self.bitsInLau is not None:
            self.bitsInLau.export(outfile, level, namespace_='ipxact:', name_='bitsInLau', pretty_print=pretty_print)
        if self.endianness is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:endianness>%s</ipxact:endianness>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.endianness), input_name='endianness')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'indirectAddressRef':
            indirectAddressRef_ = child_.text
            indirectAddressRef_ = self.gds_validate_string(indirectAddressRef_, node, 'indirectAddressRef')
            self.indirectAddressRef = indirectAddressRef_
        elif nodeName_ == 'indirectDataRef':
            indirectDataRef_ = child_.text
            indirectDataRef_ = self.gds_validate_string(indirectDataRef_, node, 'indirectDataRef')
            self.indirectDataRef = indirectDataRef_
        elif nodeName_ == 'memoryMapRef':
            memoryMapRef_ = child_.text
            memoryMapRef_ = self.gds_validate_string(memoryMapRef_, node, 'memoryMapRef')
            self.memoryMapRef = memoryMapRef_
        elif nodeName_ == 'transparentBridge':
            obj_ = transparentBridge.factory()
            obj_.build(child_)
            self.transparentBridge.append(obj_)
            obj_.original_tagname_ = 'transparentBridge'
        elif nodeName_ == 'bitsInLau':
            obj_ = unsignedPositiveLongintExpression.factory()
            obj_.build(child_)
            self.bitsInLau = obj_
            obj_.original_tagname_ = 'bitsInLau'
        elif nodeName_ == 'endianness':
            endianness_ = child_.text
            endianness_ = self.gds_validate_string(endianness_, node, 'endianness')
            self.endianness = endianness_
            # validate type endianessType
            self.validate_endianessType(self.endianness)
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class indirectInterfaceType


class AbstractionTypes(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('abstractionType', 'abstractionTypeType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'abstractionType', 'type': 'abstractionTypeType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, abstractionType=None):
        self.original_tagname_ = None
        if abstractionType is None:
            self.abstractionType = []
        else:
            self.abstractionType = abstractionType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractionTypes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractionTypes.subclass:
            return AbstractionTypes.subclass(*args_, **kwargs_)
        else:
            return AbstractionTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_abstractionType(self): return self.abstractionType
    def set_abstractionType(self, abstractionType): self.abstractionType = abstractionType
    def add_abstractionType(self, value): self.abstractionType.append(value)
    def insert_abstractionType_at(self, index, value): self.abstractionType.insert(index, value)
    def replace_abstractionType_at(self, index, value): self.abstractionType[index] = value
    def hasContent_(self):
        if (
            self.abstractionType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractionTypes', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractionTypes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractionTypes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractionTypes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractionTypes'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractionTypes', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for abstractionType_ in self.abstractionType:
            abstractionType_.export(outfile, level, namespace_, name_='abstractionType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'abstractionType':
            obj_ = AbstractionType.factory()
            obj_.build(child_)
            self.abstractionType.append(obj_)
            obj_.original_tagname_ = 'abstractionType'
# end class AbstractionTypes


class abstractionDefinition(GeneratedsSuper):
    """Define the ports and other information of a particular abstraction
    of the bus"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'vendor'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'library'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'version'}, None),
        MemberSpec_('busType', 'libraryRefType', 0, 0, {'type': 'libraryRefType', 'name': 'busType'}, None),
        MemberSpec_('extends', 'libraryRefType', 0, 1, {'minOccurs': '0', 'type': 'libraryRefType', 'name': 'extends'}, None),
        MemberSpec_('ports', 'portsType', 0, 0, {'type': 'portsType', 'name': 'ports'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'type': 'assertions', 'ref': 'assertions', 'name': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, busType=None, extends=None, ports=None, description=None, parameters=None, assertions=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.vendor = vendor
        self.library = library
        self.name = name
        self.version = version
        self.busType = busType
        self.extends = extends
        self.ports = ports
        self.description = description
        self.parameters = parameters
        self.assertions = assertions
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractionDefinition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractionDefinition.subclass:
            return abstractionDefinition.subclass(*args_, **kwargs_)
        else:
            return abstractionDefinition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_busType(self): return self.busType
    def set_busType(self, busType): self.busType = busType
    def get_extends(self): return self.extends
    def set_extends(self, extends): self.extends = extends
    def get_ports(self): return self.ports
    def set_ports(self, ports): self.ports = ports
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_assertions(self): return self.assertions
    def set_assertions(self, assertions): self.assertions = assertions
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.busType is not None or
            self.extends is not None or
            self.ports is not None or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractionDefinition', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractionDefinition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractionDefinition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractionDefinition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractionDefinition'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractionDefinition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:vendor>%s</ipxact:vendor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), eol_))
        if self.library is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:library>%s</ipxact:library>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:version>%s</ipxact:version>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), eol_))
        if self.busType is not None:
            self.busType.export(outfile, level, namespace_, name_='busType', pretty_print=pretty_print)
        if self.extends is not None:
            self.extends.export(outfile, level, namespace_, name_='extends', pretty_print=pretty_print)
        if self.ports is not None:
            self.ports.export(outfile, level, namespace_, name_='ports', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            self.assertions.export(outfile, level, namespace_='ipxact:', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'library':
            library_ = child_.text
            library_ = self.gds_validate_string(library_, node, 'library')
            self.library = library_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'busType':
            obj_ = LibraryRef.factory()
            obj_.build(child_)
            self.busType = obj_
            obj_.original_tagname_ = 'busType'
        elif nodeName_ == 'extends':
            obj_ = LibraryRef.factory()
            obj_.build(child_)
            self.extends = obj_
            obj_.original_tagname_ = 'extends'
        elif nodeName_ == 'ports':
            obj_ = Ports.factory()
            obj_.build(child_)
            self.ports = obj_
            obj_.original_tagname_ = 'ports'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory()
            obj_.build(child_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class abstractionDefinition


class addressBankType(GeneratedsSuper):
    """Top level bank the specify an addressDescribes whether this bank's
    blocks are aligned in 'parallel' or 'serial'."""
    member_data_items_ = [
        MemberSpec_('bankAlignment', 'ipxact:bankAlignmentType', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType42', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType42', 'name': 'accessHandles'}, None),
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 0, {'type': 'baseAddress', 'ref': 'baseAddress', 'name': 'baseAddress'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 0, {'type': 'bankedBlockType', 'name': 'addressBlock'}, 15),
        MemberSpec_('bank', 'addressBankType', 1, 0, {'type': 'bankedBankType', 'name': 'bank'}, 15),
        MemberSpec_('subspaceMap', 'bankedSubspaceType', 1, 0, {'type': 'bankedSubspaceType', 'name': 'subspaceMap'}, 15),
        MemberSpec_('usage', ['usageType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'name': 'usage'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, bankAlignment=None, id=None, name=None, displayName=None, description=None, accessHandles=None, baseAddress=None, isPresent=None, addressBlock=None, bank=None, subspaceMap=None, usage=None, volatile=None, access=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.bankAlignment = _cast(None, bankAlignment)
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.baseAddress = baseAddress
        self.isPresent = isPresent
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        if subspaceMap is None:
            self.subspaceMap = []
        else:
            self.subspaceMap = subspaceMap
        self.usage = usage
        self.validate_usageType(self.usage)
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressBankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressBankType.subclass:
            return addressBankType.subclass(*args_, **kwargs_)
        else:
            return addressBankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_baseAddress(self): return self.baseAddress
    def set_baseAddress(self, baseAddress): self.baseAddress = baseAddress
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressBlock(self): return self.addressBlock
    def set_addressBlock(self, addressBlock): self.addressBlock = addressBlock
    def add_addressBlock(self, value): self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value): self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value): self.addressBlock[index] = value
    def get_bank(self): return self.bank
    def set_bank(self, bank): self.bank = bank
    def add_bank(self, value): self.bank.append(value)
    def insert_bank_at(self, index, value): self.bank.insert(index, value)
    def replace_bank_at(self, index, value): self.bank[index] = value
    def get_subspaceMap(self): return self.subspaceMap
    def set_subspaceMap(self, subspaceMap): self.subspaceMap = subspaceMap
    def add_subspaceMap(self, value): self.subspaceMap.append(value)
    def insert_subspaceMap_at(self, index, value): self.subspaceMap.insert(index, value)
    def replace_subspaceMap_at(self, index, value): self.subspaceMap[index] = value
    def get_usage(self): return self.usage
    def set_usage(self, usage): self.usage = usage
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_bankAlignment(self): return self.bankAlignment
    def set_bankAlignment(self, bankAlignment): self.bankAlignment = bankAlignment
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_usageType(self, value):
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['memory', 'register', 'reserved']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on usageType' % {"value" : value.encode("utf-8")} )
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.baseAddress is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.subspaceMap or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='addressBankType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressBankType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='addressBankType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='addressBankType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='addressBankType'):
        if self.bankAlignment is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            outfile.write(' bankAlignment=%s' % (quote_attrib(self.bankAlignment), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='addressBankType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.baseAddress is not None:
            self.baseAddress.export(outfile, level, namespace_='ipxact:', name_='baseAddress', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            addressBlock_.export(outfile, level, namespace_, name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            bank_.export(outfile, level, namespace_, name_='bank', pretty_print=pretty_print)
        for subspaceMap_ in self.subspaceMap:
            subspaceMap_.export(outfile, level, namespace_, name_='subspaceMap', pretty_print=pretty_print)
        if self.usage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:usage>%s</ipxact:usage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), eol_))
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bankAlignment', node)
        if value is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            self.bankAlignment = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType42.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'baseAddress':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = addressBlockType.factory()
            obj_.build(child_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = addressBankType.factory()
            obj_.build(child_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'subspaceMap':
            obj_ = bankedSubspaceType.factory()
            obj_.build(child_)
            self.subspaceMap.append(obj_)
            obj_.original_tagname_ = 'subspaceMap'
        elif nodeName_ == 'usage':
            usage_ = child_.text
            if usage_:
                usage_ = re_.sub(String_cleanup_pat_, " ", usage_).strip()
            else:
                usage_ = ""
            usage_ = self.gds_validate_string(usage_, node, 'usage')
            self.usage = usage_
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class addressBankType


class localAddressBankType(GeneratedsSuper):
    """Top level bank the specify an addressDescribes whether this bank's
    blocks are aligned in 'parallel' or 'serial'."""
    member_data_items_ = [
        MemberSpec_('bankAlignment', 'ipxact:bankAlignmentType', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType43', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType43', 'name': 'accessHandles'}, None),
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 0, {'type': 'baseAddress', 'ref': 'baseAddress', 'name': 'baseAddress'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 0, {'type': 'bankedBlockType', 'name': 'addressBlock'}, 16),
        MemberSpec_('bank', 'addressBankType', 1, 0, {'type': 'localBankedBankType', 'name': 'bank'}, 16),
        MemberSpec_('usage', ['usageType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'name': 'usage'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, bankAlignment=None, id=None, name=None, displayName=None, description=None, accessHandles=None, baseAddress=None, isPresent=None, addressBlock=None, bank=None, usage=None, volatile=None, access=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.bankAlignment = _cast(None, bankAlignment)
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.baseAddress = baseAddress
        self.isPresent = isPresent
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        self.usage = usage
        self.validate_usageType(self.usage)
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, localAddressBankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if localAddressBankType.subclass:
            return localAddressBankType.subclass(*args_, **kwargs_)
        else:
            return localAddressBankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_baseAddress(self): return self.baseAddress
    def set_baseAddress(self, baseAddress): self.baseAddress = baseAddress
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressBlock(self): return self.addressBlock
    def set_addressBlock(self, addressBlock): self.addressBlock = addressBlock
    def add_addressBlock(self, value): self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value): self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value): self.addressBlock[index] = value
    def get_bank(self): return self.bank
    def set_bank(self, bank): self.bank = bank
    def add_bank(self, value): self.bank.append(value)
    def insert_bank_at(self, index, value): self.bank.insert(index, value)
    def replace_bank_at(self, index, value): self.bank[index] = value
    def get_usage(self): return self.usage
    def set_usage(self, usage): self.usage = usage
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_bankAlignment(self): return self.bankAlignment
    def set_bankAlignment(self, bankAlignment): self.bankAlignment = bankAlignment
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_usageType(self, value):
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['memory', 'register', 'reserved']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on usageType' % {"value" : value.encode("utf-8")} )
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.baseAddress is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='localAddressBankType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('localAddressBankType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='localAddressBankType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='localAddressBankType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='localAddressBankType'):
        if self.bankAlignment is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            outfile.write(' bankAlignment=%s' % (quote_attrib(self.bankAlignment), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='localAddressBankType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.baseAddress is not None:
            self.baseAddress.export(outfile, level, namespace_='ipxact:', name_='baseAddress', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            addressBlock_.export(outfile, level, namespace_, name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            bank_.export(outfile, level, namespace_, name_='bank', pretty_print=pretty_print)
        if self.usage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:usage>%s</ipxact:usage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), eol_))
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bankAlignment', node)
        if value is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            self.bankAlignment = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType43.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'baseAddress':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = addressBlockType.factory()
            obj_.build(child_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = addressBankType.factory()
            obj_.build(child_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'usage':
            usage_ = child_.text
            if usage_:
                usage_ = re_.sub(String_cleanup_pat_, " ", usage_).strip()
            else:
                usage_ = ""
            usage_ = self.gds_validate_string(usage_, node, 'usage')
            self.usage = usage_
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class localAddressBankType


class addressBlockType(GeneratedsSuper):
    """Top level address block that specify an address"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType44', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType44', 'name': 'accessHandles'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 0, {'type': 'baseAddress', 'ref': 'baseAddress', 'name': 'baseAddress'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'typeIdentifier'}, None),
        MemberSpec_('addressRange', 'unsignedPositiveLongintExpression', 0, 0, {'type': 'addressRange', 'ref': 'addressRange', 'name': 'addressRange'}, None),
        MemberSpec_('width', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'name': 'width'}, None),
        MemberSpec_('usage', ['usageType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'name': 'usage'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('register', 'registerType50', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'register', 'type': 'registerType50'}, 23),
        MemberSpec_('registerFile', 'registerFile', 0, 0, {'type': 'registerFile', 'ref': 'registerFile', 'name': 'registerFile'}, 23),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, baseAddress=None, typeIdentifier=None, addressRange=None, width=None, usage=None, volatile=None, access=None, parameters=None, register=None, registerFile=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.isPresent = isPresent
        self.baseAddress = baseAddress
        self.typeIdentifier = typeIdentifier
        self.addressRange = addressRange
        self.width = width
        self.usage = usage
        self.validate_usageType(self.usage)
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        self.parameters = parameters
        if register is None:
            self.register = []
        else:
            self.register = register
        self.registerFile = registerFile
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressBlockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressBlockType.subclass:
            return addressBlockType.subclass(*args_, **kwargs_)
        else:
            return addressBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_baseAddress(self): return self.baseAddress
    def set_baseAddress(self, baseAddress): self.baseAddress = baseAddress
    def get_typeIdentifier(self): return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier): self.typeIdentifier = typeIdentifier
    def get_addressRange(self): return self.addressRange
    def set_addressRange(self, addressRange): self.addressRange = addressRange
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_usage(self): return self.usage
    def set_usage(self, usage): self.usage = usage
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_register(self): return self.register
    def set_register(self, register): self.register = register
    def add_register(self, value): self.register.append(value)
    def insert_register_at(self, index, value): self.register.insert(index, value)
    def replace_register_at(self, index, value): self.register[index] = value
    def get_registerFile(self): return self.registerFile
    def set_registerFile(self, registerFile): self.registerFile = registerFile
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_usageType(self, value):
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['memory', 'register', 'reserved']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on usageType' % {"value" : value.encode("utf-8")} )
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.baseAddress is not None or
            self.typeIdentifier is not None or
            self.addressRange is not None or
            self.width is not None or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.register or
            self.registerFile is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='addressBlockType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressBlockType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='addressBlockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='addressBlockType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='addressBlockType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='addressBlockType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.baseAddress is not None:
            self.baseAddress.export(outfile, level, namespace_='ipxact:', name_='baseAddress', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:typeIdentifier>%s</ipxact:typeIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), eol_))
        if self.addressRange is not None:
            self.addressRange.export(outfile, level, namespace_, name_='addressRange', pretty_print=pretty_print)
        if self.width is not None:
            self.width.export(outfile, level, namespace_, name_='width', pretty_print=pretty_print)
        if self.usage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:usage>%s</ipxact:usage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), eol_))
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        for register_ in self.register:
            register_.export(outfile, level, namespace_, name_='register', pretty_print=pretty_print)
        if self.registerFile is not None:
            self.registerFile.export(outfile, level, namespace_='ipxact:', name_='registerFile', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType44.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'baseAddress':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        elif nodeName_ == 'typeIdentifier':
            typeIdentifier_ = child_.text
            typeIdentifier_ = self.gds_validate_string(typeIdentifier_, node, 'typeIdentifier')
            self.typeIdentifier = typeIdentifier_
        elif nodeName_ == 'addressRange':
            obj_ = unsignedPositiveLongintExpression.factory()
            obj_.build(child_)
            self.addressRange = obj_
            obj_.original_tagname_ = 'addressRange'
        elif nodeName_ == 'width':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'usage':
            usage_ = child_.text
            if usage_:
                usage_ = re_.sub(String_cleanup_pat_, " ", usage_).strip()
            else:
                usage_ = ""
            usage_ = self.gds_validate_string(usage_, node, 'usage')
            self.usage = usage_
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'register':
            obj_ = registerType50.factory()
            obj_.build(child_)
            self.register.append(obj_)
            obj_.original_tagname_ = 'register'
        elif nodeName_ == 'registerFile':
            obj_ = registerFile.factory()
            obj_.build(child_)
            self.registerFile = obj_
            obj_.original_tagname_ = 'registerFile'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class addressBlockType


class addrSpaceRefType(GeneratedsSuper):
    """Base type for an element which references an address space.
    Reference is kept in an attribute rather than the text value, so
    that the type may be extended with child elements if necessary.A
    reference to a unique address space."""
    member_data_items_ = [
        MemberSpec_('addressSpaceRef', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, addressSpaceRef=None, id=None, isPresent=None, extensiontype_=None):
        self.original_tagname_ = None
        self.addressSpaceRef = _cast(None, addressSpaceRef)
        self.id = _cast(None, id)
        self.isPresent = isPresent
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addrSpaceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addrSpaceRefType.subclass:
            return addrSpaceRefType.subclass(*args_, **kwargs_)
        else:
            return addrSpaceRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressSpaceRef(self): return self.addressSpaceRef
    def set_addressSpaceRef(self, addressSpaceRef): self.addressSpaceRef = addressSpaceRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='addrSpaceRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addrSpaceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='addrSpaceRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='addrSpaceRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='addrSpaceRefType'):
        if self.addressSpaceRef is not None and 'addressSpaceRef' not in already_processed:
            already_processed.add('addressSpaceRef')
            outfile.write(' addressSpaceRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.addressSpaceRef), input_name='addressSpaceRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='addrSpaceRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('addressSpaceRef', node)
        if value is not None and 'addressSpaceRef' not in already_processed:
            already_processed.add('addressSpaceRef')
            self.addressSpaceRef = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class addrSpaceRefType


class memoryMapRefType(GeneratedsSuper):
    """Base type for an element which references an memory map. Reference
    is kept in an attribute rather than the text value, so that the
    type may be extended with child elements if necessary.A
    reference to a unique memory map."""
    member_data_items_ = [
        MemberSpec_('memoryMapRef', 'xs:Name', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = None
    def __init__(self, memoryMapRef=None):
        self.original_tagname_ = None
        self.memoryMapRef = _cast(None, memoryMapRef)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, memoryMapRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if memoryMapRefType.subclass:
            return memoryMapRefType.subclass(*args_, **kwargs_)
        else:
            return memoryMapRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_memoryMapRef(self): return self.memoryMapRef
    def set_memoryMapRef(self, memoryMapRef): self.memoryMapRef = memoryMapRef
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='memoryMapRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memoryMapRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='memoryMapRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='memoryMapRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='memoryMapRefType'):
        if self.memoryMapRef is not None and 'memoryMapRef' not in already_processed:
            already_processed.add('memoryMapRef')
            outfile.write(' memoryMapRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.memoryMapRef), input_name='memoryMapRef')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='memoryMapRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('memoryMapRef', node)
        if value is not None and 'memoryMapRef' not in already_processed:
            already_processed.add('memoryMapRef')
            self.memoryMapRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class memoryMapRefType


class bankedBankType(GeneratedsSuper):
    """Banks nested inside a bank do not specify address."""
    member_data_items_ = [
        MemberSpec_('bankAlignment', 'ipxact:bankAlignmentType', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType45', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType45', 'name': 'accessHandles'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 0, {'type': 'bankedBlockType', 'name': 'addressBlock'}, 17),
        MemberSpec_('bank', 'addressBankType', 1, 0, {'type': 'bankedBankType', 'name': 'bank'}, 17),
        MemberSpec_('subspaceMap', 'bankedSubspaceType', 1, 0, {'type': 'bankedSubspaceType', 'name': 'subspaceMap'}, 17),
        MemberSpec_('usage', ['usageType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'name': 'usage'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, bankAlignment=None, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, addressBlock=None, bank=None, subspaceMap=None, usage=None, volatile=None, access=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.bankAlignment = _cast(None, bankAlignment)
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.isPresent = isPresent
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        if subspaceMap is None:
            self.subspaceMap = []
        else:
            self.subspaceMap = subspaceMap
        self.usage = usage
        self.validate_usageType(self.usage)
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bankedBankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bankedBankType.subclass:
            return bankedBankType.subclass(*args_, **kwargs_)
        else:
            return bankedBankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressBlock(self): return self.addressBlock
    def set_addressBlock(self, addressBlock): self.addressBlock = addressBlock
    def add_addressBlock(self, value): self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value): self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value): self.addressBlock[index] = value
    def get_bank(self): return self.bank
    def set_bank(self, bank): self.bank = bank
    def add_bank(self, value): self.bank.append(value)
    def insert_bank_at(self, index, value): self.bank.insert(index, value)
    def replace_bank_at(self, index, value): self.bank[index] = value
    def get_subspaceMap(self): return self.subspaceMap
    def set_subspaceMap(self, subspaceMap): self.subspaceMap = subspaceMap
    def add_subspaceMap(self, value): self.subspaceMap.append(value)
    def insert_subspaceMap_at(self, index, value): self.subspaceMap.insert(index, value)
    def replace_subspaceMap_at(self, index, value): self.subspaceMap[index] = value
    def get_usage(self): return self.usage
    def set_usage(self, usage): self.usage = usage
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_bankAlignment(self): return self.bankAlignment
    def set_bankAlignment(self, bankAlignment): self.bankAlignment = bankAlignment
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_usageType(self, value):
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['memory', 'register', 'reserved']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on usageType' % {"value" : value.encode("utf-8")} )
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.subspaceMap or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='bankedBankType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bankedBankType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bankedBankType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='bankedBankType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='bankedBankType'):
        if self.bankAlignment is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            outfile.write(' bankAlignment=%s' % (quote_attrib(self.bankAlignment), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='bankedBankType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            addressBlock_.export(outfile, level, namespace_, name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            bank_.export(outfile, level, namespace_, name_='bank', pretty_print=pretty_print)
        for subspaceMap_ in self.subspaceMap:
            subspaceMap_.export(outfile, level, namespace_, name_='subspaceMap', pretty_print=pretty_print)
        if self.usage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:usage>%s</ipxact:usage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), eol_))
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bankAlignment', node)
        if value is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            self.bankAlignment = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType45.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = addressBlockType.factory()
            obj_.build(child_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = addressBankType.factory()
            obj_.build(child_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'subspaceMap':
            obj_ = bankedSubspaceType.factory()
            obj_.build(child_)
            self.subspaceMap.append(obj_)
            obj_.original_tagname_ = 'subspaceMap'
        elif nodeName_ == 'usage':
            usage_ = child_.text
            if usage_:
                usage_ = re_.sub(String_cleanup_pat_, " ", usage_).strip()
            else:
                usage_ = ""
            usage_ = self.gds_validate_string(usage_, node, 'usage')
            self.usage = usage_
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class bankedBankType


class localBankedBankType(GeneratedsSuper):
    """Banks nested inside a bank do not specify address."""
    member_data_items_ = [
        MemberSpec_('bankAlignment', 'ipxact:bankAlignmentType', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType46', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType46', 'name': 'accessHandles'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 0, {'type': 'bankedBlockType', 'name': 'addressBlock'}, 18),
        MemberSpec_('bank', 'addressBankType', 1, 0, {'type': 'localBankedBankType', 'name': 'bank'}, 18),
        MemberSpec_('usage', ['usageType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'name': 'usage'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, bankAlignment=None, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, addressBlock=None, bank=None, usage=None, volatile=None, access=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.bankAlignment = _cast(None, bankAlignment)
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.isPresent = isPresent
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        self.usage = usage
        self.validate_usageType(self.usage)
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, localBankedBankType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if localBankedBankType.subclass:
            return localBankedBankType.subclass(*args_, **kwargs_)
        else:
            return localBankedBankType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressBlock(self): return self.addressBlock
    def set_addressBlock(self, addressBlock): self.addressBlock = addressBlock
    def add_addressBlock(self, value): self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value): self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value): self.addressBlock[index] = value
    def get_bank(self): return self.bank
    def set_bank(self, bank): self.bank = bank
    def add_bank(self, value): self.bank.append(value)
    def insert_bank_at(self, index, value): self.bank.insert(index, value)
    def replace_bank_at(self, index, value): self.bank[index] = value
    def get_usage(self): return self.usage
    def set_usage(self, usage): self.usage = usage
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_bankAlignment(self): return self.bankAlignment
    def set_bankAlignment(self, bankAlignment): self.bankAlignment = bankAlignment
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_usageType(self, value):
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['memory', 'register', 'reserved']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on usageType' % {"value" : value.encode("utf-8")} )
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='localBankedBankType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('localBankedBankType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='localBankedBankType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='localBankedBankType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='localBankedBankType'):
        if self.bankAlignment is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            outfile.write(' bankAlignment=%s' % (quote_attrib(self.bankAlignment), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='localBankedBankType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            addressBlock_.export(outfile, level, namespace_, name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            bank_.export(outfile, level, namespace_, name_='bank', pretty_print=pretty_print)
        if self.usage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:usage>%s</ipxact:usage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), eol_))
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('bankAlignment', node)
        if value is not None and 'bankAlignment' not in already_processed:
            already_processed.add('bankAlignment')
            self.bankAlignment = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType46.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = addressBlockType.factory()
            obj_.build(child_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = addressBankType.factory()
            obj_.build(child_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'usage':
            usage_ = child_.text
            if usage_:
                usage_ = re_.sub(String_cleanup_pat_, " ", usage_).strip()
            else:
                usage_ = ""
            usage_ = self.gds_validate_string(usage_, node, 'usage')
            self.usage = usage_
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class localBankedBankType


class bankedBlockType(GeneratedsSuper):
    """Address blocks inside a bank do not specify address."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType47', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType47', 'name': 'accessHandles'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('addressRange', 'unsignedPositiveLongintExpression', 0, 0, {'type': 'addressRange', 'ref': 'addressRange', 'name': 'addressRange'}, None),
        MemberSpec_('width', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'name': 'width'}, None),
        MemberSpec_('usage', ['usageType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'name': 'usage'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('register', 'registerType50', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'register', 'type': 'registerType50'}, 23),
        MemberSpec_('registerFile', 'registerFile', 0, 0, {'type': 'registerFile', 'ref': 'registerFile', 'name': 'registerFile'}, 23),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, addressRange=None, width=None, usage=None, volatile=None, access=None, parameters=None, register=None, registerFile=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.isPresent = isPresent
        self.addressRange = addressRange
        self.width = width
        self.usage = usage
        self.validate_usageType(self.usage)
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        self.parameters = parameters
        if register is None:
            self.register = []
        else:
            self.register = register
        self.registerFile = registerFile
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bankedBlockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bankedBlockType.subclass:
            return bankedBlockType.subclass(*args_, **kwargs_)
        else:
            return bankedBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressRange(self): return self.addressRange
    def set_addressRange(self, addressRange): self.addressRange = addressRange
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_usage(self): return self.usage
    def set_usage(self, usage): self.usage = usage
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_register(self): return self.register
    def set_register(self, register): self.register = register
    def add_register(self, value): self.register.append(value)
    def insert_register_at(self, index, value): self.register.insert(index, value)
    def replace_register_at(self, index, value): self.register[index] = value
    def get_registerFile(self): return self.registerFile
    def set_registerFile(self, registerFile): self.registerFile = registerFile
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_usageType(self, value):
        # Validate type usageType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['memory', 'register', 'reserved']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on usageType' % {"value" : value.encode("utf-8")} )
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.addressRange is not None or
            self.width is not None or
            self.usage is not None or
            self.volatile is not None or
            self.access is not None or
            self.parameters is not None or
            self.register or
            self.registerFile is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='bankedBlockType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bankedBlockType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bankedBlockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='bankedBlockType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='bankedBlockType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='bankedBlockType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.addressRange is not None:
            self.addressRange.export(outfile, level, namespace_, name_='addressRange', pretty_print=pretty_print)
        if self.width is not None:
            self.width.export(outfile, level, namespace_, name_='width', pretty_print=pretty_print)
        if self.usage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:usage>%s</ipxact:usage>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.usage), input_name='usage')), eol_))
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        for register_ in self.register:
            register_.export(outfile, level, namespace_, name_='register', pretty_print=pretty_print)
        if self.registerFile is not None:
            self.registerFile.export(outfile, level, namespace_='ipxact:', name_='registerFile', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType47.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressRange':
            obj_ = unsignedPositiveLongintExpression.factory()
            obj_.build(child_)
            self.addressRange = obj_
            obj_.original_tagname_ = 'addressRange'
        elif nodeName_ == 'width':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'usage':
            usage_ = child_.text
            if usage_:
                usage_ = re_.sub(String_cleanup_pat_, " ", usage_).strip()
            else:
                usage_ = ""
            usage_ = self.gds_validate_string(usage_, node, 'usage')
            self.usage = usage_
            # validate type usageType
            self.validate_usageType(self.usage)
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'register':
            obj_ = registerType50.factory()
            obj_.build(child_)
            self.register.append(obj_)
            obj_.original_tagname_ = 'register'
        elif nodeName_ == 'registerFile':
            obj_ = registerFile.factory()
            obj_.build(child_)
            self.registerFile = obj_
            obj_.original_tagname_ = 'registerFile'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class bankedBlockType


class bankedSubspaceType(GeneratedsSuper):
    """Subspace references inside banks do not specify an address.For
    subspaceMap elements, this attribute identifies the master that
    contains the address space to be mapped."""
    member_data_items_ = [
        MemberSpec_('masterRef', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, masterRef=None, id=None, name=None, displayName=None, description=None, isPresent=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.masterRef = _cast(None, masterRef)
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, bankedSubspaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if bankedSubspaceType.subclass:
            return bankedSubspaceType.subclass(*args_, **kwargs_)
        else:
            return bankedSubspaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_masterRef(self): return self.masterRef
    def set_masterRef(self, masterRef): self.masterRef = masterRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='bankedSubspaceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('bankedSubspaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='bankedSubspaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='bankedSubspaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='bankedSubspaceType'):
        if self.masterRef is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            outfile.write(' masterRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.masterRef), input_name='masterRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='bankedSubspaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterRef', node)
        if value is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            self.masterRef = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class bankedSubspaceType


class fieldType(GeneratedsSuper):
    """A field within a registerA unique identifier within a component for
    a field."""
    member_data_items_ = [
        MemberSpec_('fieldID', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType48', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType48', 'name': 'accessHandles'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('bitOffset', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'name': 'bitOffset'}, None),
        MemberSpec_('resets', 'resetsType', 0, 1, {'minOccurs': '0', 'type': 'resetsType', 'name': 'resets'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'typeIdentifier'}, None),
        MemberSpec_('bitWidth', 'unsignedPositiveIntExpression', 0, 0, {'type': 'unsignedPositiveIntExpression', 'name': 'bitWidth'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('enumeratedValues', 'enumeratedValues', 0, 1, {'minOccurs': '0', 'type': 'enumeratedValues', 'ref': 'enumeratedValues', 'name': 'enumeratedValues'}, None),
        MemberSpec_('modifiedWriteValue', 'modifiedWriteValueType54', 0, 1, {'minOccurs': '0', 'type': 'modifiedWriteValueType54', 'name': 'modifiedWriteValue'}, None),
        MemberSpec_('writeValueConstraint', 'writeValueConstraintType', 0, 1, {'minOccurs': '0', 'type': 'writeValueConstraintType', 'name': 'writeValueConstraint'}, None),
        MemberSpec_('readAction', 'readActionType55', 0, 1, {'minOccurs': '0', 'type': 'readActionType55', 'name': 'readAction'}, None),
        MemberSpec_('testable', 'testableType', 0, 1, {'minOccurs': '0', 'type': 'testableType', 'name': 'testable'}, None),
        MemberSpec_('reserved', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'default': 'false', 'name': 'reserved'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, fieldID=None, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, bitOffset=None, resets=None, typeIdentifier=None, bitWidth=None, volatile=None, access=None, enumeratedValues=None, modifiedWriteValue=None, writeValueConstraint=None, readAction=None, testable=None, reserved=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.fieldID = _cast(None, fieldID)
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.isPresent = isPresent
        self.bitOffset = bitOffset
        self.resets = resets
        self.typeIdentifier = typeIdentifier
        self.bitWidth = bitWidth
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        self.enumeratedValues = enumeratedValues
        self.modifiedWriteValue = modifiedWriteValue
        self.writeValueConstraint = writeValueConstraint
        self.readAction = readAction
        self.testable = testable
        if reserved is None:
            self.reserved = globals()['unsignedBitExpression']('false')
        else:
            self.reserved = reserved
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fieldType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fieldType.subclass:
            return fieldType.subclass(*args_, **kwargs_)
        else:
            return fieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_bitOffset(self): return self.bitOffset
    def set_bitOffset(self, bitOffset): self.bitOffset = bitOffset
    def get_resets(self): return self.resets
    def set_resets(self, resets): self.resets = resets
    def get_typeIdentifier(self): return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier): self.typeIdentifier = typeIdentifier
    def get_bitWidth(self): return self.bitWidth
    def set_bitWidth(self, bitWidth): self.bitWidth = bitWidth
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_enumeratedValues(self): return self.enumeratedValues
    def set_enumeratedValues(self, enumeratedValues): self.enumeratedValues = enumeratedValues
    def get_modifiedWriteValue(self): return self.modifiedWriteValue
    def set_modifiedWriteValue(self, modifiedWriteValue): self.modifiedWriteValue = modifiedWriteValue
    def get_writeValueConstraint(self): return self.writeValueConstraint
    def set_writeValueConstraint(self, writeValueConstraint): self.writeValueConstraint = writeValueConstraint
    def get_readAction(self): return self.readAction
    def set_readAction(self, readAction): self.readAction = readAction
    def get_testable(self): return self.testable
    def set_testable(self, testable): self.testable = testable
    def get_reserved(self): return self.reserved
    def set_reserved(self, reserved): self.reserved = reserved
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_fieldID(self): return self.fieldID
    def set_fieldID(self, fieldID): self.fieldID = fieldID
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.bitOffset is not None or
            self.resets is not None or
            self.typeIdentifier is not None or
            self.bitWidth is not None or
            self.volatile is not None or
            self.access is not None or
            self.enumeratedValues is not None or
            self.modifiedWriteValue is not None or
            self.writeValueConstraint is not None or
            self.readAction is not None or
            self.testable is not None or
            self.reserved != false or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='fieldType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fieldType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fieldType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='fieldType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='fieldType'):
        if self.fieldID is not None and 'fieldID' not in already_processed:
            already_processed.add('fieldID')
            outfile.write(' fieldID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fieldID), input_name='fieldID')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='fieldType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.bitOffset is not None:
            self.bitOffset.export(outfile, level, namespace_, name_='bitOffset', pretty_print=pretty_print)
        if self.resets is not None:
            self.resets.export(outfile, level, namespace_, name_='resets', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:typeIdentifier>%s</ipxact:typeIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), eol_))
        if self.bitWidth is not None:
            self.bitWidth.export(outfile, level, namespace_, name_='bitWidth', pretty_print=pretty_print)
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        if self.enumeratedValues is not None:
            self.enumeratedValues.export(outfile, level, namespace_='ipxact:', name_='enumeratedValues', pretty_print=pretty_print)
        if self.modifiedWriteValue is not None:
            self.modifiedWriteValue.export(outfile, level, namespace_, name_='modifiedWriteValue', pretty_print=pretty_print)
        if self.writeValueConstraint is not None:
            self.writeValueConstraint.export(outfile, level, namespace_, name_='writeValueConstraint', pretty_print=pretty_print)
        if self.readAction is not None:
            self.readAction.export(outfile, level, namespace_, name_='readAction', pretty_print=pretty_print)
        if self.testable is not None:
            self.testable.export(outfile, level, namespace_, name_='testable', pretty_print=pretty_print)
        if self.reserved is not None:
            self.reserved.export(outfile, level, namespace_, name_='reserved', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fieldID', node)
        if value is not None and 'fieldID' not in already_processed:
            already_processed.add('fieldID')
            self.fieldID = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType48.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'bitOffset':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.bitOffset = obj_
            obj_.original_tagname_ = 'bitOffset'
        elif nodeName_ == 'resets':
            obj_ = resetsType.factory()
            obj_.build(child_)
            self.resets = obj_
            obj_.original_tagname_ = 'resets'
        elif nodeName_ == 'typeIdentifier':
            typeIdentifier_ = child_.text
            typeIdentifier_ = self.gds_validate_string(typeIdentifier_, node, 'typeIdentifier')
            self.typeIdentifier = typeIdentifier_
        elif nodeName_ == 'bitWidth':
            obj_ = unsignedPositiveIntExpression.factory()
            obj_.build(child_)
            self.bitWidth = obj_
            obj_.original_tagname_ = 'bitWidth'
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'enumeratedValues':
            obj_ = enumeratedValues.factory()
            obj_.build(child_)
            self.enumeratedValues = obj_
            obj_.original_tagname_ = 'enumeratedValues'
        elif nodeName_ == 'modifiedWriteValue':
            obj_ = modifiedWriteValueType54.factory()
            obj_.build(child_)
            self.modifiedWriteValue = obj_
            obj_.original_tagname_ = 'modifiedWriteValue'
        elif nodeName_ == 'writeValueConstraint':
            obj_ = writeValueConstraintType.factory()
            obj_.build(child_)
            self.writeValueConstraint = obj_
            obj_.original_tagname_ = 'writeValueConstraint'
        elif nodeName_ == 'readAction':
            obj_ = readActionType55.factory()
            obj_.build(child_)
            self.readAction = obj_
            obj_.original_tagname_ = 'readAction'
        elif nodeName_ == 'testable':
            obj_ = testableType.factory()
            obj_.build(child_)
            self.testable = obj_
            obj_.original_tagname_ = 'testable'
        elif nodeName_ == 'reserved':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.reserved = obj_
            obj_.original_tagname_ = 'reserved'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class fieldType


class memoryMapType(GeneratedsSuper):
    """Map of address space blocks on slave slave bus interface."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'addressBlock', 'name': 'addressBlock', 'type': 'bankedBlockType'}, None),
        MemberSpec_('bank', 'addressBankType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'bank', 'name': 'bank', 'type': 'localBankedBankType'}, None),
        MemberSpec_('subspaceMap', 'subspaceRefType', 1, 1, {'minOccurs': '0', 'type': 'subspaceRefType', 'name': 'subspaceMap', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('memoryRemap', 'memoryRemapType', 1, 1, {'minOccurs': '0', 'type': 'memoryRemapType', 'name': 'memoryRemap', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('addressUnitBits', 'unsignedPositiveLongintExpression', 0, 1, {'minOccurs': '0', 'type': 'addressUnitBits', 'ref': 'addressUnitBits', 'name': 'addressUnitBits'}, None),
        MemberSpec_('shared', ['sharedType', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'name': 'shared'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, addressBlock=None, bank=None, subspaceMap=None, memoryRemap=None, addressUnitBits=None, shared=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        if subspaceMap is None:
            self.subspaceMap = []
        else:
            self.subspaceMap = subspaceMap
        if memoryRemap is None:
            self.memoryRemap = []
        else:
            self.memoryRemap = memoryRemap
        self.addressUnitBits = addressUnitBits
        self.shared = shared
        self.validate_sharedType(self.shared)
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, memoryMapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if memoryMapType.subclass:
            return memoryMapType.subclass(*args_, **kwargs_)
        else:
            return memoryMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressBlock(self): return self.addressBlock
    def set_addressBlock(self, addressBlock): self.addressBlock = addressBlock
    def add_addressBlock(self, value): self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value): self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value): self.addressBlock[index] = value
    def get_bank(self): return self.bank
    def set_bank(self, bank): self.bank = bank
    def add_bank(self, value): self.bank.append(value)
    def insert_bank_at(self, index, value): self.bank.insert(index, value)
    def replace_bank_at(self, index, value): self.bank[index] = value
    def get_subspaceMap(self): return self.subspaceMap
    def set_subspaceMap(self, subspaceMap): self.subspaceMap = subspaceMap
    def add_subspaceMap(self, value): self.subspaceMap.append(value)
    def insert_subspaceMap_at(self, index, value): self.subspaceMap.insert(index, value)
    def replace_subspaceMap_at(self, index, value): self.subspaceMap[index] = value
    def get_memoryRemap(self): return self.memoryRemap
    def set_memoryRemap(self, memoryRemap): self.memoryRemap = memoryRemap
    def add_memoryRemap(self, value): self.memoryRemap.append(value)
    def insert_memoryRemap_at(self, index, value): self.memoryRemap.insert(index, value)
    def replace_memoryRemap_at(self, index, value): self.memoryRemap[index] = value
    def get_addressUnitBits(self): return self.addressUnitBits
    def set_addressUnitBits(self, addressUnitBits): self.addressUnitBits = addressUnitBits
    def get_shared(self): return self.shared
    def set_shared(self, shared): self.shared = shared
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_sharedType(self, value):
        # Validate type sharedType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['yes', 'no', 'undefined']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on sharedType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.subspaceMap or
            self.memoryRemap or
            self.addressUnitBits is not None or
            self.shared is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='memoryMapType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memoryMapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='memoryMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='memoryMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='memoryMapType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='memoryMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            addressBlock_.export(outfile, level, namespace_='ipxact:', name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            bank_.export(outfile, level, namespace_='ipxact:', name_='bank', pretty_print=pretty_print)
        for subspaceMap_ in self.subspaceMap:
            subspaceMap_.export(outfile, level, namespace_, name_='subspaceMap', pretty_print=pretty_print)
        for memoryRemap_ in self.memoryRemap:
            memoryRemap_.export(outfile, level, namespace_, name_='memoryRemap', pretty_print=pretty_print)
        if self.addressUnitBits is not None:
            self.addressUnitBits.export(outfile, level, namespace_='ipxact:', name_='addressUnitBits', pretty_print=pretty_print)
        if self.shared is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:shared>%s</ipxact:shared>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.shared), input_name='shared')), eol_))
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = addressBlockType.factory()
            obj_.build(child_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = addressBankType.factory()
            obj_.build(child_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'subspaceMap':
            obj_ = subspaceRefType.factory()
            obj_.build(child_)
            self.subspaceMap.append(obj_)
            obj_.original_tagname_ = 'subspaceMap'
        elif nodeName_ == 'memoryRemap':
            obj_ = memoryRemapType.factory()
            obj_.build(child_)
            self.memoryRemap.append(obj_)
            obj_.original_tagname_ = 'memoryRemap'
        elif nodeName_ == 'addressUnitBits':
            obj_ = unsignedPositiveLongintExpression.factory()
            obj_.build(child_)
            self.addressUnitBits = obj_
            obj_.original_tagname_ = 'addressUnitBits'
        elif nodeName_ == 'shared':
            shared_ = child_.text
            if shared_:
                shared_ = re_.sub(String_cleanup_pat_, " ", shared_).strip()
            else:
                shared_ = ""
            shared_ = self.gds_validate_string(shared_, node, 'shared')
            self.shared = shared_
            # validate type sharedType
            self.validate_sharedType(self.shared)
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class memoryMapType


class memoryRemapType(GeneratedsSuper):
    """Map of address space blocks on a slave bus interface in a specific
    remap state.State of the component in which the memory map is
    active."""
    member_data_items_ = [
        MemberSpec_('state', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'addressBlock', 'name': 'addressBlock', 'type': 'bankedBlockType'}, None),
        MemberSpec_('bank', 'addressBankType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'bank', 'name': 'bank', 'type': 'localBankedBankType'}, None),
        MemberSpec_('subspaceMap', 'subspaceRefType', 1, 1, {'minOccurs': '0', 'type': 'subspaceRefType', 'name': 'subspaceMap', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, state=None, id=None, name=None, displayName=None, description=None, isPresent=None, addressBlock=None, bank=None, subspaceMap=None):
        self.original_tagname_ = None
        self.state = _cast(None, state)
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
        if subspaceMap is None:
            self.subspaceMap = []
        else:
            self.subspaceMap = subspaceMap
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, memoryRemapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if memoryRemapType.subclass:
            return memoryRemapType.subclass(*args_, **kwargs_)
        else:
            return memoryRemapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressBlock(self): return self.addressBlock
    def set_addressBlock(self, addressBlock): self.addressBlock = addressBlock
    def add_addressBlock(self, value): self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value): self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value): self.addressBlock[index] = value
    def get_bank(self): return self.bank
    def set_bank(self, bank): self.bank = bank
    def add_bank(self, value): self.bank.append(value)
    def insert_bank_at(self, index, value): self.bank.insert(index, value)
    def replace_bank_at(self, index, value): self.bank[index] = value
    def get_subspaceMap(self): return self.subspaceMap
    def set_subspaceMap(self, subspaceMap): self.subspaceMap = subspaceMap
    def add_subspaceMap(self, value): self.subspaceMap.append(value)
    def insert_subspaceMap_at(self, index, value): self.subspaceMap.insert(index, value)
    def replace_subspaceMap_at(self, index, value): self.subspaceMap[index] = value
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank or
            self.subspaceMap
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='memoryRemapType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memoryRemapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='memoryRemapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='memoryRemapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='memoryRemapType'):
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='memoryRemapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            addressBlock_.export(outfile, level, namespace_='ipxact:', name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            bank_.export(outfile, level, namespace_='ipxact:', name_='bank', pretty_print=pretty_print)
        for subspaceMap_ in self.subspaceMap:
            subspaceMap_.export(outfile, level, namespace_, name_='subspaceMap', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = addressBlockType.factory()
            obj_.build(child_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = addressBankType.factory()
            obj_.build(child_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
        elif nodeName_ == 'subspaceMap':
            obj_ = subspaceRefType.factory()
            obj_.build(child_)
            self.subspaceMap.append(obj_)
            obj_.original_tagname_ = 'subspaceMap'
# end class memoryRemapType


class localMemoryMapType(GeneratedsSuper):
    """Map of address space blocks on the local memory map of a master bus
    interface."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('addressBlock', 'addressBlockType', 1, 1, {'type': 'bankedBlockType', 'ref': 'addressBlock', 'name': 'addressBlock'}, 20),
        MemberSpec_('bank', 'addressBankType', 1, 1, {'type': 'localAddressBankType', 'name': 'bank'}, 20),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, addressBlock=None, bank=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        if addressBlock is None:
            self.addressBlock = []
        else:
            self.addressBlock = addressBlock
        if bank is None:
            self.bank = []
        else:
            self.bank = bank
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, localMemoryMapType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if localMemoryMapType.subclass:
            return localMemoryMapType.subclass(*args_, **kwargs_)
        else:
            return localMemoryMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressBlock(self): return self.addressBlock
    def set_addressBlock(self, addressBlock): self.addressBlock = addressBlock
    def add_addressBlock(self, value): self.addressBlock.append(value)
    def insert_addressBlock_at(self, index, value): self.addressBlock.insert(index, value)
    def replace_addressBlock_at(self, index, value): self.addressBlock[index] = value
    def get_bank(self): return self.bank
    def set_bank(self, bank): self.bank = bank
    def add_bank(self, value): self.bank.append(value)
    def insert_bank_at(self, index, value): self.bank.insert(index, value)
    def replace_bank_at(self, index, value): self.bank[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.addressBlock or
            self.bank
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='localMemoryMapType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('localMemoryMapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='localMemoryMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='localMemoryMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='localMemoryMapType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='localMemoryMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for addressBlock_ in self.addressBlock:
            addressBlock_.export(outfile, level, namespace_='ipxact:', name_='addressBlock', pretty_print=pretty_print)
        for bank_ in self.bank:
            bank_.export(outfile, level, namespace_, name_='bank', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressBlock':
            obj_ = addressBlockType.factory()
            obj_.build(child_)
            self.addressBlock.append(obj_)
            obj_.original_tagname_ = 'addressBlock'
        elif nodeName_ == 'bank':
            obj_ = addressBankType.factory()
            obj_.build(child_)
            self.bank.append(obj_)
            obj_.original_tagname_ = 'bank'
# end class localMemoryMapType


class subspaceRefType(GeneratedsSuper):
    """Address subspace type. Its subspaceReference attribute references
    the subspace from which the dimensions are taken.Any parameters
    that may apply to the subspace reference.For subspaceMap
    elements, this attribute identifies the master that contains the
    address space to be mapped.Refernce to a segment of the
    addressSpace of the masterRef attribute."""
    member_data_items_ = [
        MemberSpec_('masterRef', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('segmentRef', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 0, {'type': 'baseAddress', 'ref': 'baseAddress', 'name': 'baseAddress'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, masterRef=None, segmentRef=None, name=None, displayName=None, description=None, isPresent=None, baseAddress=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.masterRef = _cast(None, masterRef)
        self.segmentRef = _cast(None, segmentRef)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        self.baseAddress = baseAddress
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, subspaceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if subspaceRefType.subclass:
            return subspaceRefType.subclass(*args_, **kwargs_)
        else:
            return subspaceRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_baseAddress(self): return self.baseAddress
    def set_baseAddress(self, baseAddress): self.baseAddress = baseAddress
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_masterRef(self): return self.masterRef
    def set_masterRef(self, masterRef): self.masterRef = masterRef
    def get_segmentRef(self): return self.segmentRef
    def set_segmentRef(self, segmentRef): self.segmentRef = segmentRef
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.baseAddress is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='subspaceRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('subspaceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subspaceRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='subspaceRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='subspaceRefType'):
        if self.masterRef is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            outfile.write(' masterRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.masterRef), input_name='masterRef')), ))
        if self.segmentRef is not None and 'segmentRef' not in already_processed:
            already_processed.add('segmentRef')
            outfile.write(' segmentRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.segmentRef), input_name='segmentRef')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='subspaceRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.baseAddress is not None:
            self.baseAddress.export(outfile, level, namespace_='ipxact:', name_='baseAddress', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('masterRef', node)
        if value is not None and 'masterRef' not in already_processed:
            already_processed.add('masterRef')
            self.masterRef = value
        value = find_attr_value_('segmentRef', node)
        if value is not None and 'segmentRef' not in already_processed:
            already_processed.add('segmentRef')
            self.segmentRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'baseAddress':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class subspaceRefType


class addressSpaces(GeneratedsSuper):
    """If this component is a bus master, this lists all the address spaces
    defined by the component."""
    member_data_items_ = [
        MemberSpec_('addressSpace', 'addressSpaceType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'addressSpace', 'type': 'addressSpaceType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, addressSpace=None):
        self.original_tagname_ = None
        if addressSpace is None:
            self.addressSpace = []
        else:
            self.addressSpace = addressSpace
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressSpaces)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressSpaces.subclass:
            return addressSpaces.subclass(*args_, **kwargs_)
        else:
            return addressSpaces(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_addressSpace(self): return self.addressSpace
    def set_addressSpace(self, addressSpace): self.addressSpace = addressSpace
    def add_addressSpace(self, value): self.addressSpace.append(value)
    def insert_addressSpace_at(self, index, value): self.addressSpace.insert(index, value)
    def replace_addressSpace_at(self, index, value): self.addressSpace[index] = value
    def hasContent_(self):
        if (
            self.addressSpace
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='addressSpaces', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressSpaces')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='addressSpaces')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='addressSpaces', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='addressSpaces'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='addressSpaces', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for addressSpace_ in self.addressSpace:
            addressSpace_.export(outfile, level, namespace_, name_='addressSpace', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'addressSpace':
            obj_ = addressSpaceType.factory()
            obj_.build(child_)
            self.addressSpace.append(obj_)
            obj_.original_tagname_ = 'addressSpace'
# end class addressSpaces


class memoryMaps(GeneratedsSuper):
    """Lists all the slave memory maps defined by the component."""
    member_data_items_ = [
        MemberSpec_('memoryMap', 'memoryMapType', 1, 0, {'type': 'memoryMapType', 'name': 'memoryMap', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, memoryMap=None):
        self.original_tagname_ = None
        if memoryMap is None:
            self.memoryMap = []
        else:
            self.memoryMap = memoryMap
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, memoryMaps)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if memoryMaps.subclass:
            return memoryMaps.subclass(*args_, **kwargs_)
        else:
            return memoryMaps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_memoryMap(self): return self.memoryMap
    def set_memoryMap(self, memoryMap): self.memoryMap = memoryMap
    def add_memoryMap(self, value): self.memoryMap.append(value)
    def insert_memoryMap_at(self, index, value): self.memoryMap.insert(index, value)
    def replace_memoryMap_at(self, index, value): self.memoryMap[index] = value
    def hasContent_(self):
        if (
            self.memoryMap
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='memoryMaps', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('memoryMaps')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='memoryMaps')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='memoryMaps', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='memoryMaps'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='memoryMaps', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for memoryMap_ in self.memoryMap:
            memoryMap_.export(outfile, level, namespace_, name_='memoryMap', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'memoryMap':
            obj_ = memoryMapType.factory()
            obj_.build(child_)
            self.memoryMap.append(obj_)
            obj_.original_tagname_ = 'memoryMap'
# end class memoryMaps


class alternateRegisters(GeneratedsSuper):
    """Alternate definitions for the current register"""
    member_data_items_ = [
        MemberSpec_('alternateRegister', 'alternateRegisterType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'alternateRegister', 'type': 'alternateRegisterType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, alternateRegister=None):
        self.original_tagname_ = None
        if alternateRegister is None:
            self.alternateRegister = []
        else:
            self.alternateRegister = alternateRegister
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateRegisters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateRegisters.subclass:
            return alternateRegisters.subclass(*args_, **kwargs_)
        else:
            return alternateRegisters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_alternateRegister(self): return self.alternateRegister
    def set_alternateRegister(self, alternateRegister): self.alternateRegister = alternateRegister
    def add_alternateRegister(self, value): self.alternateRegister.append(value)
    def insert_alternateRegister_at(self, index, value): self.alternateRegister.insert(index, value)
    def replace_alternateRegister_at(self, index, value): self.alternateRegister[index] = value
    def hasContent_(self):
        if (
            self.alternateRegister
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='alternateRegisters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateRegisters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alternateRegisters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='alternateRegisters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='alternateRegisters'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='alternateRegisters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateRegister_ in self.alternateRegister:
            alternateRegister_.export(outfile, level, namespace_, name_='alternateRegister', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'alternateRegister':
            obj_ = alternateRegisterType.factory()
            obj_.build(child_)
            self.alternateRegister.append(obj_)
            obj_.original_tagname_ = 'alternateRegister'
# end class alternateRegisters


class enumeratedValues(GeneratedsSuper):
    """Enumerates specific values that can be assigned to the bit field."""
    member_data_items_ = [
        MemberSpec_('enumeratedValue', 'enumeratedValueType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'enumeratedValue', 'type': 'enumeratedValueType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, enumeratedValue=None):
        self.original_tagname_ = None
        if enumeratedValue is None:
            self.enumeratedValue = []
        else:
            self.enumeratedValue = enumeratedValue
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, enumeratedValues)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if enumeratedValues.subclass:
            return enumeratedValues.subclass(*args_, **kwargs_)
        else:
            return enumeratedValues(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enumeratedValue(self): return self.enumeratedValue
    def set_enumeratedValue(self, enumeratedValue): self.enumeratedValue = enumeratedValue
    def add_enumeratedValue(self, value): self.enumeratedValue.append(value)
    def insert_enumeratedValue_at(self, index, value): self.enumeratedValue.insert(index, value)
    def replace_enumeratedValue_at(self, index, value): self.enumeratedValue[index] = value
    def hasContent_(self):
        if (
            self.enumeratedValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='enumeratedValues', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('enumeratedValues')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='enumeratedValues')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='enumeratedValues', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='enumeratedValues'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='enumeratedValues', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for enumeratedValue_ in self.enumeratedValue:
            enumeratedValue_.export(outfile, level, namespace_, name_='enumeratedValue', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enumeratedValue':
            obj_ = enumeratedValueType.factory()
            obj_.build(child_)
            self.enumeratedValue.append(obj_)
            obj_.original_tagname_ = 'enumeratedValue'
# end class enumeratedValues


class valueMaskConfigType(GeneratedsSuper):
    """This type is used to specify a value and optional mask that are
    configurable"""
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, valueMaskConfigType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if valueMaskConfigType.subclass:
            return valueMaskConfigType.subclass(*args_, **kwargs_)
        else:
            return valueMaskConfigType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='valueMaskConfigType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('valueMaskConfigType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='valueMaskConfigType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='valueMaskConfigType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='valueMaskConfigType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='valueMaskConfigType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class valueMaskConfigType


class writeValueConstraintType(GeneratedsSuper):
    """A constraint on the values that can be written to this field.
    Absence of this element implies that any value that fits can be
    written to it."""
    member_data_items_ = [
        MemberSpec_('writeAsRead', 'xs:boolean', 0, 0, {'type': 'xs:boolean', 'name': 'writeAsRead'}, 24),
        MemberSpec_('useEnumeratedValues', 'xs:boolean', 0, 0, {'type': 'xs:boolean', 'name': 'useEnumeratedValues'}, 24),
        MemberSpec_('minimum', 'unsignedBitVectorExpression', 0, 0, {'type': 'unsignedBitVectorExpression', 'name': 'minimum'}, 24),
        MemberSpec_('maximum', 'unsignedBitVectorExpression', 0, 0, {'type': 'unsignedBitVectorExpression', 'name': 'maximum'}, 24),
    ]
    subclass = None
    superclass = None
    def __init__(self, writeAsRead=None, useEnumeratedValues=None, minimum=None, maximum=None):
        self.original_tagname_ = None
        self.writeAsRead = writeAsRead
        self.useEnumeratedValues = useEnumeratedValues
        self.minimum = minimum
        self.maximum = maximum
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, writeValueConstraintType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if writeValueConstraintType.subclass:
            return writeValueConstraintType.subclass(*args_, **kwargs_)
        else:
            return writeValueConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_writeAsRead(self): return self.writeAsRead
    def set_writeAsRead(self, writeAsRead): self.writeAsRead = writeAsRead
    def get_useEnumeratedValues(self): return self.useEnumeratedValues
    def set_useEnumeratedValues(self, useEnumeratedValues): self.useEnumeratedValues = useEnumeratedValues
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def hasContent_(self):
        if (
            self.writeAsRead is not None or
            self.useEnumeratedValues is not None or
            self.minimum is not None or
            self.maximum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='writeValueConstraintType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('writeValueConstraintType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='writeValueConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='writeValueConstraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='writeValueConstraintType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='writeValueConstraintType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.writeAsRead is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:writeAsRead>%s</ipxact:writeAsRead>%s' % (self.gds_format_boolean(self.writeAsRead, input_name='writeAsRead'), eol_))
        if self.useEnumeratedValues is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:useEnumeratedValues>%s</ipxact:useEnumeratedValues>%s' % (self.gds_format_boolean(self.useEnumeratedValues, input_name='useEnumeratedValues'), eol_))
        if self.minimum is not None:
            self.minimum.export(outfile, level, namespace_, name_='minimum', pretty_print=pretty_print)
        if self.maximum is not None:
            self.maximum.export(outfile, level, namespace_, name_='maximum', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'writeAsRead':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'writeAsRead')
            self.writeAsRead = ival_
        elif nodeName_ == 'useEnumeratedValues':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'useEnumeratedValues')
            self.useEnumeratedValues = ival_
        elif nodeName_ == 'minimum':
            obj_ = unsignedBitVectorExpression.factory()
            obj_.build(child_)
            self.minimum = obj_
            obj_.original_tagname_ = 'minimum'
        elif nodeName_ == 'maximum':
            obj_ = unsignedBitVectorExpression.factory()
            obj_.build(child_)
            self.maximum = obj_
            obj_.original_tagname_ = 'maximum'
# end class writeValueConstraintType


class registerFile(GeneratedsSuper):
    """A structure of registers and register files"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType56', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType56', 'name': 'accessHandles'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('dim', 'dimType57', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'dim', 'type': 'dimType57'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'type': 'unsignedLongintExpression', 'name': 'addressOffset'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'typeIdentifier'}, None),
        MemberSpec_('unsignedPositiveLongintExpression', 'unsignedPositiveLongintExpression', 0, 0, {'type': 'unsignedPositiveLongintExpression', 'ref': 'addressRange', 'name': 'unsignedPositiveLongintExpression'}, None),
        MemberSpec_('registerData', 'xs:string', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'registerData', 'name': 'registerData', 'type': 'xs:string'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, dim=None, addressOffset=None, typeIdentifier=None, unsignedPositiveLongintExpression=None, registerData=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.isPresent = isPresent
        if dim is None:
            self.dim = []
        else:
            self.dim = dim
        self.addressOffset = addressOffset
        self.typeIdentifier = typeIdentifier
        self.unsignedPositiveLongintExpression = unsignedPositiveLongintExpression
        if registerData is None:
            self.registerData = []
        else:
            self.registerData = registerData
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, registerFile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if registerFile.subclass:
            return registerFile.subclass(*args_, **kwargs_)
        else:
            return registerFile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_dim(self): return self.dim
    def set_dim(self, dim): self.dim = dim
    def add_dim(self, value): self.dim.append(value)
    def insert_dim_at(self, index, value): self.dim.insert(index, value)
    def replace_dim_at(self, index, value): self.dim[index] = value
    def get_addressOffset(self): return self.addressOffset
    def set_addressOffset(self, addressOffset): self.addressOffset = addressOffset
    def get_typeIdentifier(self): return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier): self.typeIdentifier = typeIdentifier
    def get_unsignedPositiveLongintExpression(self): return self.unsignedPositiveLongintExpression
    def set_unsignedPositiveLongintExpression(self, unsignedPositiveLongintExpression): self.unsignedPositiveLongintExpression = unsignedPositiveLongintExpression
    def get_registerData(self): return self.registerData
    def set_registerData(self, registerData): self.registerData = registerData
    def add_registerData(self, value): self.registerData.append(value)
    def insert_registerData_at(self, index, value): self.registerData.insert(index, value)
    def replace_registerData_at(self, index, value): self.registerData[index] = value
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.dim or
            self.addressOffset is not None or
            self.typeIdentifier is not None or
            self.unsignedPositiveLongintExpression is not None or
            self.registerData or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='registerFile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('registerFile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='registerFile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='registerFile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='registerFile'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='registerFile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for dim_ in self.dim:
            dim_.export(outfile, level, namespace_, name_='dim', pretty_print=pretty_print)
        if self.addressOffset is not None:
            self.addressOffset.export(outfile, level, namespace_, name_='addressOffset', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:typeIdentifier>%s</ipxact:typeIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), eol_))
        if self.unsignedPositiveLongintExpression is not None:
            self.unsignedPositiveLongintExpression.export(outfile, level, namespace_, name_='unsignedPositiveLongintExpression', pretty_print=pretty_print)
        for registerData_ in self.registerData:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:registerData>%s</ipxact:registerData>%s' % (self.gds_encode(self.gds_format_string(quote_xml(registerData_), input_name='registerData')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType56.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'dim':
            obj_ = dimType57.factory()
            obj_.build(child_)
            self.dim.append(obj_)
            obj_.original_tagname_ = 'dim'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'typeIdentifier':
            typeIdentifier_ = child_.text
            typeIdentifier_ = self.gds_validate_string(typeIdentifier_, node, 'typeIdentifier')
            self.typeIdentifier = typeIdentifier_
        elif nodeName_ == 'unsignedPositiveLongintExpression':
            obj_ = unsignedPositiveLongintExpression.factory()
            obj_.build(child_)
            self.unsignedPositiveLongintExpression = obj_
            obj_.original_tagname_ = 'unsignedPositiveLongintExpression'
        elif nodeName_ == 'registerData':
            registerData_ = child_.text
            registerData_ = self.gds_validate_string(registerData_, node, 'registerData')
            self.registerData.append(registerData_)
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class registerFile


class reset(GeneratedsSuper):
    """Register value at reset.Reference to a user defined resetType.
    Assumed to be HARD if not present."""
    member_data_items_ = [
        MemberSpec_('resetTypeRef', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('value', 'stringExpression', 0, 0, {'type': 'unsignedBitVectorExpression', 'name': 'value'}, None),
        MemberSpec_('mask', 'unsignedBitVectorExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitVectorExpression', 'name': 'mask'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, resetTypeRef=None, id=None, value=None, mask=None):
        self.original_tagname_ = None
        self.resetTypeRef = _cast(None, resetTypeRef)
        self.id = _cast(None, id)
        self.value = value
        self.mask = mask
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, reset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if reset.subclass:
            return reset.subclass(*args_, **kwargs_)
        else:
            return reset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_mask(self): return self.mask
    def set_mask(self, mask): self.mask = mask
    def get_resetTypeRef(self): return self.resetTypeRef
    def set_resetTypeRef(self, resetTypeRef): self.resetTypeRef = resetTypeRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.value is not None or
            self.mask is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='reset', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('reset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='reset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='reset'):
        if self.resetTypeRef is not None and 'resetTypeRef' not in already_processed:
            already_processed.add('resetTypeRef')
            outfile.write(' resetTypeRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.resetTypeRef), input_name='resetTypeRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='reset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.mask is not None:
            self.mask.export(outfile, level, namespace_, name_='mask', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resetTypeRef', node)
        if value is not None and 'resetTypeRef' not in already_processed:
            already_processed.add('resetTypeRef')
            self.resetTypeRef = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'mask':
            obj_ = unsignedBitVectorExpression.factory()
            obj_.build(child_)
            self.mask = obj_
            obj_.original_tagname_ = 'mask'
# end class reset


class designInstantiationType(GeneratedsSuper):
    """Design instantiation type."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('designRef', 'configurableLibraryRefType', 0, 0, {'type': 'configurableLibraryRefType', 'name': 'designRef'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, designRef=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.designRef = designRef
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, designInstantiationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if designInstantiationType.subclass:
            return designInstantiationType.subclass(*args_, **kwargs_)
        else:
            return designInstantiationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_designRef(self): return self.designRef
    def set_designRef(self, designRef): self.designRef = designRef
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.designRef is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='designInstantiationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('designInstantiationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='designInstantiationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='designInstantiationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='designInstantiationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='designInstantiationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.designRef is not None:
            self.designRef.export(outfile, level, namespace_, name_='designRef', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'designRef':
            obj_ = ConfigurableLibraryRef.factory()
            obj_.build(child_)
            self.designRef = obj_
            obj_.original_tagname_ = 'designRef'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class designInstantiationType


class designConfigurationInstantiationType(GeneratedsSuper):
    """Design configuration instantiation type."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('language', 'languageType', 0, 1, {'minOccurs': '0', 'type': 'languageType', 'name': 'language'}, None),
        MemberSpec_('designConfigurationRef', 'configurableLibraryRefType', 0, 0, {'type': 'configurableLibraryRefType', 'name': 'designConfigurationRef'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, language=None, designConfigurationRef=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.language = language
        self.designConfigurationRef = designConfigurationRef
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, designConfigurationInstantiationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if designConfigurationInstantiationType.subclass:
            return designConfigurationInstantiationType.subclass(*args_, **kwargs_)
        else:
            return designConfigurationInstantiationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_designConfigurationRef(self): return self.designConfigurationRef
    def set_designConfigurationRef(self, designConfigurationRef): self.designConfigurationRef = designConfigurationRef
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.language is not None or
            self.designConfigurationRef is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='designConfigurationInstantiationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('designConfigurationInstantiationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='designConfigurationInstantiationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='designConfigurationInstantiationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='designConfigurationInstantiationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='designConfigurationInstantiationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.language is not None:
            self.language.export(outfile, level, namespace_, name_='language', pretty_print=pretty_print)
        if self.designConfigurationRef is not None:
            self.designConfigurationRef.export(outfile, level, namespace_, name_='designConfigurationRef', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'language':
            obj_ = languageType.factory()
            obj_.build(child_)
            self.language = obj_
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'designConfigurationRef':
            obj_ = ConfigurableLibraryRef.factory()
            obj_.build(child_)
            self.designConfigurationRef = obj_
            obj_.original_tagname_ = 'designConfigurationRef'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class designConfigurationInstantiationType


class componentInstantiationType(GeneratedsSuper):
    """Component instantiation type"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isVirtual', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'default': 'false', 'name': 'isVirtual'}, None),
        MemberSpec_('language', 'languageType', 0, 1, {'minOccurs': '0', 'type': 'languageType', 'name': 'language'}, None),
        MemberSpec_('libraryName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'name': 'libraryName'}, None),
        MemberSpec_('packageName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'name': 'packageName'}, None),
        MemberSpec_('moduleName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'name': 'moduleName'}, None),
        MemberSpec_('architectureName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'name': 'architectureName'}, None),
        MemberSpec_('configurationName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'name': 'configurationName'}, None),
        MemberSpec_('moduleParameters', 'moduleParametersType', 0, 1, {'minOccurs': '0', 'type': 'moduleParametersType', 'name': 'moduleParameters'}, None),
        MemberSpec_('defaultFileBuilder', 'fileBuilderType', 1, 1, {'minOccurs': '0', 'type': 'fileBuilderType', 'name': 'defaultFileBuilder', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('fileSetRef', 'fileSetRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'fileSetRef', 'name': 'fileSetRef', 'type': 'fileSetRef'}, None),
        MemberSpec_('constraintSetRef', 'constraintSetRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'constraintSetRef', 'name': 'constraintSetRef', 'type': 'constraintSetRef'}, None),
        MemberSpec_('whiteboxElementRefs', 'whiteboxElementRefsType', 0, 1, {'minOccurs': '0', 'type': 'whiteboxElementRefsType', 'name': 'whiteboxElementRefs'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isVirtual=False, language=None, libraryName=None, packageName=None, moduleName=None, architectureName=None, configurationName=None, moduleParameters=None, defaultFileBuilder=None, fileSetRef=None, constraintSetRef=None, whiteboxElementRefs=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isVirtual = isVirtual
        self.language = language
        self.libraryName = libraryName
        self.packageName = packageName
        self.moduleName = moduleName
        self.architectureName = architectureName
        self.configurationName = configurationName
        self.moduleParameters = moduleParameters
        if defaultFileBuilder is None:
            self.defaultFileBuilder = []
        else:
            self.defaultFileBuilder = defaultFileBuilder
        if fileSetRef is None:
            self.fileSetRef = []
        else:
            self.fileSetRef = fileSetRef
        if constraintSetRef is None:
            self.constraintSetRef = []
        else:
            self.constraintSetRef = constraintSetRef
        self.whiteboxElementRefs = whiteboxElementRefs
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, componentInstantiationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if componentInstantiationType.subclass:
            return componentInstantiationType.subclass(*args_, **kwargs_)
        else:
            return componentInstantiationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isVirtual(self): return self.isVirtual
    def set_isVirtual(self, isVirtual): self.isVirtual = isVirtual
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_libraryName(self): return self.libraryName
    def set_libraryName(self, libraryName): self.libraryName = libraryName
    def get_packageName(self): return self.packageName
    def set_packageName(self, packageName): self.packageName = packageName
    def get_moduleName(self): return self.moduleName
    def set_moduleName(self, moduleName): self.moduleName = moduleName
    def get_architectureName(self): return self.architectureName
    def set_architectureName(self, architectureName): self.architectureName = architectureName
    def get_configurationName(self): return self.configurationName
    def set_configurationName(self, configurationName): self.configurationName = configurationName
    def get_moduleParameters(self): return self.moduleParameters
    def set_moduleParameters(self, moduleParameters): self.moduleParameters = moduleParameters
    def get_defaultFileBuilder(self): return self.defaultFileBuilder
    def set_defaultFileBuilder(self, defaultFileBuilder): self.defaultFileBuilder = defaultFileBuilder
    def add_defaultFileBuilder(self, value): self.defaultFileBuilder.append(value)
    def insert_defaultFileBuilder_at(self, index, value): self.defaultFileBuilder.insert(index, value)
    def replace_defaultFileBuilder_at(self, index, value): self.defaultFileBuilder[index] = value
    def get_fileSetRef(self): return self.fileSetRef
    def set_fileSetRef(self, fileSetRef): self.fileSetRef = fileSetRef
    def add_fileSetRef(self, value): self.fileSetRef.append(value)
    def insert_fileSetRef_at(self, index, value): self.fileSetRef.insert(index, value)
    def replace_fileSetRef_at(self, index, value): self.fileSetRef[index] = value
    def get_constraintSetRef(self): return self.constraintSetRef
    def set_constraintSetRef(self, constraintSetRef): self.constraintSetRef = constraintSetRef
    def add_constraintSetRef(self, value): self.constraintSetRef.append(value)
    def insert_constraintSetRef_at(self, index, value): self.constraintSetRef.insert(index, value)
    def replace_constraintSetRef_at(self, index, value): self.constraintSetRef[index] = value
    def get_whiteboxElementRefs(self): return self.whiteboxElementRefs
    def set_whiteboxElementRefs(self, whiteboxElementRefs): self.whiteboxElementRefs = whiteboxElementRefs
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isVirtual or
            self.language is not None or
            self.libraryName is not None or
            self.packageName is not None or
            self.moduleName is not None or
            self.architectureName is not None or
            self.configurationName is not None or
            self.moduleParameters is not None or
            self.defaultFileBuilder or
            self.fileSetRef or
            self.constraintSetRef or
            self.whiteboxElementRefs is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='componentInstantiationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('componentInstantiationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='componentInstantiationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='componentInstantiationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='componentInstantiationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='componentInstantiationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isVirtual:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:isVirtual>%s</ipxact:isVirtual>%s' % (self.gds_format_boolean(self.isVirtual, input_name='isVirtual'), eol_))
        if self.language is not None:
            self.language.export(outfile, level, namespace_, name_='language', pretty_print=pretty_print)
        if self.libraryName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:libraryName>%s</ipxact:libraryName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.libraryName), input_name='libraryName')), eol_))
        if self.packageName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:packageName>%s</ipxact:packageName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.packageName), input_name='packageName')), eol_))
        if self.moduleName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:moduleName>%s</ipxact:moduleName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.moduleName), input_name='moduleName')), eol_))
        if self.architectureName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:architectureName>%s</ipxact:architectureName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.architectureName), input_name='architectureName')), eol_))
        if self.configurationName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:configurationName>%s</ipxact:configurationName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.configurationName), input_name='configurationName')), eol_))
        if self.moduleParameters is not None:
            self.moduleParameters.export(outfile, level, namespace_, name_='moduleParameters', pretty_print=pretty_print)
        for defaultFileBuilder_ in self.defaultFileBuilder:
            defaultFileBuilder_.export(outfile, level, namespace_, name_='defaultFileBuilder', pretty_print=pretty_print)
        for fileSetRef_ in self.fileSetRef:
            fileSetRef_.export(outfile, level, namespace_='ipxact:', name_='fileSetRef', pretty_print=pretty_print)
        for constraintSetRef_ in self.constraintSetRef:
            constraintSetRef_.export(outfile, level, namespace_='ipxact:', name_='constraintSetRef', pretty_print=pretty_print)
        if self.whiteboxElementRefs is not None:
            self.whiteboxElementRefs.export(outfile, level, namespace_, name_='whiteboxElementRefs', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isVirtual':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isVirtual')
            self.isVirtual = ival_
        elif nodeName_ == 'language':
            obj_ = languageType.factory()
            obj_.build(child_)
            self.language = obj_
            obj_.original_tagname_ = 'language'
        elif nodeName_ == 'libraryName':
            libraryName_ = child_.text
            libraryName_ = self.gds_validate_string(libraryName_, node, 'libraryName')
            self.libraryName = libraryName_
        elif nodeName_ == 'packageName':
            packageName_ = child_.text
            packageName_ = self.gds_validate_string(packageName_, node, 'packageName')
            self.packageName = packageName_
        elif nodeName_ == 'moduleName':
            moduleName_ = child_.text
            moduleName_ = self.gds_validate_string(moduleName_, node, 'moduleName')
            self.moduleName = moduleName_
        elif nodeName_ == 'architectureName':
            architectureName_ = child_.text
            architectureName_ = self.gds_validate_string(architectureName_, node, 'architectureName')
            self.architectureName = architectureName_
        elif nodeName_ == 'configurationName':
            configurationName_ = child_.text
            configurationName_ = self.gds_validate_string(configurationName_, node, 'configurationName')
            self.configurationName = configurationName_
        elif nodeName_ == 'moduleParameters':
            obj_ = moduleParametersType.factory()
            obj_.build(child_)
            self.moduleParameters = obj_
            obj_.original_tagname_ = 'moduleParameters'
        elif nodeName_ == 'defaultFileBuilder':
            obj_ = fileBuilderType.factory()
            obj_.build(child_)
            self.defaultFileBuilder.append(obj_)
            obj_.original_tagname_ = 'defaultFileBuilder'
        elif nodeName_ == 'fileSetRef':
            obj_ = fileSetRef.factory()
            obj_.build(child_)
            self.fileSetRef.append(obj_)
            obj_.original_tagname_ = 'fileSetRef'
        elif nodeName_ == 'constraintSetRef':
            obj_ = constraintSetRef.factory()
            obj_.build(child_)
            self.constraintSetRef.append(obj_)
            obj_.original_tagname_ = 'constraintSetRef'
        elif nodeName_ == 'whiteboxElementRefs':
            obj_ = whiteboxElementRefsType.factory()
            obj_.build(child_)
            self.whiteboxElementRefs = obj_
            obj_.original_tagname_ = 'whiteboxElementRefs'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class componentInstantiationType


class libraryName(GeneratedsSuper):
    """A string specifying the library name in which the model should be
    compiled. If the libraryName element is not present then its
    value defaults to work."""
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, libraryName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if libraryName.subclass:
            return libraryName.subclass(*args_, **kwargs_)
        else:
            return libraryName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='libraryName', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('libraryName')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='libraryName')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='libraryName', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='libraryName'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='libraryName', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class libraryName


class Model(GeneratedsSuper):
    """Model information."""
    member_data_items_ = [
        MemberSpec_('views', 'viewsType', 0, 1, {'minOccurs': '0', 'type': 'viewsType', 'name': 'views'}, None),
        MemberSpec_('instantiations', 'instantiationsType', 0, 1, {'minOccurs': '0', 'type': 'instantiationsType', 'name': 'instantiations'}, None),
        MemberSpec_('ports', 'portsType68', 0, 1, {'minOccurs': '0', 'type': 'portsType68', 'name': 'ports'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, views=None, instantiations=None, ports=None):
        self.original_tagname_ = None
        self.views = views
        self.instantiations = instantiations
        self.ports = ports
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Model)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Model.subclass:
            return Model.subclass(*args_, **kwargs_)
        else:
            return Model(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_views(self): return self.views
    def set_views(self, views): self.views = views
    def get_instantiations(self): return self.instantiations
    def set_instantiations(self, instantiations): self.instantiations = instantiations
    def get_ports(self): return self.ports
    def set_ports(self, ports): self.ports = ports
    def hasContent_(self):
        if (
            self.views is not None or
            self.instantiations is not None or
            self.ports is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='modelType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('modelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='modelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='modelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='modelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='modelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.views is not None:
            self.views.export(outfile, level, namespace_, name_='views', pretty_print=pretty_print)
        if self.instantiations is not None:
            self.instantiations.export(outfile, level, namespace_, name_='instantiations', pretty_print=pretty_print)
        if self.ports is not None:
            self.ports.export(outfile, level, namespace_, name_='ports', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'views':
            obj_ = viewsType.factory()
            obj_.build(child_)
            self.views = obj_
            obj_.original_tagname_ = 'views'
        elif nodeName_ == 'instantiations':
            obj_ = instantiationsType.factory()
            obj_.build(child_)
            self.instantiations = obj_
            obj_.original_tagname_ = 'instantiations'
        elif nodeName_ == 'ports':
            obj_ = portsType68.factory()
            obj_.build(child_)
            self.ports = obj_
            obj_.original_tagname_ = 'ports'
# end class Model


class abstractorModelType(GeneratedsSuper):
    """Model information for an abstractor."""
    member_data_items_ = [
        MemberSpec_('views', 'viewsType69', 0, 1, {'minOccurs': '0', 'type': 'viewsType69', 'name': 'views'}, None),
        MemberSpec_('instantiations', 'instantiationsType72', 0, 1, {'minOccurs': '0', 'type': 'instantiationsType72', 'name': 'instantiations'}, None),
        MemberSpec_('ports', 'portsType73', 0, 1, {'minOccurs': '0', 'type': 'portsType73', 'name': 'ports'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, views=None, instantiations=None, ports=None):
        self.original_tagname_ = None
        self.views = views
        self.instantiations = instantiations
        self.ports = ports
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorModelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorModelType.subclass:
            return abstractorModelType.subclass(*args_, **kwargs_)
        else:
            return abstractorModelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_views(self): return self.views
    def set_views(self, views): self.views = views
    def get_instantiations(self): return self.instantiations
    def set_instantiations(self, instantiations): self.instantiations = instantiations
    def get_ports(self): return self.ports
    def set_ports(self, ports): self.ports = ports
    def hasContent_(self):
        if (
            self.views is not None or
            self.instantiations is not None or
            self.ports is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractorModelType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorModelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractorModelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractorModelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractorModelType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractorModelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.views is not None:
            self.views.export(outfile, level, namespace_, name_='views', pretty_print=pretty_print)
        if self.instantiations is not None:
            self.instantiations.export(outfile, level, namespace_, name_='instantiations', pretty_print=pretty_print)
        if self.ports is not None:
            self.ports.export(outfile, level, namespace_, name_='ports', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'views':
            obj_ = viewsType69.factory()
            obj_.build(child_)
            self.views = obj_
            obj_.original_tagname_ = 'views'
        elif nodeName_ == 'instantiations':
            obj_ = instantiationsType72.factory()
            obj_.build(child_)
            self.instantiations = obj_
            obj_.original_tagname_ = 'instantiations'
        elif nodeName_ == 'ports':
            obj_ = portsType73.factory()
            obj_.build(child_)
            self.ports = obj_
            obj_.original_tagname_ = 'ports'
# end class abstractorModelType


class whiteboxElementRefType(GeneratedsSuper):
    """Reference to a whiteboxElement within a view. The 'name' attribute
    must refer to a whiteboxElement defined within this component.
    Reference to a whiteboxElement defined within this component."""
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('location', 'slicesType', 1, 0, {'type': 'slicesType', 'name': 'location', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, isPresent=None, location=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.id = _cast(None, id)
        self.isPresent = isPresent
        if location is None:
            self.location = []
        else:
            self.location = location
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, whiteboxElementRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if whiteboxElementRefType.subclass:
            return whiteboxElementRefType.subclass(*args_, **kwargs_)
        else:
            return whiteboxElementRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def add_location(self, value): self.location.append(value)
    def insert_location_at(self, index, value): self.location.insert(index, value)
    def replace_location_at(self, index, value): self.location[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.isPresent is not None or
            self.location
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='whiteboxElementRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('whiteboxElementRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='whiteboxElementRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='whiteboxElementRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='whiteboxElementRefType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='whiteboxElementRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for location_ in self.location:
            location_.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'location':
            obj_ = slicesType.factory()
            obj_.build(child_)
            self.location.append(obj_)
            obj_.original_tagname_ = 'location'
# end class whiteboxElementRefType


class languageType(GeneratedsSuper):
    """A value of 'true' indicates that this value must match the language
    being generated for the design."""
    member_data_items_ = [
        MemberSpec_('strict', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:token', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, strict=False, valueOf_=None):
        self.original_tagname_ = None
        self.strict = _cast(bool, strict)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, languageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if languageType.subclass:
            return languageType.subclass(*args_, **kwargs_)
        else:
            return languageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_strict(self): return self.strict
    def set_strict(self, strict): self.strict = strict
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='languageType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('languageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='languageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='languageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='languageType'):
        if self.strict and 'strict' not in already_processed:
            already_processed.add('strict')
            outfile.write(' strict="%s"' % self.gds_format_boolean(self.strict, input_name='strict'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='languageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('strict', node)
        if value is not None and 'strict' not in already_processed:
            already_processed.add('strict')
            if value in ('true', '1'):
                self.strict = True
            elif value in ('false', '0'):
                self.strict = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class languageType


class design(GeneratedsSuper):
    """Root element for a platform design."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'vendor'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'library'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'version'}, None),
        MemberSpec_('componentInstances', 'componentInstances', 0, 1, {'minOccurs': '0', 'type': 'componentInstances', 'ref': 'componentInstances', 'name': 'componentInstances'}, None),
        MemberSpec_('interconnections', 'interconnections', 0, 1, {'minOccurs': '0', 'type': 'interconnections', 'ref': 'interconnections', 'name': 'interconnections'}, None),
        MemberSpec_('adHocConnections', 'adHocConnections', 0, 1, {'minOccurs': '0', 'type': 'adHocConnections', 'ref': 'adHocConnections', 'name': 'adHocConnections'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'type': 'assertions', 'ref': 'assertions', 'name': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, componentInstances=None, interconnections=None, adHocConnections=None, description=None, parameters=None, assertions=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.vendor = vendor
        self.library = library
        self.name = name
        self.version = version
        self.componentInstances = componentInstances
        self.interconnections = interconnections
        self.adHocConnections = adHocConnections
        self.description = description
        self.parameters = parameters
        self.assertions = assertions
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, design)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if design.subclass:
            return design.subclass(*args_, **kwargs_)
        else:
            return design(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_componentInstances(self): return self.componentInstances
    def set_componentInstances(self, componentInstances): self.componentInstances = componentInstances
    def get_interconnections(self): return self.interconnections
    def set_interconnections(self, interconnections): self.interconnections = interconnections
    def get_adHocConnections(self): return self.adHocConnections
    def set_adHocConnections(self, adHocConnections): self.adHocConnections = adHocConnections
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_assertions(self): return self.assertions
    def set_assertions(self, assertions): self.assertions = assertions
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.componentInstances is not None or
            self.interconnections is not None or
            self.adHocConnections is not None or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='design', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('design')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='design')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='design', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='design'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='design', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:vendor>%s</ipxact:vendor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), eol_))
        if self.library is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:library>%s</ipxact:library>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:version>%s</ipxact:version>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), eol_))
        if self.componentInstances is not None:
            self.componentInstances.export(outfile, level, namespace_='ipxact:', name_='componentInstances', pretty_print=pretty_print)
        if self.interconnections is not None:
            self.interconnections.export(outfile, level, namespace_='ipxact:', name_='interconnections', pretty_print=pretty_print)
        if self.adHocConnections is not None:
            self.adHocConnections.export(outfile, level, namespace_='ipxact:', name_='adHocConnections', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            self.assertions.export(outfile, level, namespace_='ipxact:', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'library':
            library_ = child_.text
            library_ = self.gds_validate_string(library_, node, 'library')
            self.library = library_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'componentInstances':
            obj_ = componentInstances.factory()
            obj_.build(child_)
            self.componentInstances = obj_
            obj_.original_tagname_ = 'componentInstances'
        elif nodeName_ == 'interconnections':
            obj_ = interconnections.factory()
            obj_.build(child_)
            self.interconnections = obj_
            obj_.original_tagname_ = 'interconnections'
        elif nodeName_ == 'adHocConnections':
            obj_ = adHocConnections.factory()
            obj_.build(child_)
            self.adHocConnections = obj_
            obj_.original_tagname_ = 'adHocConnections'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory()
            obj_.build(child_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class design


class designConfiguration(GeneratedsSuper):
    """Top level element for describing the current configuration of a
    design. Does not describe instance parameterization"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'vendor'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'library'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'version'}, None),
        MemberSpec_('designRef', 'libraryRefType', 0, 1, {'minOccurs': '0', 'type': 'libraryRefType', 'name': 'designRef'}, None),
        MemberSpec_('generatorChainConfiguration', 'configurableLibraryRefType', 1, 1, {'minOccurs': '0', 'type': 'configurableLibraryRefType', 'name': 'generatorChainConfiguration', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('interconnectionConfiguration', 'interconnectionConfigurationType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'interconnectionConfiguration', 'type': 'interconnectionConfigurationType'}, None),
        MemberSpec_('viewConfiguration', 'viewConfigurationType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'viewConfiguration', 'type': 'viewConfigurationType'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'type': 'assertions', 'ref': 'assertions', 'name': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, designRef=None, generatorChainConfiguration=None, interconnectionConfiguration=None, viewConfiguration=None, description=None, parameters=None, assertions=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.vendor = vendor
        self.library = library
        self.name = name
        self.version = version
        self.designRef = designRef
        if generatorChainConfiguration is None:
            self.generatorChainConfiguration = []
        else:
            self.generatorChainConfiguration = generatorChainConfiguration
        if interconnectionConfiguration is None:
            self.interconnectionConfiguration = []
        else:
            self.interconnectionConfiguration = interconnectionConfiguration
        if viewConfiguration is None:
            self.viewConfiguration = []
        else:
            self.viewConfiguration = viewConfiguration
        self.description = description
        self.parameters = parameters
        self.assertions = assertions
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, designConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if designConfiguration.subclass:
            return designConfiguration.subclass(*args_, **kwargs_)
        else:
            return designConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_designRef(self): return self.designRef
    def set_designRef(self, designRef): self.designRef = designRef
    def get_generatorChainConfiguration(self): return self.generatorChainConfiguration
    def set_generatorChainConfiguration(self, generatorChainConfiguration): self.generatorChainConfiguration = generatorChainConfiguration
    def add_generatorChainConfiguration(self, value): self.generatorChainConfiguration.append(value)
    def insert_generatorChainConfiguration_at(self, index, value): self.generatorChainConfiguration.insert(index, value)
    def replace_generatorChainConfiguration_at(self, index, value): self.generatorChainConfiguration[index] = value
    def get_interconnectionConfiguration(self): return self.interconnectionConfiguration
    def set_interconnectionConfiguration(self, interconnectionConfiguration): self.interconnectionConfiguration = interconnectionConfiguration
    def add_interconnectionConfiguration(self, value): self.interconnectionConfiguration.append(value)
    def insert_interconnectionConfiguration_at(self, index, value): self.interconnectionConfiguration.insert(index, value)
    def replace_interconnectionConfiguration_at(self, index, value): self.interconnectionConfiguration[index] = value
    def get_viewConfiguration(self): return self.viewConfiguration
    def set_viewConfiguration(self, viewConfiguration): self.viewConfiguration = viewConfiguration
    def add_viewConfiguration(self, value): self.viewConfiguration.append(value)
    def insert_viewConfiguration_at(self, index, value): self.viewConfiguration.insert(index, value)
    def replace_viewConfiguration_at(self, index, value): self.viewConfiguration[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_assertions(self): return self.assertions
    def set_assertions(self, assertions): self.assertions = assertions
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.designRef is not None or
            self.generatorChainConfiguration or
            self.interconnectionConfiguration or
            self.viewConfiguration or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='designConfiguration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('designConfiguration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='designConfiguration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='designConfiguration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='designConfiguration'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='designConfiguration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:vendor>%s</ipxact:vendor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), eol_))
        if self.library is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:library>%s</ipxact:library>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:version>%s</ipxact:version>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), eol_))
        if self.designRef is not None:
            self.designRef.export(outfile, level, namespace_, name_='designRef', pretty_print=pretty_print)
        for generatorChainConfiguration_ in self.generatorChainConfiguration:
            generatorChainConfiguration_.export(outfile, level, namespace_, name_='generatorChainConfiguration', pretty_print=pretty_print)
        for interconnectionConfiguration_ in self.interconnectionConfiguration:
            interconnectionConfiguration_.export(outfile, level, namespace_, name_='interconnectionConfiguration', pretty_print=pretty_print)
        for viewConfiguration_ in self.viewConfiguration:
            viewConfiguration_.export(outfile, level, namespace_, name_='viewConfiguration', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            self.assertions.export(outfile, level, namespace_='ipxact:', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'library':
            library_ = child_.text
            library_ = self.gds_validate_string(library_, node, 'library')
            self.library = library_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'designRef':
            obj_ = LibraryRef.factory()
            obj_.build(child_)
            self.designRef = obj_
            obj_.original_tagname_ = 'designRef'
        elif nodeName_ == 'generatorChainConfiguration':
            obj_ = ConfigurableLibraryRef.factory()
            obj_.build(child_)
            self.generatorChainConfiguration.append(obj_)
            obj_.original_tagname_ = 'generatorChainConfiguration'
        elif nodeName_ == 'interconnectionConfiguration':
            obj_ = interconnectionConfigurationType.factory()
            obj_.build(child_)
            self.interconnectionConfiguration.append(obj_)
            obj_.original_tagname_ = 'interconnectionConfiguration'
        elif nodeName_ == 'viewConfiguration':
            obj_ = viewConfigurationType.factory()
            obj_.build(child_)
            self.viewConfiguration.append(obj_)
            obj_.original_tagname_ = 'viewConfiguration'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory()
            obj_.build(child_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class designConfiguration


class ipxactFilesType(GeneratedsSuper):
    """Contains a list of IP-XACT files to include."""
    member_data_items_ = [
        MemberSpec_('ipxactFile', 'ipxactFileType', 1, 0, {'type': 'ipxactFileType', 'name': 'ipxactFile', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, ipxactFile=None):
        self.original_tagname_ = None
        if ipxactFile is None:
            self.ipxactFile = []
        else:
            self.ipxactFile = ipxactFile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ipxactFilesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ipxactFilesType.subclass:
            return ipxactFilesType.subclass(*args_, **kwargs_)
        else:
            return ipxactFilesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipxactFile(self): return self.ipxactFile
    def set_ipxactFile(self, ipxactFile): self.ipxactFile = ipxactFile
    def add_ipxactFile(self, value): self.ipxactFile.append(value)
    def insert_ipxactFile_at(self, index, value): self.ipxactFile.insert(index, value)
    def replace_ipxactFile_at(self, index, value): self.ipxactFile[index] = value
    def hasContent_(self):
        if (
            self.ipxactFile
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='ipxactFilesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ipxactFilesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ipxactFilesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='ipxactFilesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='ipxactFilesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='ipxactFilesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ipxactFile_ in self.ipxactFile:
            ipxactFile_.export(outfile, level, namespace_, name_='ipxactFile', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ipxactFile':
            obj_ = ipxactFileType.factory()
            obj_.build(child_)
            self.ipxactFile.append(obj_)
            obj_.original_tagname_ = 'ipxactFile'
# end class ipxactFilesType


class catalog(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'vendor'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'library'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'version'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('catalogs', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'type': 'ipxactFilesType', 'name': 'catalogs'}, None),
        MemberSpec_('busDefinitions', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'type': 'ipxactFilesType', 'name': 'busDefinitions'}, None),
        MemberSpec_('abstractionDefinitions', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'type': 'ipxactFilesType', 'name': 'abstractionDefinitions'}, None),
        MemberSpec_('components', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'type': 'ipxactFilesType', 'name': 'components'}, None),
        MemberSpec_('abstractors', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'type': 'ipxactFilesType', 'name': 'abstractors'}, None),
        MemberSpec_('designs', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'type': 'ipxactFilesType', 'name': 'designs'}, None),
        MemberSpec_('designConfigurations', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'type': 'ipxactFilesType', 'name': 'designConfigurations'}, None),
        MemberSpec_('generatorChains', 'ipxactFilesType', 0, 1, {'minOccurs': '0', 'type': 'ipxactFilesType', 'name': 'generatorChains'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, vendor=None, library=None, name=None, version=None, description=None, catalogs=None, busDefinitions=None, abstractionDefinitions=None, components=None, abstractors=None, designs=None, designConfigurations=None, generatorChains=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.vendor = vendor
        self.library = library
        self.name = name
        self.version = version
        self.description = description
        self.catalogs = catalogs
        self.busDefinitions = busDefinitions
        self.abstractionDefinitions = abstractionDefinitions
        self.components = components
        self.abstractors = abstractors
        self.designs = designs
        self.designConfigurations = designConfigurations
        self.generatorChains = generatorChains
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, catalog)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if catalog.subclass:
            return catalog.subclass(*args_, **kwargs_)
        else:
            return catalog(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_catalogs(self): return self.catalogs
    def set_catalogs(self, catalogs): self.catalogs = catalogs
    def get_busDefinitions(self): return self.busDefinitions
    def set_busDefinitions(self, busDefinitions): self.busDefinitions = busDefinitions
    def get_abstractionDefinitions(self): return self.abstractionDefinitions
    def set_abstractionDefinitions(self, abstractionDefinitions): self.abstractionDefinitions = abstractionDefinitions
    def get_components(self): return self.components
    def set_components(self, components): self.components = components
    def get_abstractors(self): return self.abstractors
    def set_abstractors(self, abstractors): self.abstractors = abstractors
    def get_designs(self): return self.designs
    def set_designs(self, designs): self.designs = designs
    def get_designConfigurations(self): return self.designConfigurations
    def set_designConfigurations(self, designConfigurations): self.designConfigurations = designConfigurations
    def get_generatorChains(self): return self.generatorChains
    def set_generatorChains(self, generatorChains): self.generatorChains = generatorChains
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def hasContent_(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.description is not None or
            self.catalogs is not None or
            self.busDefinitions is not None or
            self.abstractionDefinitions is not None or
            self.components is not None or
            self.abstractors is not None or
            self.designs is not None or
            self.designConfigurations is not None or
            self.generatorChains is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='catalog', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('catalog')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='catalog')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='catalog', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='catalog'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='catalog', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:vendor>%s</ipxact:vendor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), eol_))
        if self.library is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:library>%s</ipxact:library>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:version>%s</ipxact:version>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.catalogs is not None:
            self.catalogs.export(outfile, level, namespace_, name_='catalogs', pretty_print=pretty_print)
        if self.busDefinitions is not None:
            self.busDefinitions.export(outfile, level, namespace_, name_='busDefinitions', pretty_print=pretty_print)
        if self.abstractionDefinitions is not None:
            self.abstractionDefinitions.export(outfile, level, namespace_, name_='abstractionDefinitions', pretty_print=pretty_print)
        if self.components is not None:
            self.components.export(outfile, level, namespace_, name_='components', pretty_print=pretty_print)
        if self.abstractors is not None:
            self.abstractors.export(outfile, level, namespace_, name_='abstractors', pretty_print=pretty_print)
        if self.designs is not None:
            self.designs.export(outfile, level, namespace_, name_='designs', pretty_print=pretty_print)
        if self.designConfigurations is not None:
            self.designConfigurations.export(outfile, level, namespace_, name_='designConfigurations', pretty_print=pretty_print)
        if self.generatorChains is not None:
            self.generatorChains.export(outfile, level, namespace_, name_='generatorChains', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'library':
            library_ = child_.text
            library_ = self.gds_validate_string(library_, node, 'library')
            self.library = library_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'catalogs':
            obj_ = ipxactFilesType.factory()
            obj_.build(child_)
            self.catalogs = obj_
            obj_.original_tagname_ = 'catalogs'
        elif nodeName_ == 'busDefinitions':
            obj_ = ipxactFilesType.factory()
            obj_.build(child_)
            self.busDefinitions = obj_
            obj_.original_tagname_ = 'busDefinitions'
        elif nodeName_ == 'abstractionDefinitions':
            obj_ = ipxactFilesType.factory()
            obj_.build(child_)
            self.abstractionDefinitions = obj_
            obj_.original_tagname_ = 'abstractionDefinitions'
        elif nodeName_ == 'components':
            obj_ = ipxactFilesType.factory()
            obj_.build(child_)
            self.components = obj_
            obj_.original_tagname_ = 'components'
        elif nodeName_ == 'abstractors':
            obj_ = ipxactFilesType.factory()
            obj_.build(child_)
            self.abstractors = obj_
            obj_.original_tagname_ = 'abstractors'
        elif nodeName_ == 'designs':
            obj_ = ipxactFilesType.factory()
            obj_.build(child_)
            self.designs = obj_
            obj_.original_tagname_ = 'designs'
        elif nodeName_ == 'designConfigurations':
            obj_ = ipxactFilesType.factory()
            obj_.build(child_)
            self.designConfigurations = obj_
            obj_.original_tagname_ = 'designConfigurations'
        elif nodeName_ == 'generatorChains':
            obj_ = ipxactFilesType.factory()
            obj_.build(child_)
            self.generatorChains = obj_
            obj_.original_tagname_ = 'generatorChains'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class catalog


class ipxactFileType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('vlnv', 'libraryRefType', 0, 0, {'type': 'libraryRefType', 'name': 'vlnv'}, None),
        MemberSpec_('name', 'stringURIExpression', 0, 0, {'type': 'stringURIExpression', 'name': 'name'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, vlnv=None, name=None, description=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.vlnv = vlnv
        self.name = name
        self.description = description
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ipxactFileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ipxactFileType.subclass:
            return ipxactFileType.subclass(*args_, **kwargs_)
        else:
            return ipxactFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vlnv(self): return self.vlnv
    def set_vlnv(self, vlnv): self.vlnv = vlnv
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def hasContent_(self):
        if (
            self.vlnv is not None or
            self.name is not None or
            self.description is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='ipxactFileType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ipxactFileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ipxactFileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='ipxactFileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='ipxactFileType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='ipxactFileType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vlnv is not None:
            self.vlnv.export(outfile, level, namespace_, name_='vlnv', pretty_print=pretty_print)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vlnv':
            obj_ = LibraryRef.factory()
            obj_.build(child_)
            self.vlnv = obj_
            obj_.original_tagname_ = 'vlnv'
        elif nodeName_ == 'name':
            obj_ = stringURIExpression.factory()
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class ipxactFileType


class abstractorType(GeneratedsSuper):
    """Abstractor-specific extension to abstractorType"""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('vendor', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'vendor'}, None),
        MemberSpec_('library', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'library'}, None),
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('version', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'version'}, None),
        MemberSpec_('abstractorMode', 'abstractorModeType75', 0, 0, {'type': 'abstractorModeType75', 'name': 'abstractorMode'}, None),
        MemberSpec_('busType', 'libraryRefType', 0, 0, {'type': 'libraryRefType', 'name': 'busType'}, None),
        MemberSpec_('abstractorInterfaces', 'abstractorInterfacesType', 0, 0, {'type': 'abstractorInterfacesType', 'name': 'abstractorInterfaces'}, None),
        MemberSpec_('model', 'modelType', 0, 1, {'minOccurs': '0', 'type': 'abstractorModelType', 'name': 'model'}, None),
        MemberSpec_('abstractorGenerators', 'abstractorGenerators', 0, 1, {'minOccurs': '0', 'type': 'abstractorGenerators', 'ref': 'abstractorGenerators', 'name': 'abstractorGenerators'}, None),
        MemberSpec_('choices', 'choices', 0, 1, {'minOccurs': '0', 'type': 'choices', 'ref': 'choices', 'name': 'choices'}, None),
        MemberSpec_('fileSets', 'fileSets', 0, 1, {'minOccurs': '0', 'type': 'fileSets', 'ref': 'fileSets', 'name': 'fileSets'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('assertions', 'assertions', 0, 1, {'minOccurs': '0', 'type': 'assertions', 'ref': 'assertions', 'name': 'assertions'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, vendor=None, library=None, name=None, version=None, abstractorMode=None, busType=None, abstractorInterfaces=None, model=None, abstractorGenerators=None, choices=None, fileSets=None, description=None, parameters=None, assertions=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.vendor = vendor
        self.library = library
        self.name = name
        self.version = version
        self.abstractorMode = abstractorMode
        self.busType = busType
        self.abstractorInterfaces = abstractorInterfaces
        self.model = model
        self.abstractorGenerators = abstractorGenerators
        self.choices = choices
        self.fileSets = fileSets
        self.description = description
        self.parameters = parameters
        self.assertions = assertions
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorType.subclass:
            return abstractorType.subclass(*args_, **kwargs_)
        else:
            return abstractorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_abstractorMode(self): return self.abstractorMode
    def set_abstractorMode(self, abstractorMode): self.abstractorMode = abstractorMode
    def get_busType(self): return self.busType
    def set_busType(self, busType): self.busType = busType
    def get_abstractorInterfaces(self): return self.abstractorInterfaces
    def set_abstractorInterfaces(self, abstractorInterfaces): self.abstractorInterfaces = abstractorInterfaces
    def get_model(self): return self.model
    def set_model(self, model): self.model = model
    def get_abstractorGenerators(self): return self.abstractorGenerators
    def set_abstractorGenerators(self, abstractorGenerators): self.abstractorGenerators = abstractorGenerators
    def get_choices(self): return self.choices
    def set_choices(self, choices): self.choices = choices
    def get_fileSets(self): return self.fileSets
    def set_fileSets(self, fileSets): self.fileSets = fileSets
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_assertions(self): return self.assertions
    def set_assertions(self, assertions): self.assertions = assertions
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.vendor is not None or
            self.library is not None or
            self.name is not None or
            self.version is not None or
            self.abstractorMode is not None or
            self.busType is not None or
            self.abstractorInterfaces is not None or
            self.model is not None or
            self.abstractorGenerators is not None or
            self.choices is not None or
            self.fileSets is not None or
            self.description is not None or
            self.parameters is not None or
            self.assertions is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractorType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:vendor>%s</ipxact:vendor>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.vendor), input_name='vendor')), eol_))
        if self.library is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:library>%s</ipxact:library>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.library), input_name='library')), eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:version>%s</ipxact:version>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.version), input_name='version')), eol_))
        if self.abstractorMode is not None:
            self.abstractorMode.export(outfile, level, namespace_, name_='abstractorMode', pretty_print=pretty_print)
        if self.busType is not None:
            self.busType.export(outfile, level, namespace_, name_='busType', pretty_print=pretty_print)
        if self.abstractorInterfaces is not None:
            self.abstractorInterfaces.export(outfile, level, namespace_, name_='abstractorInterfaces', pretty_print=pretty_print)
        if self.model is not None:
            self.model.export(outfile, level, namespace_, name_='model', pretty_print=pretty_print)
        if self.abstractorGenerators is not None:
            self.abstractorGenerators.export(outfile, level, namespace_='ipxact:', name_='abstractorGenerators', pretty_print=pretty_print)
        if self.choices is not None:
            self.choices.export(outfile, level, namespace_='ipxact:', name_='choices', pretty_print=pretty_print)
        if self.fileSets is not None:
            self.fileSets.export(outfile, level, namespace_='ipxact:', name_='fileSets', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.assertions is not None:
            self.assertions.export(outfile, level, namespace_='ipxact:', name_='assertions', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vendor':
            vendor_ = child_.text
            vendor_ = self.gds_validate_string(vendor_, node, 'vendor')
            self.vendor = vendor_
        elif nodeName_ == 'library':
            library_ = child_.text
            library_ = self.gds_validate_string(library_, node, 'library')
            self.library = library_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'abstractorMode':
            obj_ = abstractorModeType75.factory()
            obj_.build(child_)
            self.abstractorMode = obj_
            obj_.original_tagname_ = 'abstractorMode'
        elif nodeName_ == 'busType':
            obj_ = LibraryRef.factory()
            obj_.build(child_)
            self.busType = obj_
            obj_.original_tagname_ = 'busType'
        elif nodeName_ == 'abstractorInterfaces':
            obj_ = abstractorInterfacesType.factory()
            obj_.build(child_)
            self.abstractorInterfaces = obj_
            obj_.original_tagname_ = 'abstractorInterfaces'
        elif nodeName_ == 'model':
            obj_ = Model.factory()
            obj_.build(child_)
            self.model = obj_
            obj_.original_tagname_ = 'model'
        elif nodeName_ == 'abstractorGenerators':
            obj_ = abstractorGenerators.factory()
            obj_.build(child_)
            self.abstractorGenerators = obj_
            obj_.original_tagname_ = 'abstractorGenerators'
        elif nodeName_ == 'choices':
            obj_ = choices.factory()
            obj_.build(child_)
            self.choices = obj_
            obj_.original_tagname_ = 'choices'
        elif nodeName_ == 'fileSets':
            obj_ = fileSets.factory()
            obj_.build(child_)
            self.fileSets = obj_
            obj_.original_tagname_ = 'fileSets'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'assertions':
            obj_ = assertions.factory()
            obj_.build(child_)
            self.assertions = obj_
            obj_.original_tagname_ = 'assertions'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class abstractorType


class systemGroupNamesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('systemGroupName', 'systemGroupNameType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'systemGroupName', 'type': 'systemGroupNameType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, systemGroupName=None):
        self.original_tagname_ = None
        if systemGroupName is None:
            self.systemGroupName = []
        else:
            self.systemGroupName = systemGroupName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, systemGroupNamesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if systemGroupNamesType.subclass:
            return systemGroupNamesType.subclass(*args_, **kwargs_)
        else:
            return systemGroupNamesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_systemGroupName(self): return self.systemGroupName
    def set_systemGroupName(self, systemGroupName): self.systemGroupName = systemGroupName
    def add_systemGroupName(self, value): self.systemGroupName.append(value)
    def insert_systemGroupName_at(self, index, value): self.systemGroupName.insert(index, value)
    def replace_systemGroupName_at(self, index, value): self.systemGroupName[index] = value
    def hasContent_(self):
        if (
            self.systemGroupName
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='systemGroupNamesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('systemGroupNamesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='systemGroupNamesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='systemGroupNamesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='systemGroupNamesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='systemGroupNamesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for systemGroupName_ in self.systemGroupName:
            systemGroupName_.export(outfile, level, namespace_, name_='systemGroupName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'systemGroupName':
            obj_ = systemGroupNameType.factory()
            obj_.build(child_)
            self.systemGroupName.append(obj_)
            obj_.original_tagname_ = 'systemGroupName'
# end class systemGroupNamesType


class systemGroupNameType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, systemGroupNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if systemGroupNameType.subclass:
            return systemGroupNameType.subclass(*args_, **kwargs_)
        else:
            return systemGroupNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='systemGroupNameType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('systemGroupNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='systemGroupNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='systemGroupNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='systemGroupNameType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='systemGroupNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class systemGroupNameType


class choiceType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('enumeration', 'enumerationType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'enumeration', 'type': 'enumerationType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, enumeration=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        if enumeration is None:
            self.enumeration = []
        else:
            self.enumeration = enumeration
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, choiceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if choiceType.subclass:
            return choiceType.subclass(*args_, **kwargs_)
        else:
            return choiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_enumeration(self): return self.enumeration
    def set_enumeration(self, enumeration): self.enumeration = enumeration
    def add_enumeration(self, value): self.enumeration.append(value)
    def insert_enumeration_at(self, index, value): self.enumeration.insert(index, value)
    def replace_enumeration_at(self, index, value): self.enumeration[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.enumeration
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='choiceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('choiceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='choiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='choiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='choiceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='choiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        for enumeration_ in self.enumeration:
            enumeration_.export(outfile, level, namespace_, name_='enumeration', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'enumeration':
            obj_ = enumerationType.factory()
            obj_.build(child_)
            self.enumeration.append(obj_)
            obj_.original_tagname_ = 'enumeration'
# end class choiceType


class enumerationType(complexBaseExpression):
    """When specified, displayed in place of the ipxact:enumeration value
    Text that may be displayed if the user requests help about the
    meaning of an element"""
    member_data_items_ = [
        MemberSpec_('text', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('help', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, text=None, help=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        super(enumerationType, self).__init__(valueOf_, )
        self.text = _cast(None, text)
        self.help = _cast(None, help)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, enumerationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if enumerationType.subclass:
            return enumerationType.subclass(*args_, **kwargs_)
        else:
            return enumerationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_text(self): return self.text
    def set_text(self, text): self.text = text
    def get_help(self): return self.help
    def set_help(self, help): self.help = help
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(enumerationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='enumerationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('enumerationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='enumerationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='enumerationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='enumerationType'):
        super(enumerationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='enumerationType')
        if self.text is not None and 'text' not in already_processed:
            already_processed.add('text')
            outfile.write(' text=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.text), input_name='text')), ))
        if self.help is not None and 'help' not in already_processed:
            already_processed.add('help')
            outfile.write(' help=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.help), input_name='help')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='enumerationType', fromsubclass_=False, pretty_print=True):
        super(enumerationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('text', node)
        if value is not None and 'text' not in already_processed:
            already_processed.add('text')
            self.text = value
        value = find_attr_value_('help', node)
        if value is not None and 'help' not in already_processed:
            already_processed.add('help')
            self.help = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(enumerationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class enumerationType


class portReferencesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('internalPortReference', 'internalPortReferenceType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'internalPortReference', 'type': 'internalPortReferenceType'}, 26),
        MemberSpec_('externalPortReference', 'externalPortReference', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'externalPortReference', 'name': 'externalPortReference', 'type': 'externalPortReference'}, 26),
    ]
    subclass = None
    superclass = None
    def __init__(self, internalPortReference=None, externalPortReference=None):
        self.original_tagname_ = None
        if internalPortReference is None:
            self.internalPortReference = []
        else:
            self.internalPortReference = internalPortReference
        if externalPortReference is None:
            self.externalPortReference = []
        else:
            self.externalPortReference = externalPortReference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portReferencesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portReferencesType.subclass:
            return portReferencesType.subclass(*args_, **kwargs_)
        else:
            return portReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_internalPortReference(self): return self.internalPortReference
    def set_internalPortReference(self, internalPortReference): self.internalPortReference = internalPortReference
    def add_internalPortReference(self, value): self.internalPortReference.append(value)
    def insert_internalPortReference_at(self, index, value): self.internalPortReference.insert(index, value)
    def replace_internalPortReference_at(self, index, value): self.internalPortReference[index] = value
    def get_externalPortReference(self): return self.externalPortReference
    def set_externalPortReference(self, externalPortReference): self.externalPortReference = externalPortReference
    def add_externalPortReference(self, value): self.externalPortReference.append(value)
    def insert_externalPortReference_at(self, index, value): self.externalPortReference.insert(index, value)
    def replace_externalPortReference_at(self, index, value): self.externalPortReference[index] = value
    def hasContent_(self):
        if (
            self.internalPortReference or
            self.externalPortReference
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='portReferencesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portReferencesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portReferencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='portReferencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='portReferencesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='portReferencesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for internalPortReference_ in self.internalPortReference:
            internalPortReference_.export(outfile, level, namespace_, name_='internalPortReference', pretty_print=pretty_print)
        for externalPortReference_ in self.externalPortReference:
            externalPortReference_.export(outfile, level, namespace_='ipxact:', name_='externalPortReference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'internalPortReference':
            obj_ = internalPortReferenceType.factory()
            obj_.build(child_)
            self.internalPortReference.append(obj_)
            obj_.original_tagname_ = 'internalPortReference'
        elif nodeName_ == 'externalPortReference':
            obj_ = externalPortReference.factory()
            obj_.build(child_)
            self.externalPortReference.append(obj_)
            obj_.original_tagname_ = 'externalPortReference'
# end class portReferencesType


class internalPortReferenceType(GeneratedsSuper):
    """A reference to the instanceName element of a component in this
    design.A port on the on the referenced component from
    componentRef."""
    member_data_items_ = [
        MemberSpec_('componentRef', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('portRef', 'ipxact:portName', 0, 0, {'use': 'required'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('PartSelect', 'partSelect', 0, 1, {'minOccurs': '0', 'type': 'partSelect', 'ref': 'partSelect', 'name': 'partSelect'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentRef=None, portRef=None, id=None, isPresent=None, PartSelect=None):
        self.original_tagname_ = None
        self.componentRef = _cast(None, componentRef)
        self.portRef = _cast(None, portRef)
        self.id = _cast(None, id)
        self.isPresent = isPresent
        self.PartSelect = PartSelect
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, internalPortReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if internalPortReferenceType.subclass:
            return internalPortReferenceType.subclass(*args_, **kwargs_)
        else:
            return internalPortReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_partSelect(self): return self.PartSelect
    def set_partSelect(self, PartSelect): self.PartSelect = PartSelect
    def get_componentRef(self): return self.componentRef
    def set_componentRef(self, componentRef): self.componentRef = componentRef
    def get_portRef(self): return self.portRef
    def set_portRef(self, portRef): self.portRef = portRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.isPresent is not None or
            self.PartSelect is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='internalPortReferenceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('internalPortReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='internalPortReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='internalPortReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='internalPortReferenceType'):
        if self.componentRef is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            outfile.write(' componentRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.componentRef), input_name='componentRef')), ))
        if self.portRef is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            outfile.write(' portRef=%s' % (quote_attrib(self.portRef), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='internalPortReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.PartSelect is not None:
            self.PartSelect.export(outfile, level, namespace_='ipxact:', name_='partSelect', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('componentRef', node)
        if value is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            self.componentRef = value
        value = find_attr_value_('portRef', node)
        if value is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            self.portRef = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'partSelect':
            obj_ = PartSelect.factory()
            obj_.build(child_)
            self.PartSelect = obj_
            obj_.original_tagname_ = 'partSelect'
# end class internalPortReferenceType


class monitorInterfaceType1(monitorInterfaceType):
    member_data_items_ = [
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
    ]
    subclass = None
    superclass = monitorInterfaceType
    def __init__(self, componentRef=None, busRef=None, id=None, path=None, description=None, vendorExtensions=None, isPresent=None):
        self.original_tagname_ = None
        super(monitorInterfaceType1, self).__init__(componentRef, busRef, id, path, description, vendorExtensions, )
        self.isPresent = isPresent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monitorInterfaceType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monitorInterfaceType1.subclass:
            return monitorInterfaceType1.subclass(*args_, **kwargs_)
        else:
            return monitorInterfaceType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def hasContent_(self):
        if (
            self.isPresent is not None or
            super(monitorInterfaceType1, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='monitorInterfaceType1', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monitorInterfaceType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='monitorInterfaceType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='monitorInterfaceType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='monitorInterfaceType1'):
        super(monitorInterfaceType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='monitorInterfaceType1')
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='monitorInterfaceType1', fromsubclass_=False, pretty_print=True):
        super(monitorInterfaceType1, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(monitorInterfaceType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        super(monitorInterfaceType1, self).buildChildren(child_, node, nodeName_, True)
# end class monitorInterfaceType1


class excludePortsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('excludePort', 'excludePortType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'excludePort', 'type': 'excludePortType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, excludePort=None):
        self.original_tagname_ = None
        if excludePort is None:
            self.excludePort = []
        else:
            self.excludePort = excludePort
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, excludePortsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if excludePortsType.subclass:
            return excludePortsType.subclass(*args_, **kwargs_)
        else:
            return excludePortsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_excludePort(self): return self.excludePort
    def set_excludePort(self, excludePort): self.excludePort = excludePort
    def add_excludePort(self, value): self.excludePort.append(value)
    def insert_excludePort_at(self, index, value): self.excludePort.insert(index, value)
    def replace_excludePort_at(self, index, value): self.excludePort[index] = value
    def hasContent_(self):
        if (
            self.excludePort
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='excludePortsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('excludePortsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='excludePortsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='excludePortsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='excludePortsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='excludePortsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for excludePort_ in self.excludePort:
            excludePort_.export(outfile, level, namespace_, name_='excludePort', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'excludePort':
            obj_ = excludePortType.factory()
            obj_.build(child_)
            self.excludePort.append(obj_)
            obj_.original_tagname_ = 'excludePort'
# end class excludePortsType


class excludePortType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['portName', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, excludePortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if excludePortType.subclass:
            return excludePortType.subclass(*args_, **kwargs_)
        else:
            return excludePortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='excludePortType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('excludePortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='excludePortType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='excludePortType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='excludePortType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='excludePortType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class excludePortType


class viewRefType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType.subclass:
            return viewRefType.subclass(*args_, **kwargs_)
        else:
            return viewRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewRefType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewRefType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class viewRefType


class indicesType2(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('index', 'unsignedIntExpression', 1, 0, {'type': 'unsignedIntExpression', 'name': 'index', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, index=None):
        self.original_tagname_ = None
        if index is None:
            self.index = []
        else:
            self.index = index
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indicesType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indicesType2.subclass:
            return indicesType2.subclass(*args_, **kwargs_)
        else:
            return indicesType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def add_index(self, value): self.index.append(value)
    def insert_index_at(self, index, value): self.index.insert(index, value)
    def replace_index_at(self, index, value): self.index[index] = value
    def hasContent_(self):
        if (
            self.index
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='indicesType2', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indicesType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indicesType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='indicesType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='indicesType2'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='indicesType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for index_ in self.index:
            index_.export(outfile, level, namespace_, name_='index', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'index':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.index.append(obj_)
            obj_.original_tagname_ = 'index'
# end class indicesType2


class viewRefType3(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType3.subclass:
            return viewRefType3.subclass(*args_, **kwargs_)
        else:
            return viewRefType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewRefType3', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewRefType3')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewRefType3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewRefType3'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewRefType3', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class viewRefType3


class viewRefType4(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType4.subclass:
            return viewRefType4.subclass(*args_, **kwargs_)
        else:
            return viewRefType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewRefType4', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewRefType4')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewRefType4', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewRefType4'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewRefType4', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class viewRefType4


class indicesType5(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('index', 'unsignedIntExpression', 1, 0, {'type': 'unsignedIntExpression', 'name': 'index', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, index=None):
        self.original_tagname_ = None
        if index is None:
            self.index = []
        else:
            self.index = index
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, indicesType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if indicesType5.subclass:
            return indicesType5.subclass(*args_, **kwargs_)
        else:
            return indicesType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def add_index(self, value): self.index.append(value)
    def insert_index_at(self, index, value): self.index.insert(index, value)
    def replace_index_at(self, index, value): self.index[index] = value
    def hasContent_(self):
        if (
            self.index
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='indicesType5', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('indicesType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='indicesType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='indicesType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='indicesType5'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='indicesType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for index_ in self.index:
            index_.export(outfile, level, namespace_, name_='index', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'index':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.index.append(obj_)
            obj_.original_tagname_ = 'index'
# end class indicesType5


class pathSegmentsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('pathSegment', 'pathSegmentType', 1, 0, {'type': 'pathSegmentType', 'name': 'pathSegment', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, pathSegment=None):
        self.original_tagname_ = None
        if pathSegment is None:
            self.pathSegment = []
        else:
            self.pathSegment = pathSegment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathSegmentsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathSegmentsType.subclass:
            return pathSegmentsType.subclass(*args_, **kwargs_)
        else:
            return pathSegmentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pathSegment(self): return self.pathSegment
    def set_pathSegment(self, pathSegment): self.pathSegment = pathSegment
    def add_pathSegment(self, value): self.pathSegment.append(value)
    def insert_pathSegment_at(self, index, value): self.pathSegment.insert(index, value)
    def replace_pathSegment_at(self, index, value): self.pathSegment[index] = value
    def hasContent_(self):
        if (
            self.pathSegment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='pathSegmentsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pathSegmentsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pathSegmentsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='pathSegmentsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='pathSegmentsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='pathSegmentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pathSegment_ in self.pathSegment:
            pathSegment_.export(outfile, level, namespace_, name_='pathSegment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pathSegment':
            obj_ = pathSegmentType.factory()
            obj_.build(child_)
            self.pathSegment.append(obj_)
            obj_.original_tagname_ = 'pathSegment'
# end class pathSegmentsType


class viewRefType6(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType6.subclass:
            return viewRefType6.subclass(*args_, **kwargs_)
        else:
            return viewRefType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewRefType6', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewRefType6')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewRefType6', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewRefType6'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewRefType6', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class viewRefType6


class pathSegmentsType7(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('pathSegment', 'pathSegmentType', 1, 0, {'type': 'pathSegmentType', 'name': 'pathSegment', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, pathSegment=None):
        self.original_tagname_ = None
        if pathSegment is None:
            self.pathSegment = []
        else:
            self.pathSegment = pathSegment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathSegmentsType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathSegmentsType7.subclass:
            return pathSegmentsType7.subclass(*args_, **kwargs_)
        else:
            return pathSegmentsType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pathSegment(self): return self.pathSegment
    def set_pathSegment(self, pathSegment): self.pathSegment = pathSegment
    def add_pathSegment(self, value): self.pathSegment.append(value)
    def insert_pathSegment_at(self, index, value): self.pathSegment.insert(index, value)
    def replace_pathSegment_at(self, index, value): self.pathSegment[index] = value
    def hasContent_(self):
        if (
            self.pathSegment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='pathSegmentsType7', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pathSegmentsType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pathSegmentsType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='pathSegmentsType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='pathSegmentsType7'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='pathSegmentsType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pathSegment_ in self.pathSegment:
            pathSegment_.export(outfile, level, namespace_, name_='pathSegment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pathSegment':
            obj_ = pathSegmentType.factory()
            obj_.build(child_)
            self.pathSegment.append(obj_)
            obj_.original_tagname_ = 'pathSegment'
# end class pathSegmentsType7


class pathSegmentsType8(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('pathSegment', 'pathSegmentType', 1, 0, {'type': 'pathSegmentType', 'name': 'pathSegment', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, pathSegment=None):
        self.original_tagname_ = None
        if pathSegment is None:
            self.pathSegment = []
        else:
            self.pathSegment = pathSegment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pathSegmentsType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pathSegmentsType8.subclass:
            return pathSegmentsType8.subclass(*args_, **kwargs_)
        else:
            return pathSegmentsType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pathSegment(self): return self.pathSegment
    def set_pathSegment(self, pathSegment): self.pathSegment = pathSegment
    def add_pathSegment(self, value): self.pathSegment.append(value)
    def insert_pathSegment_at(self, index, value): self.pathSegment.insert(index, value)
    def replace_pathSegment_at(self, index, value): self.pathSegment[index] = value
    def hasContent_(self):
        if (
            self.pathSegment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='pathSegmentsType8', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pathSegmentsType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='pathSegmentsType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='pathSegmentsType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='pathSegmentsType8'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='pathSegmentsType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for pathSegment_ in self.pathSegment:
            pathSegment_.export(outfile, level, namespace_, name_='pathSegment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pathSegment':
            obj_ = pathSegmentType.factory()
            obj_.build(child_)
            self.pathSegment.append(obj_)
            obj_.original_tagname_ = 'pathSegment'
# end class pathSegmentsType8


class arrayType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('left', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'ref': 'left', 'name': 'left'}, None),
        MemberSpec_('right', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'ref': 'right', 'name': 'right'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, left=None, right=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.left = left
        self.right = right
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, arrayType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if arrayType.subclass:
            return arrayType.subclass(*args_, **kwargs_)
        else:
            return arrayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_left(self): return self.left
    def set_left(self, left): self.left = left
    def get_right(self): return self.right
    def set_right(self, right): self.right = right
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.left is not None or
            self.right is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='arrayType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('arrayType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='arrayType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='arrayType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='arrayType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='arrayType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left is not None:
            self.left.export(outfile, level, namespace_='ipxact:', name_='left', pretty_print=pretty_print)
        if self.right is not None:
            self.right.export(outfile, level, namespace_='ipxact:', name_='right', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'left':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.left = obj_
            obj_.original_tagname_ = 'left'
        elif nodeName_ == 'right':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.right = obj_
            obj_.original_tagname_ = 'right'
# end class arrayType


class protocolTypeType9(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('custom', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['protocolTypeType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, custom=None, valueOf_=None):
        self.original_tagname_ = None
        self.custom = _cast(None, custom)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, protocolTypeType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if protocolTypeType9.subclass:
            return protocolTypeType9.subclass(*args_, **kwargs_)
        else:
            return protocolTypeType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_custom(self): return self.custom
    def set_custom(self, custom): self.custom = custom
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='protocolTypeType9', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('protocolTypeType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='protocolTypeType9')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='protocolTypeType9', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='protocolTypeType9'):
        if self.custom is not None and 'custom' not in already_processed:
            already_processed.add('custom')
            outfile.write(' custom=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.custom), input_name='custom')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='protocolTypeType9', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('custom', node)
        if value is not None and 'custom' not in already_processed:
            already_processed.add('custom')
            self.custom = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class protocolTypeType9


class extensionType(GeneratedsSuper):
    """True if the payload extension is mandatory."""
    member_data_items_ = [
        MemberSpec_('mandatory', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, mandatory=False, valueOf_=None):
        self.original_tagname_ = None
        self.mandatory = _cast(bool, mandatory)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, extensionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if extensionType.subclass:
            return extensionType.subclass(*args_, **kwargs_)
        else:
            return extensionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mandatory(self): return self.mandatory
    def set_mandatory(self, mandatory): self.mandatory = mandatory
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='extensionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('extensionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='extensionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='extensionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='extensionType'):
        if self.mandatory and 'mandatory' not in already_processed:
            already_processed.add('mandatory')
            outfile.write(' mandatory="%s"' % self.gds_format_boolean(self.mandatory, input_name='mandatory'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='extensionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mandatory', node)
        if value is not None and 'mandatory' not in already_processed:
            already_processed.add('mandatory')
            if value in ('true', '1'):
                self.mandatory = True
            elif value in ('false', '0'):
                self.mandatory = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class extensionType


class typeNameType(GeneratedsSuper):
    """When false, defines that the type is an abstract type that may not
    be related to an existing type in the language of the referenced
    view."""
    member_data_items_ = [
        MemberSpec_('exact', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, exact=True, valueOf_=None):
        self.original_tagname_ = None
        self.exact = _cast(bool, exact)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeNameType.subclass:
            return typeNameType.subclass(*args_, **kwargs_)
        else:
            return typeNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exact(self): return self.exact
    def set_exact(self, exact): self.exact = exact
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='typeNameType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typeNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='typeNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='typeNameType'):
        if not self.exact and 'exact' not in already_processed:
            already_processed.add('exact')
            outfile.write(' exact="%s"' % self.gds_format_boolean(self.exact, input_name='exact'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='typeNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('exact', node)
        if value is not None and 'exact' not in already_processed:
            already_processed.add('exact')
            if value in ('true', '1'):
                self.exact = True
            elif value in ('false', '0'):
                self.exact = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class typeNameType


class typeDefinitionType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeDefinitionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeDefinitionType.subclass:
            return typeDefinitionType.subclass(*args_, **kwargs_)
        else:
            return typeDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='typeDefinitionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeDefinitionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typeDefinitionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='typeDefinitionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='typeDefinitionType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='typeDefinitionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class typeDefinitionType


class viewRefType10(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:NMTOKEN', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType10.subclass:
            return viewRefType10.subclass(*args_, **kwargs_)
        else:
            return viewRefType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewRefType10', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewRefType10')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewRefType10', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewRefType10'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewRefType10', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class viewRefType10


class typeNameType11(GeneratedsSuper):
    """Defines that the typeName supplied for this service is implicit and
    a netlister should not declare this service in a language
    specific top-level netlist"""
    member_data_items_ = [
        MemberSpec_('implicit', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, implicit=False, valueOf_=None):
        self.original_tagname_ = None
        self.implicit = _cast(bool, implicit)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeNameType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeNameType11.subclass:
            return typeNameType11.subclass(*args_, **kwargs_)
        else:
            return typeNameType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_implicit(self): return self.implicit
    def set_implicit(self, implicit): self.implicit = implicit
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='typeNameType11', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeNameType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typeNameType11')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='typeNameType11', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='typeNameType11'):
        if self.implicit and 'implicit' not in already_processed:
            already_processed.add('implicit')
            outfile.write(' implicit="%s"' % self.gds_format_boolean(self.implicit, input_name='implicit'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='typeNameType11', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('implicit', node)
        if value is not None and 'implicit' not in already_processed:
            already_processed.add('implicit')
            if value in ('true', '1'):
                self.implicit = True
            elif value in ('false', '0'):
                self.implicit = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class typeNameType11


class typeDefinitionType12(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeDefinitionType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeDefinitionType12.subclass:
            return typeDefinitionType12.subclass(*args_, **kwargs_)
        else:
            return typeDefinitionType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='typeDefinitionType12', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeDefinitionType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typeDefinitionType12')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='typeDefinitionType12', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='typeDefinitionType12'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='typeDefinitionType12', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class typeDefinitionType12


class typeNameType13(GeneratedsSuper):
    """Defines that the type for the port has constrainted the number of
    bits in the vector"""
    member_data_items_ = [
        MemberSpec_('constrained', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, constrained=False, valueOf_=None):
        self.original_tagname_ = None
        self.constrained = _cast(bool, constrained)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeNameType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeNameType13.subclass:
            return typeNameType13.subclass(*args_, **kwargs_)
        else:
            return typeNameType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constrained(self): return self.constrained
    def set_constrained(self, constrained): self.constrained = constrained
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='typeNameType13', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeNameType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typeNameType13')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='typeNameType13', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='typeNameType13'):
        if self.constrained and 'constrained' not in already_processed:
            already_processed.add('constrained')
            outfile.write(' constrained="%s"' % self.gds_format_boolean(self.constrained, input_name='constrained'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='typeNameType13', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('constrained', node)
        if value is not None and 'constrained' not in already_processed:
            already_processed.add('constrained')
            if value in ('true', '1'):
                self.constrained = True
            elif value in ('false', '0'):
                self.constrained = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class typeNameType13


class typeDefinitionType14(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, typeDefinitionType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if typeDefinitionType14.subclass:
            return typeDefinitionType14.subclass(*args_, **kwargs_)
        else:
            return typeDefinitionType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='typeDefinitionType14', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('typeDefinitionType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typeDefinitionType14')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='typeDefinitionType14', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='typeDefinitionType14'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='typeDefinitionType14', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class typeDefinitionType14


class viewRefType15(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:NMTOKEN', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewRefType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewRefType15.subclass:
            return viewRefType15.subclass(*args_, **kwargs_)
        else:
            return viewRefType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewRefType15', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewRefType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewRefType15')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewRefType15', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewRefType15'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewRefType15', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class viewRefType15


class connectionType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('maxConnections', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedIntExpression', 'default': '0', 'name': 'maxConnections'}, None),
        MemberSpec_('minConnections', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedIntExpression', 'default': '1', 'name': 'minConnections'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, maxConnections=None, minConnections=None):
        self.original_tagname_ = None
        if maxConnections is None:
            self.maxConnections = globals()['unsignedIntExpression']('0')
        else:
            self.maxConnections = maxConnections
        if minConnections is None:
            self.minConnections = globals()['unsignedIntExpression']('1')
        else:
            self.minConnections = minConnections
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, connectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if connectionType.subclass:
            return connectionType.subclass(*args_, **kwargs_)
        else:
            return connectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maxConnections(self): return self.maxConnections
    def set_maxConnections(self, maxConnections): self.maxConnections = maxConnections
    def get_minConnections(self): return self.minConnections
    def set_minConnections(self, minConnections): self.minConnections = minConnections
    def hasContent_(self):
        if (
            self.maxConnections != 0 or
            self.minConnections != 1
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='connectionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('connectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='connectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='connectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='connectionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='connectionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.maxConnections is not None:
            self.maxConnections.export(outfile, level, namespace_, name_='maxConnections', pretty_print=pretty_print)
        if self.minConnections is not None:
            self.minConnections.export(outfile, level, namespace_, name_='minConnections', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'maxConnections':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.maxConnections = obj_
            obj_.original_tagname_ = 'maxConnections'
        elif nodeName_ == 'minConnections':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.minConnections = obj_
            obj_.original_tagname_ = 'minConnections'
# end class connectionType


class accessHandlesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'leafAccessHandle', 1, 0, {'type': 'leafAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType.subclass:
            return accessHandlesType.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = leafAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType


class cellFunctionType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('other', 'xs:token', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['cellFunctionValueType', 'xs:token'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, other=None, valueOf_=None):
        self.original_tagname_ = None
        self.other = _cast(None, other)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cellFunctionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cellFunctionType.subclass:
            return cellFunctionType.subclass(*args_, **kwargs_)
        else:
            return cellFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_other(self): return self.other
    def set_other(self, other): self.other = other
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='cellFunctionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cellFunctionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cellFunctionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='cellFunctionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='cellFunctionType'):
        if self.other is not None and 'other' not in already_processed:
            already_processed.add('other')
            outfile.write(' other=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.other), input_name='other')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='cellFunctionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('other', node)
        if value is not None and 'other' not in already_processed:
            already_processed.add('other')
            self.other = value
            self.other = ' '.join(self.other.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cellFunctionType


class vectorType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('left', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'name': 'left'}, None),
        MemberSpec_('right', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'name': 'right'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, left=None, right=None):
        self.original_tagname_ = None
        self.left = left
        self.right = right
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, vectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if vectorType.subclass:
            return vectorType.subclass(*args_, **kwargs_)
        else:
            return vectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_left(self): return self.left
    def set_left(self, left): self.left = left
    def get_right(self): return self.right
    def set_right(self, right): self.right = right
    def hasContent_(self):
        if (
            self.left is not None or
            self.right is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='vectorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('vectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='vectorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='vectorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='vectorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.left is not None:
            self.left.export(outfile, level, namespace_, name_='left', pretty_print=pretty_print)
        if self.right is not None:
            self.right.export(outfile, level, namespace_, name_='right', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'left':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.left = obj_
            obj_.original_tagname_ = 'left'
        elif nodeName_ == 'right':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.right = obj_
            obj_.original_tagname_ = 'right'
# end class vectorType


class isIncludeFileType(GeneratedsSuper):
    """the File contains some declarations that are needed in top file"""
    member_data_items_ = [
        MemberSpec_('externalDeclarations', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:boolean', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, externalDeclarations=False, valueOf_=None):
        self.original_tagname_ = None
        self.externalDeclarations = _cast(bool, externalDeclarations)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, isIncludeFileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if isIncludeFileType.subclass:
            return isIncludeFileType.subclass(*args_, **kwargs_)
        else:
            return isIncludeFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_externalDeclarations(self): return self.externalDeclarations
    def set_externalDeclarations(self, externalDeclarations): self.externalDeclarations = externalDeclarations
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='isIncludeFileType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('isIncludeFileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isIncludeFileType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='isIncludeFileType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='isIncludeFileType'):
        if self.externalDeclarations and 'externalDeclarations' not in already_processed:
            already_processed.add('externalDeclarations')
            outfile.write(' externalDeclarations="%s"' % self.gds_format_boolean(self.externalDeclarations, input_name='externalDeclarations'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='isIncludeFileType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('externalDeclarations', node)
        if value is not None and 'externalDeclarations' not in already_processed:
            already_processed.add('externalDeclarations')
            if value in ('true', '1'):
                self.externalDeclarations = True
            elif value in ('false', '0'):
                self.externalDeclarations = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class isIncludeFileType


class logicalNameType(GeneratedsSuper):
    """The logical name shall only be used as a default and another process
    may override this name."""
    member_data_items_ = [
        MemberSpec_('default', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, default=False, valueOf_=None):
        self.original_tagname_ = None
        self.default = _cast(bool, default)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, logicalNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if logicalNameType.subclass:
            return logicalNameType.subclass(*args_, **kwargs_)
        else:
            return logicalNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='logicalNameType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('logicalNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='logicalNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='logicalNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='logicalNameType'):
        if self.default and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_boolean(self.default, input_name='default'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='logicalNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            if value in ('true', '1'):
                self.default = True
            elif value in ('false', '0'):
                self.default = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class logicalNameType


class exportedNameType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exportedNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exportedNameType.subclass:
            return exportedNameType.subclass(*args_, **kwargs_)
        else:
            return exportedNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='exportedNameType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exportedNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exportedNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='exportedNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='exportedNameType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='exportedNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exportedNameType


class buildCommandType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('command', 'stringExpression', 0, 1, {'minOccurs': '0', 'type': 'stringExpression', 'name': 'command'}, None),
        MemberSpec_('flags', 'flagsType', 0, 1, {'minOccurs': '0', 'type': 'flagsType', 'name': 'flags'}, None),
        MemberSpec_('replaceDefaultFlags', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'name': 'replaceDefaultFlags'}, None),
        MemberSpec_('targetName', 'stringURIExpression', 0, 1, {'minOccurs': '0', 'type': 'stringURIExpression', 'name': 'targetName'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, command=None, flags=None, replaceDefaultFlags=None, targetName=None):
        self.original_tagname_ = None
        self.command = command
        self.flags = flags
        self.replaceDefaultFlags = replaceDefaultFlags
        self.targetName = targetName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, buildCommandType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if buildCommandType.subclass:
            return buildCommandType.subclass(*args_, **kwargs_)
        else:
            return buildCommandType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_command(self): return self.command
    def set_command(self, command): self.command = command
    def get_flags(self): return self.flags
    def set_flags(self, flags): self.flags = flags
    def get_replaceDefaultFlags(self): return self.replaceDefaultFlags
    def set_replaceDefaultFlags(self, replaceDefaultFlags): self.replaceDefaultFlags = replaceDefaultFlags
    def get_targetName(self): return self.targetName
    def set_targetName(self, targetName): self.targetName = targetName
    def hasContent_(self):
        if (
            self.command is not None or
            self.flags is not None or
            self.replaceDefaultFlags is not None or
            self.targetName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='buildCommandType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('buildCommandType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='buildCommandType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='buildCommandType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='buildCommandType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='buildCommandType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.command is not None:
            self.command.export(outfile, level, namespace_, name_='command', pretty_print=pretty_print)
        if self.flags is not None:
            self.flags.export(outfile, level, namespace_, name_='flags', pretty_print=pretty_print)
        if self.replaceDefaultFlags is not None:
            self.replaceDefaultFlags.export(outfile, level, namespace_, name_='replaceDefaultFlags', pretty_print=pretty_print)
        if self.targetName is not None:
            self.targetName.export(outfile, level, namespace_, name_='targetName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'command':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.command = obj_
            obj_.original_tagname_ = 'command'
        elif nodeName_ == 'flags':
            obj_ = flagsType.factory()
            obj_.build(child_)
            self.flags = obj_
            obj_.original_tagname_ = 'flags'
        elif nodeName_ == 'replaceDefaultFlags':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.replaceDefaultFlags = obj_
            obj_.original_tagname_ = 'replaceDefaultFlags'
        elif nodeName_ == 'targetName':
            obj_ = stringURIExpression.factory()
            obj_.build(child_)
            self.targetName = obj_
            obj_.original_tagname_ = 'targetName'
# end class buildCommandType


class imageTypeType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:string', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, imageTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if imageTypeType.subclass:
            return imageTypeType.subclass(*args_, **kwargs_)
        else:
            return imageTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='imageTypeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('imageTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='imageTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='imageTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='imageTypeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='imageTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class imageTypeType


class languageToolsType(GeneratedsSuper):
    """If a languageTools element contains a linkerFlags element or a
    linkerCommandFile element, it shall also contain a linker
    element."""
    member_data_items_ = [
        MemberSpec_('fileBuilder', 'fileBuilderType16', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'fileBuilder', 'type': 'fileBuilderType16'}, None),
        MemberSpec_('linker', 'stringExpression', 0, 0, {'minOccurs': '1', 'type': 'stringExpression', 'name': 'linker'}, None),
        MemberSpec_('linkerFlags', 'stringExpression', 0, 0, {'minOccurs': '1', 'type': 'stringExpression', 'name': 'linkerFlags'}, 27),
        MemberSpec_('linkerCommandFile', 'linkerCommandFile', 0, 0, {'minOccurs': '1', 'type': 'linkerCommandFile', 'ref': 'linkerCommandFile', 'name': 'linkerCommandFile'}, 27),
    ]
    subclass = None
    superclass = None
    def __init__(self, fileBuilder=None, linker=None, linkerFlags=None, linkerCommandFile=None):
        self.original_tagname_ = None
        if fileBuilder is None:
            self.fileBuilder = []
        else:
            self.fileBuilder = fileBuilder
        self.linker = linker
        self.linkerFlags = linkerFlags
        self.linkerCommandFile = linkerCommandFile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, languageToolsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if languageToolsType.subclass:
            return languageToolsType.subclass(*args_, **kwargs_)
        else:
            return languageToolsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileBuilder(self): return self.fileBuilder
    def set_fileBuilder(self, fileBuilder): self.fileBuilder = fileBuilder
    def add_fileBuilder(self, value): self.fileBuilder.append(value)
    def insert_fileBuilder_at(self, index, value): self.fileBuilder.insert(index, value)
    def replace_fileBuilder_at(self, index, value): self.fileBuilder[index] = value
    def get_linker(self): return self.linker
    def set_linker(self, linker): self.linker = linker
    def get_linkerFlags(self): return self.linkerFlags
    def set_linkerFlags(self, linkerFlags): self.linkerFlags = linkerFlags
    def get_linkerCommandFile(self): return self.linkerCommandFile
    def set_linkerCommandFile(self, linkerCommandFile): self.linkerCommandFile = linkerCommandFile
    def hasContent_(self):
        if (
            self.fileBuilder or
            self.linker is not None or
            self.linkerFlags is not None or
            self.linkerCommandFile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='languageToolsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('languageToolsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='languageToolsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='languageToolsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='languageToolsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='languageToolsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fileBuilder_ in self.fileBuilder:
            fileBuilder_.export(outfile, level, namespace_, name_='fileBuilder', pretty_print=pretty_print)
        if self.linker is not None:
            self.linker.export(outfile, level, namespace_, name_='linker', pretty_print=pretty_print)
        if self.linkerFlags is not None:
            self.linkerFlags.export(outfile, level, namespace_, name_='linkerFlags', pretty_print=pretty_print)
        if self.linkerCommandFile is not None:
            self.linkerCommandFile.export(outfile, level, namespace_='ipxact:', name_='linkerCommandFile', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileBuilder':
            obj_ = fileBuilderType16.factory()
            obj_.build(child_)
            self.fileBuilder.append(obj_)
            obj_.original_tagname_ = 'fileBuilder'
        elif nodeName_ == 'linker':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.linker = obj_
            obj_.original_tagname_ = 'linker'
        elif nodeName_ == 'linkerFlags':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.linkerFlags = obj_
            obj_.original_tagname_ = 'linkerFlags'
        elif nodeName_ == 'linkerCommandFile':
            obj_ = linkerCommandFile.factory()
            obj_.build(child_)
            self.linkerCommandFile = obj_
            obj_.original_tagname_ = 'linkerCommandFile'
# end class languageToolsType


class fileBuilderType16(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('fileType', 'fileType', 0, 0, {'type': 'fileType', 'ref': 'fileType', 'name': 'fileType'}, None),
        MemberSpec_('command', 'stringExpression', 0, 0, {'type': 'stringExpression', 'name': 'command'}, None),
        MemberSpec_('flags', 'stringExpression', 0, 1, {'minOccurs': '0', 'type': 'stringExpression', 'name': 'flags'}, None),
        MemberSpec_('replaceDefaultFlags', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'name': 'replaceDefaultFlags'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, fileType=None, command=None, flags=None, replaceDefaultFlags=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.fileType = fileType
        self.command = command
        self.flags = flags
        self.replaceDefaultFlags = replaceDefaultFlags
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileBuilderType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileBuilderType16.subclass:
            return fileBuilderType16.subclass(*args_, **kwargs_)
        else:
            return fileBuilderType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileType(self): return self.fileType
    def set_fileType(self, fileType): self.fileType = fileType
    def get_command(self): return self.command
    def set_command(self, command): self.command = command
    def get_flags(self): return self.flags
    def set_flags(self, flags): self.flags = flags
    def get_replaceDefaultFlags(self): return self.replaceDefaultFlags
    def set_replaceDefaultFlags(self, replaceDefaultFlags): self.replaceDefaultFlags = replaceDefaultFlags
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.fileType is not None or
            self.command is not None or
            self.flags is not None or
            self.replaceDefaultFlags is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='fileBuilderType16', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileBuilderType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileBuilderType16')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='fileBuilderType16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='fileBuilderType16'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='fileBuilderType16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fileType is not None:
            self.fileType.export(outfile, level, namespace_='ipxact:', name_='fileType', pretty_print=pretty_print)
        if self.command is not None:
            self.command.export(outfile, level, namespace_, name_='command', pretty_print=pretty_print)
        if self.flags is not None:
            self.flags.export(outfile, level, namespace_, name_='flags', pretty_print=pretty_print)
        if self.replaceDefaultFlags is not None:
            self.replaceDefaultFlags.export(outfile, level, namespace_, name_='replaceDefaultFlags', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileType':
            obj_ = fileType.factory()
            obj_.build(child_)
            self.fileType = obj_
            obj_.original_tagname_ = 'fileType'
        elif nodeName_ == 'command':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.command = obj_
            obj_.original_tagname_ = 'command'
        elif nodeName_ == 'flags':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.flags = obj_
            obj_.original_tagname_ = 'flags'
        elif nodeName_ == 'replaceDefaultFlags':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.replaceDefaultFlags = obj_
            obj_.original_tagname_ = 'replaceDefaultFlags'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class fileBuilderType16


class fileSetRefGroupType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('fileSetRef', 'fileSetRef', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'fileSetRef', 'name': 'fileSetRef', 'type': 'fileSetRef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, fileSetRef=None):
        self.original_tagname_ = None
        if fileSetRef is None:
            self.fileSetRef = []
        else:
            self.fileSetRef = fileSetRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSetRefGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSetRefGroupType.subclass:
            return fileSetRefGroupType.subclass(*args_, **kwargs_)
        else:
            return fileSetRefGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileSetRef(self): return self.fileSetRef
    def set_fileSetRef(self, fileSetRef): self.fileSetRef = fileSetRef
    def add_fileSetRef(self, value): self.fileSetRef.append(value)
    def insert_fileSetRef_at(self, index, value): self.fileSetRef.insert(index, value)
    def replace_fileSetRef_at(self, index, value): self.fileSetRef[index] = value
    def hasContent_(self):
        if (
            self.fileSetRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='fileSetRefGroupType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSetRefGroupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileSetRefGroupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='fileSetRefGroupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='fileSetRefGroupType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='fileSetRefGroupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fileSetRef_ in self.fileSetRef:
            fileSetRef_.export(outfile, level, namespace_='ipxact:', name_='fileSetRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fileSetRef':
            obj_ = fileSetRef.factory()
            obj_.build(child_)
            self.fileSetRef.append(obj_)
            obj_.original_tagname_ = 'fileSetRef'
# end class fileSetRefGroupType


class groupType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupType.subclass:
            return groupType.subclass(*args_, **kwargs_)
        else:
            return groupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='groupType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('groupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='groupType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='groupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='groupType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='groupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class groupType


class functionType(GeneratedsSuper):
    """If true directs the generator to compile a separate object module
    for each instance of the component in the design. If false
    (default) the function will be called with different arguments
    for each instance."""
    member_data_items_ = [
        MemberSpec_('replicate', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('entryPoint', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'entryPoint'}, None),
        MemberSpec_('fileRef', 'xs:token', 0, 0, {'type': 'xs:token', 'name': 'fileRef'}, None),
        MemberSpec_('returnType', ['returnTypeType', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'name': 'returnType'}, None),
        MemberSpec_('argument', 'argumentType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'argument', 'type': 'argumentType'}, None),
        MemberSpec_('disabled', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'name': 'disabled'}, None),
        MemberSpec_('sourceFile', 'sourceFileType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'sourceFile', 'type': 'sourceFileType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, replicate=False, id=None, entryPoint=None, fileRef=None, returnType=None, argument=None, disabled=None, sourceFile=None):
        self.original_tagname_ = None
        self.replicate = _cast(bool, replicate)
        self.id = _cast(None, id)
        self.entryPoint = entryPoint
        self.fileRef = fileRef
        self.returnType = returnType
        self.validate_returnTypeType(self.returnType)
        if argument is None:
            self.argument = []
        else:
            self.argument = argument
        self.disabled = disabled
        if sourceFile is None:
            self.sourceFile = []
        else:
            self.sourceFile = sourceFile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, functionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if functionType.subclass:
            return functionType.subclass(*args_, **kwargs_)
        else:
            return functionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entryPoint(self): return self.entryPoint
    def set_entryPoint(self, entryPoint): self.entryPoint = entryPoint
    def get_fileRef(self): return self.fileRef
    def set_fileRef(self, fileRef): self.fileRef = fileRef
    def get_returnType(self): return self.returnType
    def set_returnType(self, returnType): self.returnType = returnType
    def get_argument(self): return self.argument
    def set_argument(self, argument): self.argument = argument
    def add_argument(self, value): self.argument.append(value)
    def insert_argument_at(self, index, value): self.argument.insert(index, value)
    def replace_argument_at(self, index, value): self.argument[index] = value
    def get_disabled(self): return self.disabled
    def set_disabled(self, disabled): self.disabled = disabled
    def get_sourceFile(self): return self.sourceFile
    def set_sourceFile(self, sourceFile): self.sourceFile = sourceFile
    def add_sourceFile(self, value): self.sourceFile.append(value)
    def insert_sourceFile_at(self, index, value): self.sourceFile.insert(index, value)
    def replace_sourceFile_at(self, index, value): self.sourceFile[index] = value
    def get_replicate(self): return self.replicate
    def set_replicate(self, replicate): self.replicate = replicate
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_returnTypeType(self, value):
        # Validate type returnTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['void', 'int']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on returnTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.entryPoint is not None or
            self.fileRef is not None or
            self.returnType is not None or
            self.argument or
            self.disabled is not None or
            self.sourceFile
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='functionType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('functionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='functionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='functionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='functionType'):
        if self.replicate and 'replicate' not in already_processed:
            already_processed.add('replicate')
            outfile.write(' replicate="%s"' % self.gds_format_boolean(self.replicate, input_name='replicate'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='functionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entryPoint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:entryPoint>%s</ipxact:entryPoint>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.entryPoint), input_name='entryPoint')), eol_))
        if self.fileRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:fileRef>%s</ipxact:fileRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.fileRef), input_name='fileRef')), eol_))
        if self.returnType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:returnType>%s</ipxact:returnType>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.returnType), input_name='returnType')), eol_))
        for argument_ in self.argument:
            argument_.export(outfile, level, namespace_, name_='argument', pretty_print=pretty_print)
        if self.disabled is not None:
            self.disabled.export(outfile, level, namespace_, name_='disabled', pretty_print=pretty_print)
        for sourceFile_ in self.sourceFile:
            sourceFile_.export(outfile, level, namespace_, name_='sourceFile', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('replicate', node)
        if value is not None and 'replicate' not in already_processed:
            already_processed.add('replicate')
            if value in ('true', '1'):
                self.replicate = True
            elif value in ('false', '0'):
                self.replicate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entryPoint':
            entryPoint_ = child_.text
            entryPoint_ = self.gds_validate_string(entryPoint_, node, 'entryPoint')
            self.entryPoint = entryPoint_
        elif nodeName_ == 'fileRef':
            fileRef_ = child_.text
            if fileRef_:
                fileRef_ = re_.sub(String_cleanup_pat_, " ", fileRef_).strip()
            else:
                fileRef_ = ""
            fileRef_ = self.gds_validate_string(fileRef_, node, 'fileRef')
            self.fileRef = fileRef_
        elif nodeName_ == 'returnType':
            returnType_ = child_.text
            returnType_ = self.gds_validate_string(returnType_, node, 'returnType')
            self.returnType = returnType_
            # validate type returnTypeType
            self.validate_returnTypeType(self.returnType)
        elif nodeName_ == 'argument':
            obj_ = argumentType.factory()
            obj_.build(child_)
            self.argument.append(obj_)
            obj_.original_tagname_ = 'argument'
        elif nodeName_ == 'disabled':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.disabled = obj_
            obj_.original_tagname_ = 'disabled'
        elif nodeName_ == 'sourceFile':
            obj_ = sourceFileType.factory()
            obj_.build(child_)
            self.sourceFile.append(obj_)
            obj_.original_tagname_ = 'sourceFile'
# end class functionType


class argumentType(nameValuePairType):
    """The data type of the argument as pertains to the language. Example:
    "int", "double", "char *"."""
    member_data_items_ = [
        MemberSpec_('dataType', 'ipxact:dataTypeType', 0, 0, {'use': 'required'}),
    ]
    subclass = None
    superclass = nameValuePairType
    def __init__(self, id=None, name=None, displayName=None, description=None, value=None, vendorExtensions=None, dataType=None):
        self.original_tagname_ = None
        super(argumentType, self).__init__(id, name, displayName, description, value, vendorExtensions, )
        self.dataType = _cast(None, dataType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, argumentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if argumentType.subclass:
            return argumentType.subclass(*args_, **kwargs_)
        else:
            return argumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def hasContent_(self):
        if (
            super(argumentType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='argumentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('argumentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='argumentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='argumentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='argumentType'):
        super(argumentType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='argumentType')
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (quote_attrib(self.dataType), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='argumentType', fromsubclass_=False, pretty_print=True):
        super(argumentType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
        super(argumentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(argumentType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class argumentType


class sourceFileType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('sourceName', 'ipxactURI', 0, 0, {'type': 'ipxactURI', 'name': 'sourceName'}, None),
        MemberSpec_('fileType', 'fileType', 0, 0, {'type': 'fileType', 'ref': 'fileType', 'name': 'fileType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, sourceName=None, fileType=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.sourceName = sourceName
        self.fileType = fileType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, sourceFileType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if sourceFileType.subclass:
            return sourceFileType.subclass(*args_, **kwargs_)
        else:
            return sourceFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sourceName(self): return self.sourceName
    def set_sourceName(self, sourceName): self.sourceName = sourceName
    def get_fileType(self): return self.fileType
    def set_fileType(self, fileType): self.fileType = fileType
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.sourceName is not None or
            self.fileType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='sourceFileType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('sourceFileType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sourceFileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='sourceFileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='sourceFileType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='sourceFileType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sourceName is not None:
            self.sourceName.export(outfile, level, namespace_, name_='sourceName', pretty_print=pretty_print)
        if self.fileType is not None:
            self.fileType.export(outfile, level, namespace_='ipxact:', name_='fileType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sourceName':
            class_obj_ = self.get_class_obj_(child_, ipxactURI)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.sourceName = obj_
            obj_.original_tagname_ = 'sourceName'
        elif nodeName_ == 'fileType':
            obj_ = fileType.factory()
            obj_.build(child_)
            self.fileType = obj_
            obj_.original_tagname_ = 'fileType'
# end class sourceFileType


class generatorChainSelectorType(GeneratedsSuper):
    """Specifies that only a single generator is valid in this context. If
    more that one generator is selcted based on the selection
    criteria, DE will prompt the user to resolve to a single
    generator."""
    member_data_items_ = [
        MemberSpec_('unique', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('groupSelector', 'groupSelector', 0, 0, {'type': 'groupSelector', 'ref': 'groupSelector', 'name': 'groupSelector'}, 28),
        MemberSpec_('generatorChainRef', 'configurableLibraryRefType', 0, 0, {'type': 'configurableLibraryRefType', 'name': 'generatorChainRef'}, 28),
    ]
    subclass = None
    superclass = None
    def __init__(self, unique=False, id=None, groupSelector=None, generatorChainRef=None):
        self.original_tagname_ = None
        self.unique = _cast(bool, unique)
        self.id = _cast(None, id)
        self.groupSelector = groupSelector
        self.generatorChainRef = generatorChainRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generatorChainSelectorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generatorChainSelectorType.subclass:
            return generatorChainSelectorType.subclass(*args_, **kwargs_)
        else:
            return generatorChainSelectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_groupSelector(self): return self.groupSelector
    def set_groupSelector(self, groupSelector): self.groupSelector = groupSelector
    def get_generatorChainRef(self): return self.generatorChainRef
    def set_generatorChainRef(self, generatorChainRef): self.generatorChainRef = generatorChainRef
    def get_unique(self): return self.unique
    def set_unique(self, unique): self.unique = unique
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.groupSelector is not None or
            self.generatorChainRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='generatorChainSelectorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generatorChainSelectorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='generatorChainSelectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='generatorChainSelectorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='generatorChainSelectorType'):
        if self.unique and 'unique' not in already_processed:
            already_processed.add('unique')
            outfile.write(' unique="%s"' % self.gds_format_boolean(self.unique, input_name='unique'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='generatorChainSelectorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.groupSelector is not None:
            self.groupSelector.export(outfile, level, namespace_='ipxact:', name_='groupSelector', pretty_print=pretty_print)
        if self.generatorChainRef is not None:
            self.generatorChainRef.export(outfile, level, namespace_, name_='generatorChainRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unique', node)
        if value is not None and 'unique' not in already_processed:
            already_processed.add('unique')
            if value in ('true', '1'):
                self.unique = True
            elif value in ('false', '0'):
                self.unique = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'groupSelector':
            obj_ = groupSelector.factory()
            obj_.build(child_)
            self.groupSelector = obj_
            obj_.original_tagname_ = 'groupSelector'
        elif nodeName_ == 'generatorChainRef':
            obj_ = ConfigurableLibraryRef.factory()
            obj_.build(child_)
            self.generatorChainRef = obj_
            obj_.original_tagname_ = 'generatorChainRef'
# end class generatorChainSelectorType


class chainGroupType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, chainGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if chainGroupType.subclass:
            return chainGroupType.subclass(*args_, **kwargs_)
        else:
            return chainGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='chainGroupType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('chainGroupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='chainGroupType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='chainGroupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='chainGroupType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='chainGroupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class chainGroupType


class nameType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, nameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if nameType.subclass:
            return nameType.subclass(*args_, **kwargs_)
        else:
            return nameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='nameType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('nameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='nameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='nameType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='nameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nameType


class groupType17(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, groupType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if groupType17.subclass:
            return groupType17.subclass(*args_, **kwargs_)
        else:
            return groupType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='groupType17', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('groupType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='groupType17')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='groupType17', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='groupType17'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='groupType17', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class groupType17


class apiTypeType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['apiType', 'xs:token'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, apiTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if apiTypeType.subclass:
            return apiTypeType.subclass(*args_, **kwargs_)
        else:
            return apiTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='apiTypeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('apiTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='apiTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='apiTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='apiTypeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='apiTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class apiTypeType


class transportMethodsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('transportMethod', 'transportMethodType18', 0, 0, {'type': 'transportMethodType18', 'name': 'transportMethod'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, transportMethod=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.transportMethod = transportMethod
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transportMethodsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transportMethodsType.subclass:
            return transportMethodsType.subclass(*args_, **kwargs_)
        else:
            return transportMethodsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_transportMethod(self): return self.transportMethod
    def set_transportMethod(self, transportMethod): self.transportMethod = transportMethod
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.transportMethod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='transportMethodsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transportMethodsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transportMethodsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='transportMethodsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='transportMethodsType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='transportMethodsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.transportMethod is not None:
            self.transportMethod.export(outfile, level, namespace_, name_='transportMethod', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'transportMethod':
            obj_ = transportMethodType18.factory()
            obj_.build(child_)
            self.transportMethod = obj_
            obj_.original_tagname_ = 'transportMethod'
# end class transportMethodsType


class transportMethodType18(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['transportMethodType', 'xs:token'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transportMethodType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transportMethodType18.subclass:
            return transportMethodType18.subclass(*args_, **kwargs_)
        else:
            return transportMethodType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='transportMethodType18', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transportMethodType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transportMethodType18')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='transportMethodType18', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='transportMethodType18'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='transportMethodType18', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class transportMethodType18


class whiteboxElementsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('whiteboxElement', 'whiteboxElementType', 1, 0, {'type': 'whiteboxElementType', 'name': 'whiteboxElement', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, whiteboxElement=None):
        self.original_tagname_ = None
        if whiteboxElement is None:
            self.whiteboxElement = []
        else:
            self.whiteboxElement = whiteboxElement
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, whiteboxElementsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if whiteboxElementsType.subclass:
            return whiteboxElementsType.subclass(*args_, **kwargs_)
        else:
            return whiteboxElementsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_whiteboxElement(self): return self.whiteboxElement
    def set_whiteboxElement(self, whiteboxElement): self.whiteboxElement = whiteboxElement
    def add_whiteboxElement(self, value): self.whiteboxElement.append(value)
    def insert_whiteboxElement_at(self, index, value): self.whiteboxElement.insert(index, value)
    def replace_whiteboxElement_at(self, index, value): self.whiteboxElement[index] = value
    def hasContent_(self):
        if (
            self.whiteboxElement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='whiteboxElementsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('whiteboxElementsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='whiteboxElementsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='whiteboxElementsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='whiteboxElementsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='whiteboxElementsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for whiteboxElement_ in self.whiteboxElement:
            whiteboxElement_.export(outfile, level, namespace_, name_='whiteboxElement', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'whiteboxElement':
            obj_ = whiteboxElementType.factory()
            obj_.build(child_)
            self.whiteboxElement.append(obj_)
            obj_.original_tagname_ = 'whiteboxElement'
# end class whiteboxElementsType


class cpusType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('cpu', 'cpuType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'cpu', 'type': 'cpuType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, cpu=None):
        self.original_tagname_ = None
        if cpu is None:
            self.cpu = []
        else:
            self.cpu = cpu
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cpusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cpusType.subclass:
            return cpusType.subclass(*args_, **kwargs_)
        else:
            return cpusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cpu(self): return self.cpu
    def set_cpu(self, cpu): self.cpu = cpu
    def add_cpu(self, value): self.cpu.append(value)
    def insert_cpu_at(self, index, value): self.cpu.insert(index, value)
    def replace_cpu_at(self, index, value): self.cpu[index] = value
    def hasContent_(self):
        if (
            self.cpu
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='cpusType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cpusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='cpusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='cpusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='cpusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cpu_ in self.cpu:
            cpu_.export(outfile, level, namespace_, name_='cpu', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cpu':
            obj_ = cpuType.factory()
            obj_.build(child_)
            self.cpu.append(obj_)
            obj_.original_tagname_ = 'cpu'
# end class cpusType


class cpuType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('addressSpaceRef', 'addrSpaceRefType', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'addressSpaceRef', 'name': 'addressSpaceRef', 'type': 'addrSpaceRefType'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, addressSpaceRef=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        if addressSpaceRef is None:
            self.addressSpaceRef = []
        else:
            self.addressSpaceRef = addressSpaceRef
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cpuType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cpuType.subclass:
            return cpuType.subclass(*args_, **kwargs_)
        else:
            return cpuType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressSpaceRef(self): return self.addressSpaceRef
    def set_addressSpaceRef(self, addressSpaceRef): self.addressSpaceRef = addressSpaceRef
    def add_addressSpaceRef(self, value): self.addressSpaceRef.append(value)
    def insert_addressSpaceRef_at(self, index, value): self.addressSpaceRef.insert(index, value)
    def replace_addressSpaceRef_at(self, index, value): self.addressSpaceRef[index] = value
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.addressSpaceRef or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='cpuType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cpuType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cpuType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='cpuType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='cpuType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='cpuType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for addressSpaceRef_ in self.addressSpaceRef:
            addressSpaceRef_.export(outfile, level, namespace_='ipxact:', name_='addressSpaceRef', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressSpaceRef':
            class_obj_ = self.get_class_obj_(child_, addrSpaceRefType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.addressSpaceRef.append(obj_)
            obj_.original_tagname_ = 'addressSpaceRef'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class cpuType


class resetTypesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('resetType', 'resetTypeType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'resetType', 'type': 'resetTypeType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, resetType=None):
        self.original_tagname_ = None
        if resetType is None:
            self.resetType = []
        else:
            self.resetType = resetType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resetTypesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resetTypesType.subclass:
            return resetTypesType.subclass(*args_, **kwargs_)
        else:
            return resetTypesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resetType(self): return self.resetType
    def set_resetType(self, resetType): self.resetType = resetType
    def add_resetType(self, value): self.resetType.append(value)
    def insert_resetType_at(self, index, value): self.resetType.insert(index, value)
    def replace_resetType_at(self, index, value): self.resetType[index] = value
    def hasContent_(self):
        if (
            self.resetType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='resetTypesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resetTypesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resetTypesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='resetTypesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='resetTypesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='resetTypesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for resetType_ in self.resetType:
            resetType_.export(outfile, level, namespace_, name_='resetType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resetType':
            obj_ = resetTypeType.factory()
            obj_.build(child_)
            self.resetType.append(obj_)
            obj_.original_tagname_ = 'resetType'
# end class resetTypesType


class resetTypeType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resetTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resetTypeType.subclass:
            return resetTypeType.subclass(*args_, **kwargs_)
        else:
            return resetTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='resetTypeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resetTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resetTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='resetTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='resetTypeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='resetTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class resetTypeType


class Master(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('addressSpaceRef', 'addrSpaceRefType', 0, 1, {'minOccurs': '0', 'type': 'addressSpaceRefType', 'name': 'addressSpaceRef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, addressSpaceRef=None):
        self.original_tagname_ = None
        self.addressSpaceRef = addressSpaceRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Master)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Master.subclass:
            return Master.subclass(*args_, **kwargs_)
        else:
            return Master(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_addressSpaceRef(self): return self.addressSpaceRef
    def set_addressSpaceRef(self, addressSpaceRef): self.addressSpaceRef = addressSpaceRef
    def hasContent_(self):
        if (
            self.addressSpaceRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='masterType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('masterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='masterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='masterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='masterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='masterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.addressSpaceRef is not None:
            self.addressSpaceRef.export(outfile, level, namespace_, name_='addressSpaceRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'addressSpaceRef':
            class_obj_ = self.get_class_obj_(child_, addrSpaceRefType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.addressSpaceRef = obj_
            obj_.original_tagname_ = 'addressSpaceRef'
# end class Master


class addressSpaceRefType(addrSpaceRefType):
    """If the master's mapping to the physical address space is not zero
    based, the baseAddress element may be used to indicate the
    offset. If not specified the offset is 0. The baseAddress is in
    units of the addressSpace addressUnitBits"""
    member_data_items_ = [
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 1, {'minOccurs': '0', 'type': 'signedLongintExpression', 'name': 'baseAddress'}, None),
    ]
    subclass = None
    superclass = addrSpaceRefType
    def __init__(self, addressSpaceRef=None, id=None, isPresent=None, baseAddress=None):
        self.original_tagname_ = None
        super(addressSpaceRefType, self).__init__(addressSpaceRef, id, isPresent, )
        self.baseAddress = baseAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressSpaceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressSpaceRefType.subclass:
            return addressSpaceRefType.subclass(*args_, **kwargs_)
        else:
            return addressSpaceRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseAddress(self): return self.baseAddress
    def set_baseAddress(self, baseAddress): self.baseAddress = baseAddress
    def hasContent_(self):
        if (
            self.baseAddress is not None or
            super(addressSpaceRefType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='addressSpaceRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressSpaceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='addressSpaceRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='addressSpaceRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='addressSpaceRefType'):
        super(addressSpaceRefType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='addressSpaceRefType')
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='addressSpaceRefType', fromsubclass_=False, pretty_print=True):
        super(addressSpaceRefType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.baseAddress is not None:
            self.baseAddress.export(outfile, level, namespace_, name_='baseAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(addressSpaceRefType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'baseAddress':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        super(addressSpaceRefType, self).buildChildren(child_, node, nodeName_, True)
# end class addressSpaceRefType


class Slave(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('memoryMapRef', 'memoryMapRefType', 0, 1, {'type': 'memoryMapRefType', 'ref': 'memoryMapRef', 'name': 'memoryMapRef'}, 29),
        MemberSpec_('transparentBridge', 'transparentBridge', 1, 1, {'maxOccurs': 'unbounded', 'ref': 'transparentBridge', 'name': 'transparentBridge', 'type': 'transparentBridge'}, 29),
        MemberSpec_('fileSetRefGroup', 'fileSetRefGroupType19', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'fileSetRefGroup', 'type': 'fileSetRefGroupType19'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, memoryMapRef=None, transparentBridge=None, fileSetRefGroup=None):
        self.original_tagname_ = None
        self.memoryMapRef = memoryMapRef
        if transparentBridge is None:
            self.transparentBridge = []
        else:
            self.transparentBridge = transparentBridge
        if fileSetRefGroup is None:
            self.fileSetRefGroup = []
        else:
            self.fileSetRefGroup = fileSetRefGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Slave)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Slave.subclass:
            return Slave.subclass(*args_, **kwargs_)
        else:
            return Slave(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_memoryMapRef(self): return self.memoryMapRef
    def set_memoryMapRef(self, memoryMapRef): self.memoryMapRef = memoryMapRef
    def get_transparentBridge(self): return self.transparentBridge
    def set_transparentBridge(self, transparentBridge): self.transparentBridge = transparentBridge
    def add_transparentBridge(self, value): self.transparentBridge.append(value)
    def insert_transparentBridge_at(self, index, value): self.transparentBridge.insert(index, value)
    def replace_transparentBridge_at(self, index, value): self.transparentBridge[index] = value
    def get_fileSetRefGroup(self): return self.fileSetRefGroup
    def set_fileSetRefGroup(self, fileSetRefGroup): self.fileSetRefGroup = fileSetRefGroup
    def add_fileSetRefGroup(self, value): self.fileSetRefGroup.append(value)
    def insert_fileSetRefGroup_at(self, index, value): self.fileSetRefGroup.insert(index, value)
    def replace_fileSetRefGroup_at(self, index, value): self.fileSetRefGroup[index] = value
    def hasContent_(self):
        if (
            self.memoryMapRef is not None or
            self.transparentBridge or
            self.fileSetRefGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='slaveType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('slaveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='slaveType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='slaveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='slaveType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='slaveType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.memoryMapRef is not None:
            self.memoryMapRef.export(outfile, level, namespace_='ipxact:', name_='memoryMapRef', pretty_print=pretty_print)
        for transparentBridge_ in self.transparentBridge:
            transparentBridge_.export(outfile, level, namespace_='ipxact:', name_='transparentBridge', pretty_print=pretty_print)
        for fileSetRefGroup_ in self.fileSetRefGroup:
            fileSetRefGroup_.export(outfile, level, namespace_, name_='fileSetRefGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'memoryMapRef':
            obj_ = memoryMapRefType.factory()
            obj_.build(child_)
            self.memoryMapRef = obj_
            obj_.original_tagname_ = 'memoryMapRef'
        elif nodeName_ == 'transparentBridge':
            obj_ = transparentBridge.factory()
            obj_.build(child_)
            self.transparentBridge.append(obj_)
            obj_.original_tagname_ = 'transparentBridge'
        elif nodeName_ == 'fileSetRefGroup':
            obj_ = fileSetRefGroupType19.factory()
            obj_.build(child_)
            self.fileSetRefGroup.append(obj_)
            obj_.original_tagname_ = 'fileSetRefGroup'
# end class Slave


class fileSetRefGroupType19(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('group', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'group'}, None),
        MemberSpec_('fileSetRef', 'fileSetRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'fileSetRef', 'name': 'fileSetRef', 'type': 'fileSetRef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, group=None, fileSetRef=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.group = group
        if fileSetRef is None:
            self.fileSetRef = []
        else:
            self.fileSetRef = fileSetRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSetRefGroupType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSetRefGroupType19.subclass:
            return fileSetRefGroupType19.subclass(*args_, **kwargs_)
        else:
            return fileSetRefGroupType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_fileSetRef(self): return self.fileSetRef
    def set_fileSetRef(self, fileSetRef): self.fileSetRef = fileSetRef
    def add_fileSetRef(self, value): self.fileSetRef.append(value)
    def insert_fileSetRef_at(self, index, value): self.fileSetRef.insert(index, value)
    def replace_fileSetRef_at(self, index, value): self.fileSetRef[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.group is not None or
            self.fileSetRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='fileSetRefGroupType19', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSetRefGroupType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileSetRefGroupType19')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='fileSetRefGroupType19', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='fileSetRefGroupType19'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='fileSetRefGroupType19', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
        for fileSetRef_ in self.fileSetRef:
            fileSetRef_.export(outfile, level, namespace_='ipxact:', name_='fileSetRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
        elif nodeName_ == 'fileSetRef':
            obj_ = fileSetRef.factory()
            obj_.build(child_)
            self.fileSetRef.append(obj_)
            obj_.original_tagname_ = 'fileSetRef'
# end class fileSetRefGroupType19


class systemType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'type': 'xs:Name', 'ref': 'group', 'name': 'group'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None):
        self.original_tagname_ = None
        self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, systemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if systemType.subclass:
            return systemType.subclass(*args_, **kwargs_)
        else:
            return systemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def hasContent_(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='systemType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('systemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='systemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='systemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='systemType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='systemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
# end class systemType


class mirroredSlaveType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('baseAddresses', 'baseAddressesType', 0, 1, {'minOccurs': '0', 'type': 'baseAddressesType', 'name': 'baseAddresses'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, baseAddresses=None):
        self.original_tagname_ = None
        self.baseAddresses = baseAddresses
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredSlaveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredSlaveType.subclass:
            return mirroredSlaveType.subclass(*args_, **kwargs_)
        else:
            return mirroredSlaveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseAddresses(self): return self.baseAddresses
    def set_baseAddresses(self, baseAddresses): self.baseAddresses = baseAddresses
    def hasContent_(self):
        if (
            self.baseAddresses is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='mirroredSlaveType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredSlaveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mirroredSlaveType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='mirroredSlaveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='mirroredSlaveType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='mirroredSlaveType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.baseAddresses is not None:
            self.baseAddresses.export(outfile, level, namespace_, name_='baseAddresses', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'baseAddresses':
            obj_ = baseAddressesType.factory()
            obj_.build(child_)
            self.baseAddresses = obj_
            obj_.original_tagname_ = 'baseAddresses'
# end class mirroredSlaveType


class baseAddressesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('remapAddress', 'remapAddressType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'remapAddress', 'type': 'remapAddressType'}, None),
        MemberSpec_('addressRange', 'unsignedPositiveLongintExpression', 0, 0, {'type': 'addressRange', 'ref': 'addressRange', 'name': 'addressRange'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, remapAddress=None, addressRange=None):
        self.original_tagname_ = None
        if remapAddress is None:
            self.remapAddress = []
        else:
            self.remapAddress = remapAddress
        self.addressRange = addressRange
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseAddressesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseAddressesType.subclass:
            return baseAddressesType.subclass(*args_, **kwargs_)
        else:
            return baseAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_remapAddress(self): return self.remapAddress
    def set_remapAddress(self, remapAddress): self.remapAddress = remapAddress
    def add_remapAddress(self, value): self.remapAddress.append(value)
    def insert_remapAddress_at(self, index, value): self.remapAddress.insert(index, value)
    def replace_remapAddress_at(self, index, value): self.remapAddress[index] = value
    def get_addressRange(self): return self.addressRange
    def set_addressRange(self, addressRange): self.addressRange = addressRange
    def hasContent_(self):
        if (
            self.remapAddress or
            self.addressRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='baseAddressesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('baseAddressesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='baseAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='baseAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='baseAddressesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='baseAddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remapAddress_ in self.remapAddress:
            remapAddress_.export(outfile, level, namespace_, name_='remapAddress', pretty_print=pretty_print)
        if self.addressRange is not None:
            self.addressRange.export(outfile, level, namespace_, name_='addressRange', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'remapAddress':
            obj_ = remapAddressType.factory()
            obj_.build(child_)
            self.remapAddress.append(obj_)
            obj_.original_tagname_ = 'remapAddress'
        elif nodeName_ == 'addressRange':
            obj_ = unsignedPositiveLongintExpression.factory()
            obj_.build(child_)
            self.addressRange = obj_
            obj_.original_tagname_ = 'addressRange'
# end class baseAddressesType


class mirroredMasterType(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredMasterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredMasterType.subclass:
            return mirroredMasterType.subclass(*args_, **kwargs_)
        else:
            return mirroredMasterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='mirroredMasterType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredMasterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mirroredMasterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='mirroredMasterType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='mirroredMasterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='mirroredMasterType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mirroredMasterType


class mirroredSystemType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'type': 'xs:Name', 'ref': 'group', 'name': 'group'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None):
        self.original_tagname_ = None
        self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredSystemType.subclass:
            return mirroredSystemType.subclass(*args_, **kwargs_)
        else:
            return mirroredSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def hasContent_(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='mirroredSystemType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredSystemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mirroredSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='mirroredSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='mirroredSystemType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='mirroredSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
# end class mirroredSystemType


class monitorType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('interfaceMode', 'xs:token', 0, 0, {'use': 'required'}),
        MemberSpec_('group', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'ref': 'group', 'name': 'group'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, interfaceMode=None, group=None):
        self.original_tagname_ = None
        self.interfaceMode = _cast(None, interfaceMode)
        self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monitorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monitorType.subclass:
            return monitorType.subclass(*args_, **kwargs_)
        else:
            return monitorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_interfaceMode(self): return self.interfaceMode
    def set_interfaceMode(self, interfaceMode): self.interfaceMode = interfaceMode
    def hasContent_(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='monitorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monitorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='monitorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='monitorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='monitorType'):
        if self.interfaceMode is not None and 'interfaceMode' not in already_processed:
            already_processed.add('interfaceMode')
            outfile.write(' interfaceMode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.interfaceMode), input_name='interfaceMode')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='monitorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interfaceMode', node)
        if value is not None and 'interfaceMode' not in already_processed:
            already_processed.add('interfaceMode')
            self.interfaceMode = value
            self.interfaceMode = ' '.join(self.interfaceMode.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
# end class monitorType


class channelType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('busInterfaceRef', 'busInterfaceRefType', 1, 0, {'minOccurs': '2', 'maxOccurs': 'unbounded', 'name': 'busInterfaceRef', 'type': 'busInterfaceRefType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, busInterfaceRef=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        if busInterfaceRef is None:
            self.busInterfaceRef = []
        else:
            self.busInterfaceRef = busInterfaceRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, channelType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if channelType.subclass:
            return channelType.subclass(*args_, **kwargs_)
        else:
            return channelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_busInterfaceRef(self): return self.busInterfaceRef
    def set_busInterfaceRef(self, busInterfaceRef): self.busInterfaceRef = busInterfaceRef
    def add_busInterfaceRef(self, value): self.busInterfaceRef.append(value)
    def insert_busInterfaceRef_at(self, index, value): self.busInterfaceRef.insert(index, value)
    def replace_busInterfaceRef_at(self, index, value): self.busInterfaceRef[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.busInterfaceRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='channelType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('channelType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='channelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='channelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='channelType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='channelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for busInterfaceRef_ in self.busInterfaceRef:
            busInterfaceRef_.export(outfile, level, namespace_, name_='busInterfaceRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'busInterfaceRef':
            obj_ = busInterfaceRefType.factory()
            obj_.build(child_)
            self.busInterfaceRef.append(obj_)
            obj_.original_tagname_ = 'busInterfaceRef'
# end class channelType


class busInterfaceRefType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('localName', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'localName'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, localName=None, isPresent=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.localName = localName
        self.isPresent = isPresent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, busInterfaceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if busInterfaceRefType.subclass:
            return busInterfaceRefType.subclass(*args_, **kwargs_)
        else:
            return busInterfaceRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_localName(self): return self.localName
    def set_localName(self, localName): self.localName = localName
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.localName is not None or
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='busInterfaceRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('busInterfaceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='busInterfaceRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='busInterfaceRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='busInterfaceRefType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='busInterfaceRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.localName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:localName>%s</ipxact:localName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.localName), input_name='localName')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'localName':
            localName_ = child_.text
            localName_ = self.gds_validate_string(localName_, node, 'localName')
            self.localName = localName_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class busInterfaceRefType


class remapStateType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('remapPorts', 'remapPortsType', 0, 1, {'minOccurs': '0', 'type': 'remapPortsType', 'name': 'remapPorts'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, remapPorts=None):
        self.original_tagname_ = None
        self.name = name
        self.displayName = displayName
        self.description = description
        self.remapPorts = remapPorts
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapStateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapStateType.subclass:
            return remapStateType.subclass(*args_, **kwargs_)
        else:
            return remapStateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_remapPorts(self): return self.remapPorts
    def set_remapPorts(self, remapPorts): self.remapPorts = remapPorts
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.remapPorts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='remapStateType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapStateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='remapStateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='remapStateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='remapStateType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='remapStateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.remapPorts is not None:
            self.remapPorts.export(outfile, level, namespace_, name_='remapPorts', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'remapPorts':
            obj_ = remapPortsType.factory()
            obj_.build(child_)
            self.remapPorts = obj_
            obj_.original_tagname_ = 'remapPorts'
# end class remapStateType


class remapPortsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('remapPort', 'remapPortType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'remapPort', 'type': 'remapPortType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, remapPort=None):
        self.original_tagname_ = None
        if remapPort is None:
            self.remapPort = []
        else:
            self.remapPort = remapPort
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapPortsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapPortsType.subclass:
            return remapPortsType.subclass(*args_, **kwargs_)
        else:
            return remapPortsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_remapPort(self): return self.remapPort
    def set_remapPort(self, remapPort): self.remapPort = remapPort
    def add_remapPort(self, value): self.remapPort.append(value)
    def insert_remapPort_at(self, index, value): self.remapPort.insert(index, value)
    def replace_remapPort_at(self, index, value): self.remapPort[index] = value
    def hasContent_(self):
        if (
            self.remapPort
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='remapPortsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapPortsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='remapPortsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='remapPortsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='remapPortsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='remapPortsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remapPort_ in self.remapPort:
            remapPort_.export(outfile, level, namespace_, name_='remapPort', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'remapPort':
            obj_ = remapPortType.factory()
            obj_.build(child_)
            self.remapPort.append(obj_)
            obj_.original_tagname_ = 'remapPort'
# end class remapPortsType


class remapPortType(GeneratedsSuper):
    """This attribute identifies a signal on the component which affects
    the component's memory layout"""
    member_data_items_ = [
        MemberSpec_('portRef', 'ipxact:portName', 0, 0, {'use': 'required'}),
        MemberSpec_('portIndex', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedIntExpression', 'name': 'portIndex'}, None),
        MemberSpec_('value', 'stringExpression', 0, 0, {'type': 'unsignedIntExpression', 'name': 'value'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, portRef=None, portIndex=None, value=None):
        self.original_tagname_ = None
        self.portRef = _cast(None, portRef)
        self.portIndex = portIndex
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapPortType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapPortType.subclass:
            return remapPortType.subclass(*args_, **kwargs_)
        else:
            return remapPortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_portIndex(self): return self.portIndex
    def set_portIndex(self, portIndex): self.portIndex = portIndex
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_portRef(self): return self.portRef
    def set_portRef(self, portRef): self.portRef = portRef
    def hasContent_(self):
        if (
            self.portIndex is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='remapPortType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapPortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='remapPortType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='remapPortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='remapPortType'):
        if self.portRef is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            outfile.write(' portRef=%s' % (quote_attrib(self.portRef), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='remapPortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.portIndex is not None:
            self.portIndex.export(outfile, level, namespace_, name_='portIndex', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('portRef', node)
        if value is not None and 'portRef' not in already_processed:
            already_processed.add('portRef')
            self.portRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'portIndex':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.portIndex = obj_
            obj_.original_tagname_ = 'portIndex'
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class remapPortType


class masterType20(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('addressSpaceRef', 'addrSpaceRefType', 0, 1, {'minOccurs': '0', 'type': 'addressSpaceRefType21', 'name': 'addressSpaceRef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, addressSpaceRef=None):
        self.original_tagname_ = None
        self.addressSpaceRef = addressSpaceRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, masterType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if masterType20.subclass:
            return masterType20.subclass(*args_, **kwargs_)
        else:
            return masterType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_addressSpaceRef(self): return self.addressSpaceRef
    def set_addressSpaceRef(self, addressSpaceRef): self.addressSpaceRef = addressSpaceRef
    def hasContent_(self):
        if (
            self.addressSpaceRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='masterType20', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('masterType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='masterType20')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='masterType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='masterType20'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='masterType20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.addressSpaceRef is not None:
            self.addressSpaceRef.export(outfile, level, namespace_, name_='addressSpaceRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'addressSpaceRef':
            class_obj_ = self.get_class_obj_(child_, addrSpaceRefType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.addressSpaceRef = obj_
            obj_.original_tagname_ = 'addressSpaceRef'
# end class masterType20


class addressSpaceRefType21(addrSpaceRefType):
    """If the master's mapping to the physical address space is not zero
    based, the baseAddress element may be used to indicate the
    offset. If not specified the offset is 0. The baseAddress is in
    units of the addressSpace addressUnitBits"""
    member_data_items_ = [
        MemberSpec_('baseAddress', 'unsignedLongintExpression', 0, 1, {'minOccurs': '0', 'type': 'signedLongintExpression', 'name': 'baseAddress'}, None),
    ]
    subclass = None
    superclass = addrSpaceRefType
    def __init__(self, addressSpaceRef=None, id=None, isPresent=None, baseAddress=None):
        self.original_tagname_ = None
        super(addressSpaceRefType21, self).__init__(addressSpaceRef, id, isPresent, )
        self.baseAddress = baseAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressSpaceRefType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressSpaceRefType21.subclass:
            return addressSpaceRefType21.subclass(*args_, **kwargs_)
        else:
            return addressSpaceRefType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseAddress(self): return self.baseAddress
    def set_baseAddress(self, baseAddress): self.baseAddress = baseAddress
    def hasContent_(self):
        if (
            self.baseAddress is not None or
            super(addressSpaceRefType21, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='addressSpaceRefType21', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressSpaceRefType21')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='addressSpaceRefType21')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='addressSpaceRefType21', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='addressSpaceRefType21'):
        super(addressSpaceRefType21, self).exportAttributes(outfile, level, already_processed, namespace_, name_='addressSpaceRefType21')
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='addressSpaceRefType21', fromsubclass_=False, pretty_print=True):
        super(addressSpaceRefType21, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.baseAddress is not None:
            self.baseAddress.export(outfile, level, namespace_, name_='baseAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(addressSpaceRefType21, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'baseAddress':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.baseAddress = obj_
            obj_.original_tagname_ = 'baseAddress'
        super(addressSpaceRefType21, self).buildChildren(child_, node, nodeName_, True)
# end class addressSpaceRefType21


class slaveType22(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('memoryMapRef', 'memoryMapRefType', 0, 1, {'type': 'memoryMapRefType', 'ref': 'memoryMapRef', 'name': 'memoryMapRef'}, 30),
        MemberSpec_('transparentBridge', 'transparentBridge', 1, 1, {'maxOccurs': 'unbounded', 'ref': 'transparentBridge', 'name': 'transparentBridge', 'type': 'transparentBridge'}, 30),
        MemberSpec_('fileSetRefGroup', 'fileSetRefGroupType23', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'fileSetRefGroup', 'type': 'fileSetRefGroupType23'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, memoryMapRef=None, transparentBridge=None, fileSetRefGroup=None):
        self.original_tagname_ = None
        self.memoryMapRef = memoryMapRef
        if transparentBridge is None:
            self.transparentBridge = []
        else:
            self.transparentBridge = transparentBridge
        if fileSetRefGroup is None:
            self.fileSetRefGroup = []
        else:
            self.fileSetRefGroup = fileSetRefGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, slaveType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if slaveType22.subclass:
            return slaveType22.subclass(*args_, **kwargs_)
        else:
            return slaveType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_memoryMapRef(self): return self.memoryMapRef
    def set_memoryMapRef(self, memoryMapRef): self.memoryMapRef = memoryMapRef
    def get_transparentBridge(self): return self.transparentBridge
    def set_transparentBridge(self, transparentBridge): self.transparentBridge = transparentBridge
    def add_transparentBridge(self, value): self.transparentBridge.append(value)
    def insert_transparentBridge_at(self, index, value): self.transparentBridge.insert(index, value)
    def replace_transparentBridge_at(self, index, value): self.transparentBridge[index] = value
    def get_fileSetRefGroup(self): return self.fileSetRefGroup
    def set_fileSetRefGroup(self, fileSetRefGroup): self.fileSetRefGroup = fileSetRefGroup
    def add_fileSetRefGroup(self, value): self.fileSetRefGroup.append(value)
    def insert_fileSetRefGroup_at(self, index, value): self.fileSetRefGroup.insert(index, value)
    def replace_fileSetRefGroup_at(self, index, value): self.fileSetRefGroup[index] = value
    def hasContent_(self):
        if (
            self.memoryMapRef is not None or
            self.transparentBridge or
            self.fileSetRefGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='slaveType22', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('slaveType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='slaveType22')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='slaveType22', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='slaveType22'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='slaveType22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.memoryMapRef is not None:
            self.memoryMapRef.export(outfile, level, namespace_='ipxact:', name_='memoryMapRef', pretty_print=pretty_print)
        for transparentBridge_ in self.transparentBridge:
            transparentBridge_.export(outfile, level, namespace_='ipxact:', name_='transparentBridge', pretty_print=pretty_print)
        for fileSetRefGroup_ in self.fileSetRefGroup:
            fileSetRefGroup_.export(outfile, level, namespace_, name_='fileSetRefGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'memoryMapRef':
            obj_ = memoryMapRefType.factory()
            obj_.build(child_)
            self.memoryMapRef = obj_
            obj_.original_tagname_ = 'memoryMapRef'
        elif nodeName_ == 'transparentBridge':
            obj_ = transparentBridge.factory()
            obj_.build(child_)
            self.transparentBridge.append(obj_)
            obj_.original_tagname_ = 'transparentBridge'
        elif nodeName_ == 'fileSetRefGroup':
            obj_ = fileSetRefGroupType23.factory()
            obj_.build(child_)
            self.fileSetRefGroup.append(obj_)
            obj_.original_tagname_ = 'fileSetRefGroup'
# end class slaveType22


class fileSetRefGroupType23(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('group', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'group'}, None),
        MemberSpec_('fileSetRef', 'fileSetRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'fileSetRef', 'name': 'fileSetRef', 'type': 'fileSetRef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, group=None, fileSetRef=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.group = group
        if fileSetRef is None:
            self.fileSetRef = []
        else:
            self.fileSetRef = fileSetRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fileSetRefGroupType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fileSetRefGroupType23.subclass:
            return fileSetRefGroupType23.subclass(*args_, **kwargs_)
        else:
            return fileSetRefGroupType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_fileSetRef(self): return self.fileSetRef
    def set_fileSetRef(self, fileSetRef): self.fileSetRef = fileSetRef
    def add_fileSetRef(self, value): self.fileSetRef.append(value)
    def insert_fileSetRef_at(self, index, value): self.fileSetRef.insert(index, value)
    def replace_fileSetRef_at(self, index, value): self.fileSetRef[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.group is not None or
            self.fileSetRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='fileSetRefGroupType23', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fileSetRefGroupType23')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fileSetRefGroupType23')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='fileSetRefGroupType23', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='fileSetRefGroupType23'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='fileSetRefGroupType23', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
        for fileSetRef_ in self.fileSetRef:
            fileSetRef_.export(outfile, level, namespace_='ipxact:', name_='fileSetRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
        elif nodeName_ == 'fileSetRef':
            obj_ = fileSetRef.factory()
            obj_.build(child_)
            self.fileSetRef.append(obj_)
            obj_.original_tagname_ = 'fileSetRef'
# end class fileSetRefGroupType23


class systemType24(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'type': 'xs:Name', 'ref': 'group', 'name': 'group'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None):
        self.original_tagname_ = None
        self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, systemType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if systemType24.subclass:
            return systemType24.subclass(*args_, **kwargs_)
        else:
            return systemType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def hasContent_(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='systemType24', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('systemType24')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='systemType24')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='systemType24', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='systemType24'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='systemType24', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
# end class systemType24


class mirroredSlaveType25(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('baseAddresses', 'baseAddressesType26', 0, 1, {'minOccurs': '0', 'type': 'baseAddressesType26', 'name': 'baseAddresses'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, baseAddresses=None):
        self.original_tagname_ = None
        self.baseAddresses = baseAddresses
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredSlaveType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredSlaveType25.subclass:
            return mirroredSlaveType25.subclass(*args_, **kwargs_)
        else:
            return mirroredSlaveType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_baseAddresses(self): return self.baseAddresses
    def set_baseAddresses(self, baseAddresses): self.baseAddresses = baseAddresses
    def hasContent_(self):
        if (
            self.baseAddresses is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='mirroredSlaveType25', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredSlaveType25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mirroredSlaveType25')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='mirroredSlaveType25', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='mirroredSlaveType25'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='mirroredSlaveType25', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.baseAddresses is not None:
            self.baseAddresses.export(outfile, level, namespace_, name_='baseAddresses', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'baseAddresses':
            obj_ = baseAddressesType26.factory()
            obj_.build(child_)
            self.baseAddresses = obj_
            obj_.original_tagname_ = 'baseAddresses'
# end class mirroredSlaveType25


class baseAddressesType26(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('remapAddress', 'remapAddressType27', 1, 0, {'maxOccurs': 'unbounded', 'name': 'remapAddress', 'type': 'remapAddressType27'}, None),
        MemberSpec_('addressRange', 'unsignedPositiveLongintExpression', 0, 0, {'type': 'addressRange', 'ref': 'addressRange', 'name': 'addressRange'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, remapAddress=None, addressRange=None):
        self.original_tagname_ = None
        if remapAddress is None:
            self.remapAddress = []
        else:
            self.remapAddress = remapAddress
        self.addressRange = addressRange
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, baseAddressesType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if baseAddressesType26.subclass:
            return baseAddressesType26.subclass(*args_, **kwargs_)
        else:
            return baseAddressesType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_remapAddress(self): return self.remapAddress
    def set_remapAddress(self, remapAddress): self.remapAddress = remapAddress
    def add_remapAddress(self, value): self.remapAddress.append(value)
    def insert_remapAddress_at(self, index, value): self.remapAddress.insert(index, value)
    def replace_remapAddress_at(self, index, value): self.remapAddress[index] = value
    def get_addressRange(self): return self.addressRange
    def set_addressRange(self, addressRange): self.addressRange = addressRange
    def hasContent_(self):
        if (
            self.remapAddress or
            self.addressRange is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='baseAddressesType26', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('baseAddressesType26')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='baseAddressesType26')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='baseAddressesType26', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='baseAddressesType26'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='baseAddressesType26', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for remapAddress_ in self.remapAddress:
            remapAddress_.export(outfile, level, namespace_, name_='remapAddress', pretty_print=pretty_print)
        if self.addressRange is not None:
            self.addressRange.export(outfile, level, namespace_, name_='addressRange', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'remapAddress':
            obj_ = remapAddressType27.factory()
            obj_.build(child_)
            self.remapAddress.append(obj_)
            obj_.original_tagname_ = 'remapAddress'
        elif nodeName_ == 'addressRange':
            obj_ = unsignedPositiveLongintExpression.factory()
            obj_.build(child_)
            self.addressRange = obj_
            obj_.original_tagname_ = 'addressRange'
# end class baseAddressesType26


class mirroredMasterType28(GeneratedsSuper):
    member_data_items_ = [
    ]
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredMasterType28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredMasterType28.subclass:
            return mirroredMasterType28.subclass(*args_, **kwargs_)
        else:
            return mirroredMasterType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='mirroredMasterType28', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredMasterType28')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mirroredMasterType28')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='mirroredMasterType28', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='mirroredMasterType28'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='mirroredMasterType28', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mirroredMasterType28


class mirroredSystemType29(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'type': 'xs:Name', 'ref': 'group', 'name': 'group'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None):
        self.original_tagname_ = None
        self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredSystemType29)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredSystemType29.subclass:
            return mirroredSystemType29.subclass(*args_, **kwargs_)
        else:
            return mirroredSystemType29(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def hasContent_(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='mirroredSystemType29', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredSystemType29')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mirroredSystemType29')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='mirroredSystemType29', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='mirroredSystemType29'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='mirroredSystemType29', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
# end class mirroredSystemType29


class monitorType30(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('interfaceMode', 'xs:token', 0, 0, {'use': 'required'}),
        MemberSpec_('group', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'ref': 'group', 'name': 'group'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, interfaceMode=None, group=None):
        self.original_tagname_ = None
        self.interfaceMode = _cast(None, interfaceMode)
        self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monitorType30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monitorType30.subclass:
            return monitorType30.subclass(*args_, **kwargs_)
        else:
            return monitorType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_interfaceMode(self): return self.interfaceMode
    def set_interfaceMode(self, interfaceMode): self.interfaceMode = interfaceMode
    def hasContent_(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='monitorType30', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monitorType30')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='monitorType30')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='monitorType30', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='monitorType30'):
        if self.interfaceMode is not None and 'interfaceMode' not in already_processed:
            already_processed.add('interfaceMode')
            outfile.write(' interfaceMode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.interfaceMode), input_name='interfaceMode')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='monitorType30', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interfaceMode', node)
        if value is not None and 'interfaceMode' not in already_processed:
            already_processed.add('interfaceMode')
            self.interfaceMode = value
            self.interfaceMode = ' '.join(self.interfaceMode.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
# end class monitorType30


class systemType31(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'type': 'xs:Name', 'ref': 'group', 'name': 'group'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None):
        self.original_tagname_ = None
        self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, systemType31)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if systemType31.subclass:
            return systemType31.subclass(*args_, **kwargs_)
        else:
            return systemType31(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def hasContent_(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='systemType31', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('systemType31')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='systemType31')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='systemType31', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='systemType31'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='systemType31', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
# end class systemType31


class mirroredSystemType32(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 0, {'type': 'xs:Name', 'ref': 'group', 'name': 'group'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None):
        self.original_tagname_ = None
        self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mirroredSystemType32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mirroredSystemType32.subclass:
            return mirroredSystemType32.subclass(*args_, **kwargs_)
        else:
            return mirroredSystemType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def hasContent_(self):
        if (
            self.group is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='mirroredSystemType32', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mirroredSystemType32')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mirroredSystemType32')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='mirroredSystemType32', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='mirroredSystemType32'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='mirroredSystemType32', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
# end class mirroredSystemType32


class AbstractionType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('viewRef', 'viewRef', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'viewRef', 'name': 'viewRef', 'type': 'viewRef'}, None),
        MemberSpec_('abstractionRef', 'configurableLibraryRefType', 0, 0, {'type': 'configurableLibraryRefType', 'name': 'abstractionRef'}, None),
        MemberSpec_('portMaps', 'portMapsType', 0, 1, {'minOccurs': '0', 'type': 'portMapsType', 'name': 'portMaps'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, viewRef=None, abstractionRef=None, portMaps=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if viewRef is None:
            self.viewRef = []
        else:
            self.viewRef = viewRef
        self.abstractionRef = abstractionRef
        self.portMaps = portMaps
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractionType.subclass:
            return AbstractionType.subclass(*args_, **kwargs_)
        else:
            return AbstractionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_viewRef(self): return self.viewRef
    def set_viewRef(self, viewRef): self.viewRef = viewRef
    def add_viewRef(self, value): self.viewRef.append(value)
    def insert_viewRef_at(self, index, value): self.viewRef.insert(index, value)
    def replace_viewRef_at(self, index, value): self.viewRef[index] = value
    def get_abstractionRef(self): return self.abstractionRef
    def set_abstractionRef(self, abstractionRef): self.abstractionRef = abstractionRef
    def get_portMaps(self): return self.portMaps
    def set_portMaps(self, portMaps): self.portMaps = portMaps
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.viewRef or
            self.abstractionRef is not None or
            self.portMaps is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractionTypeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractionTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractionTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractionTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractionTypeType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractionTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for viewRef_ in self.viewRef:
            viewRef_.export(outfile, level, namespace_='ipxact:', name_='viewRef', pretty_print=pretty_print)
        if self.abstractionRef is not None:
            self.abstractionRef.export(outfile, level, namespace_, name_='abstractionRef', pretty_print=pretty_print)
        if self.portMaps is not None:
            self.portMaps.export(outfile, level, namespace_, name_='portMaps', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'viewRef':
            obj_ = viewRef.factory()
            obj_.build(child_)
            self.viewRef.append(obj_)
            obj_.original_tagname_ = 'viewRef'
        elif nodeName_ == 'abstractionRef':
            obj_ = ConfigurableLibraryRef.factory()
            obj_.build(child_)
            self.abstractionRef = obj_
            obj_.original_tagname_ = 'abstractionRef'
        elif nodeName_ == 'portMaps':
            obj_ = PortMaps.factory()
            obj_.build(child_)
            self.portMaps = obj_
            obj_.original_tagname_ = 'portMaps'
# end class AbstractionType


class PortMaps(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('portMap', 'portMapType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'portMap', 'type': 'portMapType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, portMap=None):
        self.original_tagname_ = None
        if portMap is None:
            self.portMap = []
        else:
            self.portMap = portMap
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortMaps)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortMaps.subclass:
            return PortMaps.subclass(*args_, **kwargs_)
        else:
            return PortMaps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_portMap(self): return self.portMap
    def set_portMap(self, portMap): self.portMap = portMap
    def add_portMap(self, value): self.portMap.append(value)
    def insert_portMap_at(self, index, value): self.portMap.insert(index, value)
    def replace_portMap_at(self, index, value): self.portMap[index] = value
    def hasContent_(self):
        if (
            self.portMap
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='portMapsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portMapsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portMapsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='portMapsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='portMapsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='portMapsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for portMap_ in self.portMap:
            portMap_.export(outfile, level, namespace_, name_='portMap', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'portMap':
            obj_ = PortMap.factory()
            obj_.build(child_)
            self.portMap.append(obj_)
            obj_.original_tagname_ = 'portMap'
# end class PortMaps


class PortMap(GeneratedsSuper):
    """Indicates that the connection between the logical and physical ports
    should include an inversion."""
    member_data_items_ = [
        MemberSpec_('invert', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('logicalPort', 'logicalPortType', 0, 0, {'type': 'logicalPortType', 'name': 'logicalPort'}, None),
        MemberSpec_('physicalPort', 'physicalPortType', 0, 0, {'type': 'physicalPortType', 'name': 'physicalPort'}, 31),
        MemberSpec_('logicalTieOff', 'unsignedPositiveIntExpression', 0, 0, {'type': 'unsignedPositiveIntExpression', 'name': 'logicalTieOff'}, 31),
        MemberSpec_('isInformative', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'default': 'false', 'name': 'isInformative'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, invert='false', id=None, isPresent=None, logicalPort=None, physicalPort=None, logicalTieOff=None, isInformative=False):
        self.original_tagname_ = None
        self.invert = _cast(None, invert)
        self.id = _cast(None, id)
        self.isPresent = isPresent
        self.logicalPort = logicalPort
        self.physicalPort = physicalPort
        self.logicalTieOff = logicalTieOff
        self.isInformative = isInformative
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PortMap)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PortMap.subclass:
            return PortMap.subclass(*args_, **kwargs_)
        else:
            return PortMap(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_logicalPort(self): return self.logicalPort
    def set_logicalPort(self, logicalPort): self.logicalPort = logicalPort
    def get_physicalPort(self): return self.physicalPort
    def set_physicalPort(self, physicalPort): self.physicalPort = physicalPort
    def get_logicalTieOff(self): return self.logicalTieOff
    def set_logicalTieOff(self, logicalTieOff): self.logicalTieOff = logicalTieOff
    def get_isInformative(self): return self.isInformative
    def set_isInformative(self, isInformative): self.isInformative = isInformative
    def get_invert(self): return self.invert
    def set_invert(self, invert): self.invert = invert
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.isPresent is not None or
            self.logicalPort is not None or
            self.physicalPort is not None or
            self.logicalTieOff is not None or
            self.isInformative
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='portMapType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portMapType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='portMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='portMapType'):
        if self.invert != "false" and 'invert' not in already_processed:
            already_processed.add('invert')
            outfile.write(' invert=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.invert), input_name='invert')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='portMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.logicalPort is not None:
            self.logicalPort.export(outfile, level, namespace_, name_='logicalPort', pretty_print=pretty_print)
        if self.physicalPort is not None:
            self.physicalPort.export(outfile, level, namespace_, name_='physicalPort', pretty_print=pretty_print)
        if self.logicalTieOff is not None:
            self.logicalTieOff.export(outfile, level, namespace_, name_='logicalTieOff', pretty_print=pretty_print)
        if self.isInformative:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:isInformative>%s</ipxact:isInformative>%s' % (self.gds_format_boolean(self.isInformative, input_name='isInformative'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('invert', node)
        if value is not None and 'invert' not in already_processed:
            already_processed.add('invert')
            self.invert = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'logicalPort':
            obj_ = LogicalPort.factory()
            obj_.build(child_)
            self.logicalPort = obj_
            obj_.original_tagname_ = 'logicalPort'
        elif nodeName_ == 'physicalPort':
            obj_ = PhysicalPort.factory()
            obj_.build(child_)
            self.physicalPort = obj_
            obj_.original_tagname_ = 'physicalPort'
        elif nodeName_ == 'logicalTieOff':
            obj_ = unsignedPositiveIntExpression.factory()
            obj_.build(child_)
            self.logicalTieOff = obj_
            obj_.original_tagname_ = 'logicalTieOff'
        elif nodeName_ == 'isInformative':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isInformative')
            self.isInformative = ival_
# end class PortMap


class LogicalPort(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('Range', 'range', 0, 1, {'minOccurs': '0', 'type': 'range', 'ref': 'range', 'name': 'range'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, Range=None):
        self.original_tagname_ = None
        self.name = name
        self.Range = Range
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogicalPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogicalPort.subclass:
            return LogicalPort.subclass(*args_, **kwargs_)
        else:
            return LogicalPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_range(self): return self.Range
    def set_range(self, Range): self.Range = Range
    def hasContent_(self):
        if (
            self.name is not None or
            self.Range is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='logicalPortType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('logicalPortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='logicalPortType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='logicalPortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='logicalPortType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='logicalPortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.Range is not None:
            self.Range.export(outfile, level, namespace_='ipxact:', name_='range', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'range':
            obj_ = Range.factory()
            obj_.build(child_)
            self.Range = obj_
            obj_.original_tagname_ = 'range'
# end class LogicalPort


class PhysicalPort(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', ['portName', 'xs:string'], 0, 0, {'type': 'xs:string', 'name': 'name'}, None),
        MemberSpec_('PartSelect', 'partSelect', 0, 1, {'minOccurs': '0', 'type': 'partSelect', 'ref': 'partSelect', 'name': 'partSelect'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, PartSelect=None):
        self.original_tagname_ = None
        self.name = name
        self.validate_portName(self.name)
        self.PartSelect = PartSelect
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhysicalPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhysicalPort.subclass:
            return PhysicalPort.subclass(*args_, **kwargs_)
        else:
            return PhysicalPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_partSelect(self): return self.PartSelect
    def set_partSelect(self, PartSelect): self.PartSelect = PartSelect
    def validate_portName(self, value):
        # Validate type portName, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_portName_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_portName_patterns_, ))
    validate_portName_patterns_ = [['^[A-Za-z0-9\\.\\-:_]*$']]
    def hasContent_(self):
        if (
            self.name is not None or
            self.PartSelect is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='physicalPortType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('physicalPortType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='physicalPortType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='physicalPortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='physicalPortType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='physicalPortType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.PartSelect is not None:
            self.PartSelect.export(outfile, level, namespace_='ipxact:', name_='partSelect', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
            # validate type portName
            self.validate_portName(self.name)
        elif nodeName_ == 'partSelect':
            obj_ = PartSelect.factory()
            obj_.build(child_)
            self.PartSelect = obj_
            obj_.original_tagname_ = 'partSelect'
# end class PhysicalPort


class Ports(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('port', 'portType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'port', 'type': 'portType34'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, port=None):
        self.original_tagname_ = None
        if port is None:
            self.port = []
        else:
            self.port = port
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Ports)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Ports.subclass:
            return Ports.subclass(*args_, **kwargs_)
        else:
            return Ports(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def add_port(self, value): self.port.append(value)
    def insert_port_at(self, index, value): self.port.insert(index, value)
    def replace_port_at(self, index, value): self.port[index] = value
    def hasContent_(self):
        if (
            self.port
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='portsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='portsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='portsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='portsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for port_ in self.port:
            port_.export(outfile, level, namespace_, name_='port', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port':
            obj_ = Port.factory()
            obj_.build(child_)
            self.port.append(obj_)
            obj_.original_tagname_ = 'port'
# end class Ports


class portType34(GeneratedsSuper):
    """Port style."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('logicalName', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'logicalName'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('wire', 'wireType', 0, 0, {'type': 'wireType', 'name': 'wire'}, 32),
        MemberSpec_('transactional', 'transactionalType', 0, 0, {'type': 'transactionalType', 'name': 'transactional'}, 32),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, isPresent=None, logicalName=None, displayName=None, description=None, wire=None, transactional=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.isPresent = isPresent
        self.logicalName = logicalName
        self.displayName = displayName
        self.description = description
        self.wire = wire
        self.transactional = transactional
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portType34)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portType34.subclass:
            return portType34.subclass(*args_, **kwargs_)
        else:
            return portType34(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_logicalName(self): return self.logicalName
    def set_logicalName(self, logicalName): self.logicalName = logicalName
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_wire(self): return self.wire
    def set_wire(self, wire): self.wire = wire
    def get_transactional(self): return self.transactional
    def set_transactional(self, transactional): self.transactional = transactional
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.isPresent is not None or
            self.logicalName is not None or
            self.displayName is not None or
            self.description is not None or
            self.wire is not None or
            self.transactional is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='portType34', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portType34')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portType34')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='portType34', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='portType34'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='portType34', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.logicalName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:logicalName>%s</ipxact:logicalName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.logicalName), input_name='logicalName')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.wire is not None:
            self.wire.export(outfile, level, namespace_, name_='wire', pretty_print=pretty_print)
        if self.transactional is not None:
            self.transactional.export(outfile, level, namespace_, name_='transactional', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'logicalName':
            logicalName_ = child_.text
            logicalName_ = self.gds_validate_string(logicalName_, node, 'logicalName')
            self.logicalName = logicalName_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'wire':
            obj_ = wireType.factory()
            obj_.build(child_)
            self.wire = obj_
            obj_.original_tagname_ = 'wire'
        elif nodeName_ == 'transactional':
            obj_ = transactionalType.factory()
            obj_.build(child_)
            self.transactional = obj_
            obj_.original_tagname_ = 'transactional'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class portType34


class wireType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('qualifier', 'qualifierType', 0, 1, {'minOccurs': '0', 'type': 'qualifierType', 'name': 'qualifier'}, None),
        MemberSpec_('onSystem', 'onSystemType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'onSystem', 'type': 'onSystemType'}, None),
        MemberSpec_('onMaster', 'onMasterType', 0, 1, {'minOccurs': '0', 'type': 'onMasterType', 'name': 'onMaster'}, None),
        MemberSpec_('onSlave', 'onSlaveType', 0, 1, {'minOccurs': '0', 'type': 'onSlaveType', 'name': 'onSlave'}, None),
        MemberSpec_('defaultValue', 'unsignedBitVectorExpression', 0, 1, {'type': 'unsignedBitVectorExpression', 'name': 'defaultValue'}, 33),
        MemberSpec_('requiresDriver', 'requiresDriver', 0, 1, {'type': 'requiresDriver', 'ref': 'requiresDriver', 'name': 'requiresDriver'}, 33),
    ]
    subclass = None
    superclass = None
    def __init__(self, qualifier=None, onSystem=None, onMaster=None, onSlave=None, defaultValue=None, requiresDriver=None):
        self.original_tagname_ = None
        self.qualifier = qualifier
        if onSystem is None:
            self.onSystem = []
        else:
            self.onSystem = onSystem
        self.onMaster = onMaster
        self.onSlave = onSlave
        self.defaultValue = defaultValue
        self.requiresDriver = requiresDriver
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, wireType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if wireType.subclass:
            return wireType.subclass(*args_, **kwargs_)
        else:
            return wireType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_onSystem(self): return self.onSystem
    def set_onSystem(self, onSystem): self.onSystem = onSystem
    def add_onSystem(self, value): self.onSystem.append(value)
    def insert_onSystem_at(self, index, value): self.onSystem.insert(index, value)
    def replace_onSystem_at(self, index, value): self.onSystem[index] = value
    def get_onMaster(self): return self.onMaster
    def set_onMaster(self, onMaster): self.onMaster = onMaster
    def get_onSlave(self): return self.onSlave
    def set_onSlave(self, onSlave): self.onSlave = onSlave
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def get_requiresDriver(self): return self.requiresDriver
    def set_requiresDriver(self, requiresDriver): self.requiresDriver = requiresDriver
    def hasContent_(self):
        if (
            self.qualifier is not None or
            self.onSystem or
            self.onMaster is not None or
            self.onSlave is not None or
            self.defaultValue is not None or
            self.requiresDriver is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='wireType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('wireType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='wireType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='wireType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='wireType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='wireType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qualifier is not None:
            self.qualifier.export(outfile, level, namespace_, name_='qualifier', pretty_print=pretty_print)
        for onSystem_ in self.onSystem:
            onSystem_.export(outfile, level, namespace_, name_='onSystem', pretty_print=pretty_print)
        if self.onMaster is not None:
            self.onMaster.export(outfile, level, namespace_, name_='onMaster', pretty_print=pretty_print)
        if self.onSlave is not None:
            self.onSlave.export(outfile, level, namespace_, name_='onSlave', pretty_print=pretty_print)
        if self.defaultValue is not None:
            self.defaultValue.export(outfile, level, namespace_, name_='defaultValue', pretty_print=pretty_print)
        if self.requiresDriver is not None:
            self.requiresDriver.export(outfile, level, namespace_='ipxact:', name_='requiresDriver', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qualifier':
            obj_ = qualifierType.factory()
            obj_.build(child_)
            self.qualifier = obj_
            obj_.original_tagname_ = 'qualifier'
        elif nodeName_ == 'onSystem':
            obj_ = onSystemType.factory()
            obj_.build(child_)
            self.onSystem.append(obj_)
            obj_.original_tagname_ = 'onSystem'
        elif nodeName_ == 'onMaster':
            obj_ = onMasterType.factory()
            obj_.build(child_)
            self.onMaster = obj_
            obj_.original_tagname_ = 'onMaster'
        elif nodeName_ == 'onSlave':
            obj_ = onSlaveType.factory()
            obj_.build(child_)
            self.onSlave = obj_
            obj_.original_tagname_ = 'onSlave'
        elif nodeName_ == 'defaultValue':
            obj_ = unsignedBitVectorExpression.factory()
            obj_.build(child_)
            self.defaultValue = obj_
            obj_.original_tagname_ = 'defaultValue'
        elif nodeName_ == 'requiresDriver':
            obj_ = requiresDriver.factory()
            obj_.build(child_)
            self.requiresDriver = obj_
            obj_.original_tagname_ = 'requiresDriver'
# end class wireType


class qualifierType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('isAddress', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'name': 'isAddress'}, 34),
        MemberSpec_('isData', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'name': 'isData'}, 34),
        MemberSpec_('isClock', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'name': 'isClock'}, 34),
        MemberSpec_('isReset', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'name': 'isReset'}, 34),
    ]
    subclass = None
    superclass = None
    def __init__(self, isAddress=None, isData=None, isClock=None, isReset=None):
        self.original_tagname_ = None
        self.isAddress = isAddress
        self.isData = isData
        self.isClock = isClock
        self.isReset = isReset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qualifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qualifierType.subclass:
            return qualifierType.subclass(*args_, **kwargs_)
        else:
            return qualifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isAddress(self): return self.isAddress
    def set_isAddress(self, isAddress): self.isAddress = isAddress
    def get_isData(self): return self.isData
    def set_isData(self, isData): self.isData = isData
    def get_isClock(self): return self.isClock
    def set_isClock(self, isClock): self.isClock = isClock
    def get_isReset(self): return self.isReset
    def set_isReset(self, isReset): self.isReset = isReset
    def hasContent_(self):
        if (
            self.isAddress is not None or
            self.isData is not None or
            self.isClock is not None or
            self.isReset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='qualifierType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qualifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='qualifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='qualifierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='qualifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:isAddress>%s</ipxact:isAddress>%s' % (self.gds_format_boolean(self.isAddress, input_name='isAddress'), eol_))
        if self.isData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:isData>%s</ipxact:isData>%s' % (self.gds_format_boolean(self.isData, input_name='isData'), eol_))
        if self.isClock is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:isClock>%s</ipxact:isClock>%s' % (self.gds_format_boolean(self.isClock, input_name='isClock'), eol_))
        if self.isReset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:isReset>%s</ipxact:isReset>%s' % (self.gds_format_boolean(self.isReset, input_name='isReset'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isAddress':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAddress')
            self.isAddress = ival_
        elif nodeName_ == 'isData':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isData')
            self.isData = ival_
        elif nodeName_ == 'isClock':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isClock')
            self.isClock = ival_
        elif nodeName_ == 'isReset':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isReset')
            self.isReset = ival_
# end class qualifierType


class onSystemType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('group', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'group'}, None),
        MemberSpec_('presence', ['presenceType', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'presence', 'name': 'presence'}, None),
        MemberSpec_('width', 'unsignedPositiveIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedPositiveIntExpression', 'name': 'width'}, None),
        MemberSpec_('direction', ['direction', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'default': 'out', 'name': 'direction'}, None),
        MemberSpec_('modeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'type': 'abstractionDefPortConstraintsType', 'name': 'modeConstraints'}, None),
        MemberSpec_('mirroredModeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'type': 'abstractionDefPortConstraintsType', 'name': 'mirroredModeConstraints'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, group=None, presence=None, width=None, direction='out', modeConstraints=None, mirroredModeConstraints=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.group = group
        self.presence = presence
        self.validate_presenceType(self.presence)
        self.width = width
        self.direction = direction
        self.validate_direction(self.direction)
        self.modeConstraints = modeConstraints
        self.mirroredModeConstraints = mirroredModeConstraints
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onSystemType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onSystemType.subclass:
            return onSystemType.subclass(*args_, **kwargs_)
        else:
            return onSystemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_presence(self): return self.presence
    def set_presence(self, presence): self.presence = presence
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_modeConstraints(self): return self.modeConstraints
    def set_modeConstraints(self, modeConstraints): self.modeConstraints = modeConstraints
    def get_mirroredModeConstraints(self): return self.mirroredModeConstraints
    def set_mirroredModeConstraints(self, mirroredModeConstraints): self.mirroredModeConstraints = mirroredModeConstraints
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_presenceType(self, value):
        # Validate type presenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['required', 'illegal', 'optional']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on presenceType' % {"value" : value.encode("utf-8")} )
    def validate_direction(self, value):
        # Validate type direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['in', 'out', 'inout']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on direction' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.group is not None or
            self.presence is not None or
            self.width is not None or
            self.direction != "out" or
            self.modeConstraints is not None or
            self.mirroredModeConstraints is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='onSystemType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onSystemType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='onSystemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='onSystemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='onSystemType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='onSystemType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
        if self.presence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:presence>%s</ipxact:presence>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.presence), input_name='presence')), eol_))
        if self.width is not None:
            self.width.export(outfile, level, namespace_, name_='width', pretty_print=pretty_print)
        if self.direction != "out":
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:direction>%s</ipxact:direction>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), eol_))
        if self.modeConstraints is not None:
            self.modeConstraints.export(outfile, level, namespace_, name_='modeConstraints', pretty_print=pretty_print)
        if self.mirroredModeConstraints is not None:
            self.mirroredModeConstraints.export(outfile, level, namespace_, name_='mirroredModeConstraints', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
        elif nodeName_ == 'presence':
            presence_ = child_.text
            presence_ = self.gds_validate_string(presence_, node, 'presence')
            self.presence = presence_
            # validate type presenceType
            self.validate_presenceType(self.presence)
        elif nodeName_ == 'width':
            obj_ = unsignedPositiveIntExpression.factory()
            obj_.build(child_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'direction':
            direction_ = child_.text
            if direction_:
                direction_ = re_.sub(String_cleanup_pat_, " ", direction_).strip()
            else:
                direction_ = ""
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
            # validate type direction
            self.validate_direction(self.direction)
        elif nodeName_ == 'modeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory()
            obj_.build(child_)
            self.modeConstraints = obj_
            obj_.original_tagname_ = 'modeConstraints'
        elif nodeName_ == 'mirroredModeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory()
            obj_.build(child_)
            self.mirroredModeConstraints = obj_
            obj_.original_tagname_ = 'mirroredModeConstraints'
# end class onSystemType


class onMasterType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('presence', ['presenceType', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'presence', 'name': 'presence'}, None),
        MemberSpec_('width', 'unsignedPositiveIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedPositiveIntExpression', 'name': 'width'}, None),
        MemberSpec_('direction', ['direction', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'default': 'out', 'name': 'direction'}, None),
        MemberSpec_('modeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'type': 'abstractionDefPortConstraintsType', 'name': 'modeConstraints'}, None),
        MemberSpec_('mirroredModeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'type': 'abstractionDefPortConstraintsType', 'name': 'mirroredModeConstraints'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, presence=None, width=None, direction='out', modeConstraints=None, mirroredModeConstraints=None):
        self.original_tagname_ = None
        self.presence = presence
        self.validate_presenceType(self.presence)
        self.width = width
        self.direction = direction
        self.validate_direction(self.direction)
        self.modeConstraints = modeConstraints
        self.mirroredModeConstraints = mirroredModeConstraints
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onMasterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onMasterType.subclass:
            return onMasterType.subclass(*args_, **kwargs_)
        else:
            return onMasterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_presence(self): return self.presence
    def set_presence(self, presence): self.presence = presence
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_modeConstraints(self): return self.modeConstraints
    def set_modeConstraints(self, modeConstraints): self.modeConstraints = modeConstraints
    def get_mirroredModeConstraints(self): return self.mirroredModeConstraints
    def set_mirroredModeConstraints(self, mirroredModeConstraints): self.mirroredModeConstraints = mirroredModeConstraints
    def validate_presenceType(self, value):
        # Validate type presenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['required', 'illegal', 'optional']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on presenceType' % {"value" : value.encode("utf-8")} )
    def validate_direction(self, value):
        # Validate type direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['in', 'out', 'inout']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on direction' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.presence is not None or
            self.width is not None or
            self.direction != "out" or
            self.modeConstraints is not None or
            self.mirroredModeConstraints is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='onMasterType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onMasterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='onMasterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='onMasterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='onMasterType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='onMasterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.presence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:presence>%s</ipxact:presence>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.presence), input_name='presence')), eol_))
        if self.width is not None:
            self.width.export(outfile, level, namespace_, name_='width', pretty_print=pretty_print)
        if self.direction != "out":
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:direction>%s</ipxact:direction>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), eol_))
        if self.modeConstraints is not None:
            self.modeConstraints.export(outfile, level, namespace_, name_='modeConstraints', pretty_print=pretty_print)
        if self.mirroredModeConstraints is not None:
            self.mirroredModeConstraints.export(outfile, level, namespace_, name_='mirroredModeConstraints', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'presence':
            presence_ = child_.text
            presence_ = self.gds_validate_string(presence_, node, 'presence')
            self.presence = presence_
            # validate type presenceType
            self.validate_presenceType(self.presence)
        elif nodeName_ == 'width':
            obj_ = unsignedPositiveIntExpression.factory()
            obj_.build(child_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'direction':
            direction_ = child_.text
            if direction_:
                direction_ = re_.sub(String_cleanup_pat_, " ", direction_).strip()
            else:
                direction_ = ""
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
            # validate type direction
            self.validate_direction(self.direction)
        elif nodeName_ == 'modeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory()
            obj_.build(child_)
            self.modeConstraints = obj_
            obj_.original_tagname_ = 'modeConstraints'
        elif nodeName_ == 'mirroredModeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory()
            obj_.build(child_)
            self.mirroredModeConstraints = obj_
            obj_.original_tagname_ = 'mirroredModeConstraints'
# end class onMasterType


class onSlaveType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('presence', ['presenceType', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'presence', 'name': 'presence'}, None),
        MemberSpec_('width', 'unsignedPositiveIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedPositiveIntExpression', 'name': 'width'}, None),
        MemberSpec_('direction', ['direction', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'default': 'out', 'name': 'direction'}, None),
        MemberSpec_('modeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'type': 'abstractionDefPortConstraintsType', 'name': 'modeConstraints'}, None),
        MemberSpec_('mirroredModeConstraints', 'abstractionDefPortConstraintsType', 0, 1, {'minOccurs': '0', 'type': 'abstractionDefPortConstraintsType', 'name': 'mirroredModeConstraints'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, presence=None, width=None, direction='out', modeConstraints=None, mirroredModeConstraints=None):
        self.original_tagname_ = None
        self.presence = presence
        self.validate_presenceType(self.presence)
        self.width = width
        self.direction = direction
        self.validate_direction(self.direction)
        self.modeConstraints = modeConstraints
        self.mirroredModeConstraints = mirroredModeConstraints
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onSlaveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onSlaveType.subclass:
            return onSlaveType.subclass(*args_, **kwargs_)
        else:
            return onSlaveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_presence(self): return self.presence
    def set_presence(self, presence): self.presence = presence
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def get_modeConstraints(self): return self.modeConstraints
    def set_modeConstraints(self, modeConstraints): self.modeConstraints = modeConstraints
    def get_mirroredModeConstraints(self): return self.mirroredModeConstraints
    def set_mirroredModeConstraints(self, mirroredModeConstraints): self.mirroredModeConstraints = mirroredModeConstraints
    def validate_presenceType(self, value):
        # Validate type presenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['required', 'illegal', 'optional']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on presenceType' % {"value" : value.encode("utf-8")} )
    def validate_direction(self, value):
        # Validate type direction, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['in', 'out', 'inout']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on direction' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.presence is not None or
            self.width is not None or
            self.direction != "out" or
            self.modeConstraints is not None or
            self.mirroredModeConstraints is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='onSlaveType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onSlaveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='onSlaveType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='onSlaveType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='onSlaveType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='onSlaveType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.presence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:presence>%s</ipxact:presence>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.presence), input_name='presence')), eol_))
        if self.width is not None:
            self.width.export(outfile, level, namespace_, name_='width', pretty_print=pretty_print)
        if self.direction != "out":
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:direction>%s</ipxact:direction>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.direction), input_name='direction')), eol_))
        if self.modeConstraints is not None:
            self.modeConstraints.export(outfile, level, namespace_, name_='modeConstraints', pretty_print=pretty_print)
        if self.mirroredModeConstraints is not None:
            self.mirroredModeConstraints.export(outfile, level, namespace_, name_='mirroredModeConstraints', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'presence':
            presence_ = child_.text
            presence_ = self.gds_validate_string(presence_, node, 'presence')
            self.presence = presence_
            # validate type presenceType
            self.validate_presenceType(self.presence)
        elif nodeName_ == 'width':
            obj_ = unsignedPositiveIntExpression.factory()
            obj_.build(child_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'direction':
            direction_ = child_.text
            if direction_:
                direction_ = re_.sub(String_cleanup_pat_, " ", direction_).strip()
            else:
                direction_ = ""
            direction_ = self.gds_validate_string(direction_, node, 'direction')
            self.direction = direction_
            # validate type direction
            self.validate_direction(self.direction)
        elif nodeName_ == 'modeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory()
            obj_.build(child_)
            self.modeConstraints = obj_
            obj_.original_tagname_ = 'modeConstraints'
        elif nodeName_ == 'mirroredModeConstraints':
            obj_ = abstractionDefPortConstraintsType.factory()
            obj_.build(child_)
            self.mirroredModeConstraints = obj_
            obj_.original_tagname_ = 'mirroredModeConstraints'
# end class onSlaveType


class transactionalType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('qualifier', 'qualifierType35', 0, 1, {'minOccurs': '0', 'type': 'qualifierType35', 'name': 'qualifier'}, None),
        MemberSpec_('onSystem', 'onSystemType36', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'onSystem', 'type': 'onSystemType36'}, None),
        MemberSpec_('onMaster', 'onMasterType38', 0, 1, {'minOccurs': '0', 'type': 'onMasterType38', 'name': 'onMaster'}, None),
        MemberSpec_('onSlave', 'onSlaveType40', 0, 1, {'minOccurs': '0', 'type': 'onSlaveType40', 'name': 'onSlave'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, qualifier=None, onSystem=None, onMaster=None, onSlave=None):
        self.original_tagname_ = None
        self.qualifier = qualifier
        if onSystem is None:
            self.onSystem = []
        else:
            self.onSystem = onSystem
        self.onMaster = onMaster
        self.onSlave = onSlave
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transactionalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transactionalType.subclass:
            return transactionalType.subclass(*args_, **kwargs_)
        else:
            return transactionalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_onSystem(self): return self.onSystem
    def set_onSystem(self, onSystem): self.onSystem = onSystem
    def add_onSystem(self, value): self.onSystem.append(value)
    def insert_onSystem_at(self, index, value): self.onSystem.insert(index, value)
    def replace_onSystem_at(self, index, value): self.onSystem[index] = value
    def get_onMaster(self): return self.onMaster
    def set_onMaster(self, onMaster): self.onMaster = onMaster
    def get_onSlave(self): return self.onSlave
    def set_onSlave(self, onSlave): self.onSlave = onSlave
    def hasContent_(self):
        if (
            self.qualifier is not None or
            self.onSystem or
            self.onMaster is not None or
            self.onSlave is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='transactionalType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transactionalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='transactionalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='transactionalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='transactionalType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='transactionalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qualifier is not None:
            self.qualifier.export(outfile, level, namespace_, name_='qualifier', pretty_print=pretty_print)
        for onSystem_ in self.onSystem:
            onSystem_.export(outfile, level, namespace_, name_='onSystem', pretty_print=pretty_print)
        if self.onMaster is not None:
            self.onMaster.export(outfile, level, namespace_, name_='onMaster', pretty_print=pretty_print)
        if self.onSlave is not None:
            self.onSlave.export(outfile, level, namespace_, name_='onSlave', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qualifier':
            obj_ = qualifierType35.factory()
            obj_.build(child_)
            self.qualifier = obj_
            obj_.original_tagname_ = 'qualifier'
        elif nodeName_ == 'onSystem':
            obj_ = onSystemType36.factory()
            obj_.build(child_)
            self.onSystem.append(obj_)
            obj_.original_tagname_ = 'onSystem'
        elif nodeName_ == 'onMaster':
            obj_ = onMasterType38.factory()
            obj_.build(child_)
            self.onMaster = obj_
            obj_.original_tagname_ = 'onMaster'
        elif nodeName_ == 'onSlave':
            obj_ = onSlaveType40.factory()
            obj_.build(child_)
            self.onSlave = obj_
            obj_.original_tagname_ = 'onSlave'
# end class transactionalType


class qualifierType35(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('isAddress', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'name': 'isAddress'}, None),
        MemberSpec_('isData', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'name': 'isData'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, isAddress=None, isData=None):
        self.original_tagname_ = None
        self.isAddress = isAddress
        self.isData = isData
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, qualifierType35)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if qualifierType35.subclass:
            return qualifierType35.subclass(*args_, **kwargs_)
        else:
            return qualifierType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isAddress(self): return self.isAddress
    def set_isAddress(self, isAddress): self.isAddress = isAddress
    def get_isData(self): return self.isData
    def set_isData(self, isData): self.isData = isData
    def hasContent_(self):
        if (
            self.isAddress is not None or
            self.isData is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='qualifierType35', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('qualifierType35')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierType35')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='qualifierType35', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='qualifierType35'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='qualifierType35', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:isAddress>%s</ipxact:isAddress>%s' % (self.gds_format_boolean(self.isAddress, input_name='isAddress'), eol_))
        if self.isData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:isData>%s</ipxact:isData>%s' % (self.gds_format_boolean(self.isData, input_name='isData'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isAddress':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isAddress')
            self.isAddress = ival_
        elif nodeName_ == 'isData':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isData')
            self.isData = ival_
# end class qualifierType35


class onSystemType36(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('group', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'group'}, None),
        MemberSpec_('presence', ['presenceType', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'presence', 'name': 'presence'}, None),
        MemberSpec_('initiative', ['initiativeType37', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'default': 'requires', 'name': 'initiative'}, None),
        MemberSpec_('kind', 'kind', 0, 1, {'minOccurs': '0', 'type': 'kind', 'ref': 'kind', 'name': 'kind'}, None),
        MemberSpec_('busWidth', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedPositiveIntExpression', 'name': 'busWidth'}, None),
        MemberSpec_('protocol', 'protocol', 0, 1, {'minOccurs': '0', 'type': 'protocol', 'ref': 'protocol', 'name': 'protocol'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, group=None, presence=None, initiative='requires', kind=None, busWidth=None, protocol=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.group = group
        self.presence = presence
        self.validate_presenceType(self.presence)
        self.initiative = initiative
        self.validate_initiativeType37(self.initiative)
        self.kind = kind
        self.busWidth = busWidth
        self.protocol = protocol
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onSystemType36)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onSystemType36.subclass:
            return onSystemType36.subclass(*args_, **kwargs_)
        else:
            return onSystemType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_presence(self): return self.presence
    def set_presence(self, presence): self.presence = presence
    def get_initiative(self): return self.initiative
    def set_initiative(self, initiative): self.initiative = initiative
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_busWidth(self): return self.busWidth
    def set_busWidth(self, busWidth): self.busWidth = busWidth
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_presenceType(self, value):
        # Validate type presenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['required', 'illegal', 'optional']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on presenceType' % {"value" : value.encode("utf-8")} )
    def validate_initiativeType37(self, value):
        # Validate type initiativeType37, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['requires', 'provides', 'both']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on initiativeType37' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.group is not None or
            self.presence is not None or
            self.initiative != "requires" or
            self.kind is not None or
            self.busWidth is not None or
            self.protocol is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='onSystemType36', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onSystemType36')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='onSystemType36')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='onSystemType36', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='onSystemType36'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='onSystemType36', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.group is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:group>%s</ipxact:group>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.group), input_name='group')), eol_))
        if self.presence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:presence>%s</ipxact:presence>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.presence), input_name='presence')), eol_))
        if self.initiative != "requires":
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:initiative>%s</ipxact:initiative>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.initiative), input_name='initiative')), eol_))
        if self.kind is not None:
            self.kind.export(outfile, level, namespace_='ipxact:', name_='kind', pretty_print=pretty_print)
        if self.busWidth is not None:
            self.busWidth.export(outfile, level, namespace_, name_='busWidth', pretty_print=pretty_print)
        if self.protocol is not None:
            self.protocol.export(outfile, level, namespace_='ipxact:', name_='protocol', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            group_ = child_.text
            group_ = self.gds_validate_string(group_, node, 'group')
            self.group = group_
        elif nodeName_ == 'presence':
            presence_ = child_.text
            presence_ = self.gds_validate_string(presence_, node, 'presence')
            self.presence = presence_
            # validate type presenceType
            self.validate_presenceType(self.presence)
        elif nodeName_ == 'initiative':
            initiative_ = child_.text
            initiative_ = self.gds_validate_string(initiative_, node, 'initiative')
            self.initiative = initiative_
            # validate type initiativeType37
            self.validate_initiativeType37(self.initiative)
        elif nodeName_ == 'kind':
            obj_ = kind.factory()
            obj_.build(child_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'busWidth':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.busWidth = obj_
            obj_.original_tagname_ = 'busWidth'
        elif nodeName_ == 'protocol':
            obj_ = protocol.factory()
            obj_.build(child_)
            self.protocol = obj_
            obj_.original_tagname_ = 'protocol'
# end class onSystemType36


class onMasterType38(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('presence', ['presenceType', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'presence', 'name': 'presence'}, None),
        MemberSpec_('initiative', ['initiativeType39', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'default': 'requires', 'name': 'initiative'}, None),
        MemberSpec_('kind', 'kind', 0, 1, {'minOccurs': '0', 'type': 'kind', 'ref': 'kind', 'name': 'kind'}, None),
        MemberSpec_('busWidth', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedPositiveIntExpression', 'name': 'busWidth'}, None),
        MemberSpec_('protocol', 'protocol', 0, 1, {'minOccurs': '0', 'type': 'protocol', 'ref': 'protocol', 'name': 'protocol'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, presence=None, initiative='requires', kind=None, busWidth=None, protocol=None):
        self.original_tagname_ = None
        self.presence = presence
        self.validate_presenceType(self.presence)
        self.initiative = initiative
        self.validate_initiativeType39(self.initiative)
        self.kind = kind
        self.busWidth = busWidth
        self.protocol = protocol
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onMasterType38)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onMasterType38.subclass:
            return onMasterType38.subclass(*args_, **kwargs_)
        else:
            return onMasterType38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_presence(self): return self.presence
    def set_presence(self, presence): self.presence = presence
    def get_initiative(self): return self.initiative
    def set_initiative(self, initiative): self.initiative = initiative
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_busWidth(self): return self.busWidth
    def set_busWidth(self, busWidth): self.busWidth = busWidth
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def validate_presenceType(self, value):
        # Validate type presenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['required', 'illegal', 'optional']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on presenceType' % {"value" : value.encode("utf-8")} )
    def validate_initiativeType39(self, value):
        # Validate type initiativeType39, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['requires', 'provides', 'both']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on initiativeType39' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.presence is not None or
            self.initiative != "requires" or
            self.kind is not None or
            self.busWidth is not None or
            self.protocol is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='onMasterType38', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onMasterType38')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='onMasterType38')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='onMasterType38', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='onMasterType38'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='onMasterType38', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.presence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:presence>%s</ipxact:presence>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.presence), input_name='presence')), eol_))
        if self.initiative != "requires":
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:initiative>%s</ipxact:initiative>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.initiative), input_name='initiative')), eol_))
        if self.kind is not None:
            self.kind.export(outfile, level, namespace_='ipxact:', name_='kind', pretty_print=pretty_print)
        if self.busWidth is not None:
            self.busWidth.export(outfile, level, namespace_, name_='busWidth', pretty_print=pretty_print)
        if self.protocol is not None:
            self.protocol.export(outfile, level, namespace_='ipxact:', name_='protocol', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'presence':
            presence_ = child_.text
            presence_ = self.gds_validate_string(presence_, node, 'presence')
            self.presence = presence_
            # validate type presenceType
            self.validate_presenceType(self.presence)
        elif nodeName_ == 'initiative':
            initiative_ = child_.text
            initiative_ = self.gds_validate_string(initiative_, node, 'initiative')
            self.initiative = initiative_
            # validate type initiativeType39
            self.validate_initiativeType39(self.initiative)
        elif nodeName_ == 'kind':
            obj_ = kind.factory()
            obj_.build(child_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'busWidth':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.busWidth = obj_
            obj_.original_tagname_ = 'busWidth'
        elif nodeName_ == 'protocol':
            obj_ = protocol.factory()
            obj_.build(child_)
            self.protocol = obj_
            obj_.original_tagname_ = 'protocol'
# end class onMasterType38


class onSlaveType40(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('presence', ['presenceType', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'presence', 'name': 'presence'}, None),
        MemberSpec_('initiative', ['initiativeType41', 'xs:string'], 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'default': 'requires', 'name': 'initiative'}, None),
        MemberSpec_('kind', 'kind', 0, 1, {'minOccurs': '0', 'type': 'kind', 'ref': 'kind', 'name': 'kind'}, None),
        MemberSpec_('busWidth', 'unsignedIntExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedPositiveIntExpression', 'name': 'busWidth'}, None),
        MemberSpec_('protocol', 'protocol', 0, 1, {'minOccurs': '0', 'type': 'protocol', 'ref': 'protocol', 'name': 'protocol'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, presence=None, initiative='requires', kind=None, busWidth=None, protocol=None):
        self.original_tagname_ = None
        self.presence = presence
        self.validate_presenceType(self.presence)
        self.initiative = initiative
        self.validate_initiativeType41(self.initiative)
        self.kind = kind
        self.busWidth = busWidth
        self.protocol = protocol
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onSlaveType40)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onSlaveType40.subclass:
            return onSlaveType40.subclass(*args_, **kwargs_)
        else:
            return onSlaveType40(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_presence(self): return self.presence
    def set_presence(self, presence): self.presence = presence
    def get_initiative(self): return self.initiative
    def set_initiative(self, initiative): self.initiative = initiative
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_busWidth(self): return self.busWidth
    def set_busWidth(self, busWidth): self.busWidth = busWidth
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def validate_presenceType(self, value):
        # Validate type presenceType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['required', 'illegal', 'optional']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on presenceType' % {"value" : value.encode("utf-8")} )
    def validate_initiativeType41(self, value):
        # Validate type initiativeType41, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['requires', 'provides', 'both']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on initiativeType41' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.presence is not None or
            self.initiative != "requires" or
            self.kind is not None or
            self.busWidth is not None or
            self.protocol is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='onSlaveType40', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onSlaveType40')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='onSlaveType40')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='onSlaveType40', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='onSlaveType40'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='onSlaveType40', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.presence is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:presence>%s</ipxact:presence>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.presence), input_name='presence')), eol_))
        if self.initiative != "requires":
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:initiative>%s</ipxact:initiative>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.initiative), input_name='initiative')), eol_))
        if self.kind is not None:
            self.kind.export(outfile, level, namespace_='ipxact:', name_='kind', pretty_print=pretty_print)
        if self.busWidth is not None:
            self.busWidth.export(outfile, level, namespace_, name_='busWidth', pretty_print=pretty_print)
        if self.protocol is not None:
            self.protocol.export(outfile, level, namespace_='ipxact:', name_='protocol', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'presence':
            presence_ = child_.text
            presence_ = self.gds_validate_string(presence_, node, 'presence')
            self.presence = presence_
            # validate type presenceType
            self.validate_presenceType(self.presence)
        elif nodeName_ == 'initiative':
            initiative_ = child_.text
            initiative_ = self.gds_validate_string(initiative_, node, 'initiative')
            self.initiative = initiative_
            # validate type initiativeType41
            self.validate_initiativeType41(self.initiative)
        elif nodeName_ == 'kind':
            obj_ = kind.factory()
            obj_.build(child_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'busWidth':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.busWidth = obj_
            obj_.original_tagname_ = 'busWidth'
        elif nodeName_ == 'protocol':
            obj_ = protocol.factory()
            obj_.build(child_)
            self.protocol = obj_
            obj_.original_tagname_ = 'protocol'
# end class onSlaveType40


class accessHandlesType42(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'simpleAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'simpleAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType42)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType42.subclass:
            return accessHandlesType42.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType42(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType42', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType42')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType42')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType42', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType42'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType42', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = simpleAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType42


class accessHandlesType43(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'simpleAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'simpleAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType43)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType43.subclass:
            return accessHandlesType43.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType43(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType43', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType43')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType43')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType43', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType43'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType43', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = simpleAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType43


class accessHandlesType44(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'nonIndexedLeafAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'nonIndexedLeafAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType44)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType44.subclass:
            return accessHandlesType44.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType44(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType44', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType44')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType44')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType44', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType44'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType44', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = nonIndexedLeafAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType44


class accessHandlesType45(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'simpleAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'simpleAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType45)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType45.subclass:
            return accessHandlesType45.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType45(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType45', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType45')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType45')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType45', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType45'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType45', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = simpleAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType45


class accessHandlesType46(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'simpleAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'simpleAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType46)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType46.subclass:
            return accessHandlesType46.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType46(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType46', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType46')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType46')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType46', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType46'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType46', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = simpleAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType46


class accessHandlesType47(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'nonIndexedLeafAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'nonIndexedLeafAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType47)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType47.subclass:
            return accessHandlesType47.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType47(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType47', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType47')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType47')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType47', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType47'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType47', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = nonIndexedLeafAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType47


class accessHandlesType48(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'nonIndexedLeafAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'nonIndexedLeafAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType48)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType48.subclass:
            return accessHandlesType48.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType48(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType48', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType48')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType48')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType48', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType48'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType48', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = nonIndexedLeafAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType48


class resetsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('reset', 'reset', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'reset', 'name': 'reset', 'type': 'reset'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, reset=None):
        self.original_tagname_ = None
        if reset is None:
            self.reset = []
        else:
            self.reset = reset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, resetsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if resetsType.subclass:
            return resetsType.subclass(*args_, **kwargs_)
        else:
            return resetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reset(self): return self.reset
    def set_reset(self, reset): self.reset = reset
    def add_reset(self, value): self.reset.append(value)
    def insert_reset_at(self, index, value): self.reset.insert(index, value)
    def replace_reset_at(self, index, value): self.reset[index] = value
    def hasContent_(self):
        if (
            self.reset
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='resetsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('resetsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resetsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='resetsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='resetsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='resetsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for reset_ in self.reset:
            reset_.export(outfile, level, namespace_='ipxact:', name_='reset', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'reset':
            obj_ = reset.factory()
            obj_.build(child_)
            self.reset.append(obj_)
            obj_.original_tagname_ = 'reset'
# end class resetsType


class addressSpaceType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('addressRange', 'unsignedPositiveLongintExpression', 0, 0, {'type': 'addressRange', 'ref': 'addressRange', 'name': 'addressRange'}, None),
        MemberSpec_('width', 'unsignedIntExpression', 0, 0, {'type': 'unsignedIntExpression', 'name': 'width'}, None),
        MemberSpec_('segments', 'segmentsType', 0, 1, {'minOccurs': '0', 'type': 'segmentsType', 'name': 'segments'}, None),
        MemberSpec_('addressUnitBits', 'unsignedPositiveLongintExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedPositiveLongintExpression', 'ref': 'addressUnitBits', 'name': 'addressUnitBits'}, None),
        MemberSpec_('executableImage', 'executableImage', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'ref': 'executableImage', 'name': 'executableImage', 'type': 'executableImage'}, None),
        MemberSpec_('localMemoryMap', 'localMemoryMapType', 0, 1, {'minOccurs': '0', 'type': 'localMemoryMapType', 'name': 'localMemoryMap'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, addressRange=None, width=None, segments=None, addressUnitBits=None, executableImage=None, localMemoryMap=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        self.addressRange = addressRange
        self.width = width
        self.segments = segments
        self.addressUnitBits = addressUnitBits
        if executableImage is None:
            self.executableImage = []
        else:
            self.executableImage = executableImage
        self.localMemoryMap = localMemoryMap
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addressSpaceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addressSpaceType.subclass:
            return addressSpaceType.subclass(*args_, **kwargs_)
        else:
            return addressSpaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressRange(self): return self.addressRange
    def set_addressRange(self, addressRange): self.addressRange = addressRange
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_segments(self): return self.segments
    def set_segments(self, segments): self.segments = segments
    def get_addressUnitBits(self): return self.addressUnitBits
    def set_addressUnitBits(self, addressUnitBits): self.addressUnitBits = addressUnitBits
    def get_executableImage(self): return self.executableImage
    def set_executableImage(self, executableImage): self.executableImage = executableImage
    def add_executableImage(self, value): self.executableImage.append(value)
    def insert_executableImage_at(self, index, value): self.executableImage.insert(index, value)
    def replace_executableImage_at(self, index, value): self.executableImage[index] = value
    def get_localMemoryMap(self): return self.localMemoryMap
    def set_localMemoryMap(self, localMemoryMap): self.localMemoryMap = localMemoryMap
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.addressRange is not None or
            self.width is not None or
            self.segments is not None or
            self.addressUnitBits is not None or
            self.executableImage or
            self.localMemoryMap is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='addressSpaceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addressSpaceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='addressSpaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='addressSpaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='addressSpaceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='addressSpaceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.addressRange is not None:
            self.addressRange.export(outfile, level, namespace_, name_='addressRange', pretty_print=pretty_print)
        if self.width is not None:
            self.width.export(outfile, level, namespace_, name_='width', pretty_print=pretty_print)
        if self.segments is not None:
            self.segments.export(outfile, level, namespace_, name_='segments', pretty_print=pretty_print)
        if self.addressUnitBits is not None:
            self.addressUnitBits.export(outfile, level, namespace_='ipxact:', name_='addressUnitBits', pretty_print=pretty_print)
        for executableImage_ in self.executableImage:
            executableImage_.export(outfile, level, namespace_='ipxact:', name_='executableImage', pretty_print=pretty_print)
        if self.localMemoryMap is not None:
            self.localMemoryMap.export(outfile, level, namespace_, name_='localMemoryMap', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressRange':
            obj_ = unsignedPositiveLongintExpression.factory()
            obj_.build(child_)
            self.addressRange = obj_
            obj_.original_tagname_ = 'addressRange'
        elif nodeName_ == 'width':
            obj_ = unsignedIntExpression.factory()
            obj_.build(child_)
            self.width = obj_
            obj_.original_tagname_ = 'width'
        elif nodeName_ == 'segments':
            obj_ = segmentsType.factory()
            obj_.build(child_)
            self.segments = obj_
            obj_.original_tagname_ = 'segments'
        elif nodeName_ == 'addressUnitBits':
            obj_ = unsignedPositiveLongintExpression.factory()
            obj_.build(child_)
            self.addressUnitBits = obj_
            obj_.original_tagname_ = 'addressUnitBits'
        elif nodeName_ == 'executableImage':
            obj_ = executableImage.factory()
            obj_.build(child_)
            self.executableImage.append(obj_)
            obj_.original_tagname_ = 'executableImage'
        elif nodeName_ == 'localMemoryMap':
            obj_ = localMemoryMapType.factory()
            obj_.build(child_)
            self.localMemoryMap = obj_
            obj_.original_tagname_ = 'localMemoryMap'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class addressSpaceType


class segmentsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('segment', 'segmentType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'segment', 'type': 'segmentType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, segment=None):
        self.original_tagname_ = None
        if segment is None:
            self.segment = []
        else:
            self.segment = segment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, segmentsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if segmentsType.subclass:
            return segmentsType.subclass(*args_, **kwargs_)
        else:
            return segmentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_segment(self): return self.segment
    def set_segment(self, segment): self.segment = segment
    def add_segment(self, value): self.segment.append(value)
    def insert_segment_at(self, index, value): self.segment.insert(index, value)
    def replace_segment_at(self, index, value): self.segment[index] = value
    def hasContent_(self):
        if (
            self.segment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='segmentsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('segmentsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='segmentsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='segmentsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='segmentsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='segmentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for segment_ in self.segment:
            segment_.export(outfile, level, namespace_, name_='segment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'segment':
            obj_ = segmentType.factory()
            obj_.build(child_)
            self.segment.append(obj_)
            obj_.original_tagname_ = 'segment'
# end class segmentsType


class segmentType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'type': 'unsignedLongintExpression', 'name': 'addressOffset'}, None),
        MemberSpec_('addressRange', 'unsignedPositiveLongintExpression', 0, 0, {'type': 'addressRange', 'ref': 'addressRange', 'name': 'addressRange'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, isPresent=None, addressOffset=None, addressRange=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        self.addressOffset = addressOffset
        self.addressRange = addressRange
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, segmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if segmentType.subclass:
            return segmentType.subclass(*args_, **kwargs_)
        else:
            return segmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_addressOffset(self): return self.addressOffset
    def set_addressOffset(self, addressOffset): self.addressOffset = addressOffset
    def get_addressRange(self): return self.addressRange
    def set_addressRange(self, addressRange): self.addressRange = addressRange
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.addressOffset is not None or
            self.addressRange is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='segmentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('segmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='segmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='segmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='segmentType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='segmentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.addressOffset is not None:
            self.addressOffset.export(outfile, level, namespace_, name_='addressOffset', pretty_print=pretty_print)
        if self.addressRange is not None:
            self.addressRange.export(outfile, level, namespace_, name_='addressRange', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'addressRange':
            obj_ = unsignedPositiveLongintExpression.factory()
            obj_.build(child_)
            self.addressRange = obj_
            obj_.original_tagname_ = 'addressRange'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class segmentType


class registerType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType49', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType49', 'name': 'accessHandles'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('dim', 'dimType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'dim', 'type': 'dimType'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'type': 'unsignedLongintExpression', 'name': 'addressOffset'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'typeIdentifier'}, None),
        MemberSpec_('size', 'unsignedPositiveIntExpression', 0, 0, {'type': 'unsignedPositiveIntExpression', 'name': 'size'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('field', 'fieldType', 1, 0, {'minOccurs': '1', 'type': 'fieldType', 'name': 'field', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('alternateRegisters', 'alternateRegisters', 0, 1, {'minOccurs': '0', 'type': 'alternateRegisters', 'ref': 'alternateRegisters', 'name': 'alternateRegisters'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, dim=None, addressOffset=None, typeIdentifier=None, size=None, volatile=None, access=None, field=None, alternateRegisters=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.isPresent = isPresent
        if dim is None:
            self.dim = []
        else:
            self.dim = dim
        self.addressOffset = addressOffset
        self.typeIdentifier = typeIdentifier
        self.size = size
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        if field is None:
            self.field = []
        else:
            self.field = field
        self.alternateRegisters = alternateRegisters
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, registerType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if registerType.subclass:
            return registerType.subclass(*args_, **kwargs_)
        else:
            return registerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_dim(self): return self.dim
    def set_dim(self, dim): self.dim = dim
    def add_dim(self, value): self.dim.append(value)
    def insert_dim_at(self, index, value): self.dim.insert(index, value)
    def replace_dim_at(self, index, value): self.dim[index] = value
    def get_addressOffset(self): return self.addressOffset
    def set_addressOffset(self, addressOffset): self.addressOffset = addressOffset
    def get_typeIdentifier(self): return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier): self.typeIdentifier = typeIdentifier
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def add_field(self, value): self.field.append(value)
    def insert_field_at(self, index, value): self.field.insert(index, value)
    def replace_field_at(self, index, value): self.field[index] = value
    def get_alternateRegisters(self): return self.alternateRegisters
    def set_alternateRegisters(self, alternateRegisters): self.alternateRegisters = alternateRegisters
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.dim or
            self.addressOffset is not None or
            self.typeIdentifier is not None or
            self.size is not None or
            self.volatile is not None or
            self.access is not None or
            self.field or
            self.alternateRegisters is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='registerType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('registerType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='registerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='registerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='registerType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='registerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for dim_ in self.dim:
            dim_.export(outfile, level, namespace_, name_='dim', pretty_print=pretty_print)
        if self.addressOffset is not None:
            self.addressOffset.export(outfile, level, namespace_, name_='addressOffset', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:typeIdentifier>%s</ipxact:typeIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), eol_))
        if self.size is not None:
            self.size.export(outfile, level, namespace_, name_='size', pretty_print=pretty_print)
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        for field_ in self.field:
            field_.export(outfile, level, namespace_, name_='field', pretty_print=pretty_print)
        if self.alternateRegisters is not None:
            self.alternateRegisters.export(outfile, level, namespace_='ipxact:', name_='alternateRegisters', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType49.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'dim':
            obj_ = dimType.factory()
            obj_.build(child_)
            self.dim.append(obj_)
            obj_.original_tagname_ = 'dim'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'typeIdentifier':
            typeIdentifier_ = child_.text
            typeIdentifier_ = self.gds_validate_string(typeIdentifier_, node, 'typeIdentifier')
            self.typeIdentifier = typeIdentifier_
        elif nodeName_ == 'size':
            obj_ = unsignedPositiveIntExpression.factory()
            obj_.build(child_)
            self.size = obj_
            obj_.original_tagname_ = 'size'
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'field':
            obj_ = fieldType.factory()
            obj_.build(child_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        elif nodeName_ == 'alternateRegisters':
            obj_ = alternateRegisters.factory()
            obj_.build(child_)
            self.alternateRegisters = obj_
            obj_.original_tagname_ = 'alternateRegisters'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class registerType


class accessHandlesType49(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'indexedAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType49)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType49.subclass:
            return accessHandlesType49.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType49(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType49', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType49')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType49')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType49', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType49'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType49', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType49


class registerType50(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType51', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType51', 'name': 'accessHandles'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('dim', 'dimType52', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'dim', 'type': 'dimType52'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'type': 'unsignedLongintExpression', 'name': 'addressOffset'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'typeIdentifier'}, None),
        MemberSpec_('size', 'unsignedPositiveIntExpression', 0, 0, {'type': 'unsignedPositiveIntExpression', 'name': 'size'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('field', 'fieldType', 1, 0, {'minOccurs': '1', 'type': 'fieldType', 'name': 'field', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('alternateRegisters', 'alternateRegisters', 0, 1, {'minOccurs': '0', 'type': 'alternateRegisters', 'ref': 'alternateRegisters', 'name': 'alternateRegisters'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, dim=None, addressOffset=None, typeIdentifier=None, size=None, volatile=None, access=None, field=None, alternateRegisters=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.isPresent = isPresent
        if dim is None:
            self.dim = []
        else:
            self.dim = dim
        self.addressOffset = addressOffset
        self.typeIdentifier = typeIdentifier
        self.size = size
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        if field is None:
            self.field = []
        else:
            self.field = field
        self.alternateRegisters = alternateRegisters
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, registerType50)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if registerType50.subclass:
            return registerType50.subclass(*args_, **kwargs_)
        else:
            return registerType50(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_dim(self): return self.dim
    def set_dim(self, dim): self.dim = dim
    def add_dim(self, value): self.dim.append(value)
    def insert_dim_at(self, index, value): self.dim.insert(index, value)
    def replace_dim_at(self, index, value): self.dim[index] = value
    def get_addressOffset(self): return self.addressOffset
    def set_addressOffset(self, addressOffset): self.addressOffset = addressOffset
    def get_typeIdentifier(self): return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier): self.typeIdentifier = typeIdentifier
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def add_field(self, value): self.field.append(value)
    def insert_field_at(self, index, value): self.field.insert(index, value)
    def replace_field_at(self, index, value): self.field[index] = value
    def get_alternateRegisters(self): return self.alternateRegisters
    def set_alternateRegisters(self, alternateRegisters): self.alternateRegisters = alternateRegisters
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.dim or
            self.addressOffset is not None or
            self.typeIdentifier is not None or
            self.size is not None or
            self.volatile is not None or
            self.access is not None or
            self.field or
            self.alternateRegisters is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='registerType50', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('registerType50')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='registerType50')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='registerType50', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='registerType50'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='registerType50', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for dim_ in self.dim:
            dim_.export(outfile, level, namespace_, name_='dim', pretty_print=pretty_print)
        if self.addressOffset is not None:
            self.addressOffset.export(outfile, level, namespace_, name_='addressOffset', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:typeIdentifier>%s</ipxact:typeIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), eol_))
        if self.size is not None:
            self.size.export(outfile, level, namespace_, name_='size', pretty_print=pretty_print)
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        for field_ in self.field:
            field_.export(outfile, level, namespace_, name_='field', pretty_print=pretty_print)
        if self.alternateRegisters is not None:
            self.alternateRegisters.export(outfile, level, namespace_='ipxact:', name_='alternateRegisters', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType51.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'dim':
            obj_ = dimType52.factory()
            obj_.build(child_)
            self.dim.append(obj_)
            obj_.original_tagname_ = 'dim'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'typeIdentifier':
            typeIdentifier_ = child_.text
            typeIdentifier_ = self.gds_validate_string(typeIdentifier_, node, 'typeIdentifier')
            self.typeIdentifier = typeIdentifier_
        elif nodeName_ == 'size':
            obj_ = unsignedPositiveIntExpression.factory()
            obj_.build(child_)
            self.size = obj_
            obj_.original_tagname_ = 'size'
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'field':
            obj_ = fieldType.factory()
            obj_.build(child_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        elif nodeName_ == 'alternateRegisters':
            obj_ = alternateRegisters.factory()
            obj_.build(child_)
            self.alternateRegisters = obj_
            obj_.original_tagname_ = 'alternateRegisters'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class registerType50


class accessHandlesType51(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'indexedAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType51)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType51.subclass:
            return accessHandlesType51.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType51(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType51', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType51')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType51')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType51', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType51'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType51', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType51


class alternateRegisterType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType53', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType53', 'name': 'accessHandles'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('alternateGroups', 'alternateGroupsType', 0, 0, {'type': 'alternateGroupsType', 'name': 'alternateGroups'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'typeIdentifier'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('field', 'fieldType', 1, 0, {'minOccurs': '1', 'type': 'fieldType', 'name': 'field', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, alternateGroups=None, typeIdentifier=None, volatile=None, access=None, field=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.isPresent = isPresent
        self.alternateGroups = alternateGroups
        self.typeIdentifier = typeIdentifier
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        if field is None:
            self.field = []
        else:
            self.field = field
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateRegisterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateRegisterType.subclass:
            return alternateRegisterType.subclass(*args_, **kwargs_)
        else:
            return alternateRegisterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_alternateGroups(self): return self.alternateGroups
    def set_alternateGroups(self, alternateGroups): self.alternateGroups = alternateGroups
    def get_typeIdentifier(self): return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier): self.typeIdentifier = typeIdentifier
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def add_field(self, value): self.field.append(value)
    def insert_field_at(self, index, value): self.field.insert(index, value)
    def replace_field_at(self, index, value): self.field[index] = value
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.alternateGroups is not None or
            self.typeIdentifier is not None or
            self.volatile is not None or
            self.access is not None or
            self.field or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='alternateRegisterType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateRegisterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alternateRegisterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='alternateRegisterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='alternateRegisterType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='alternateRegisterType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.alternateGroups is not None:
            self.alternateGroups.export(outfile, level, namespace_, name_='alternateGroups', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:typeIdentifier>%s</ipxact:typeIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), eol_))
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        for field_ in self.field:
            field_.export(outfile, level, namespace_, name_='field', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType53.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'alternateGroups':
            obj_ = alternateGroupsType.factory()
            obj_.build(child_)
            self.alternateGroups = obj_
            obj_.original_tagname_ = 'alternateGroups'
        elif nodeName_ == 'typeIdentifier':
            typeIdentifier_ = child_.text
            typeIdentifier_ = self.gds_validate_string(typeIdentifier_, node, 'typeIdentifier')
            self.typeIdentifier = typeIdentifier_
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'field':
            obj_ = fieldType.factory()
            obj_.build(child_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class alternateRegisterType


class accessHandlesType53(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'indexedAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType53)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType53.subclass:
            return accessHandlesType53.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType53(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType53', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType53')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType53')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType53', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType53'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType53', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType53


class alternateGroupsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('alternateGroup', 'alternateGroupType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'alternateGroup', 'type': 'alternateGroupType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, alternateGroup=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if alternateGroup is None:
            self.alternateGroup = []
        else:
            self.alternateGroup = alternateGroup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateGroupsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateGroupsType.subclass:
            return alternateGroupsType.subclass(*args_, **kwargs_)
        else:
            return alternateGroupsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_alternateGroup(self): return self.alternateGroup
    def set_alternateGroup(self, alternateGroup): self.alternateGroup = alternateGroup
    def add_alternateGroup(self, value): self.alternateGroup.append(value)
    def insert_alternateGroup_at(self, index, value): self.alternateGroup.insert(index, value)
    def replace_alternateGroup_at(self, index, value): self.alternateGroup[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.alternateGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='alternateGroupsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateGroupsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alternateGroupsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='alternateGroupsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='alternateGroupsType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='alternateGroupsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alternateGroup_ in self.alternateGroup:
            alternateGroup_.export(outfile, level, namespace_, name_='alternateGroup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'alternateGroup':
            obj_ = alternateGroupType.factory()
            obj_.build(child_)
            self.alternateGroup.append(obj_)
            obj_.original_tagname_ = 'alternateGroup'
# end class alternateGroupsType


class alternateGroupType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:Name', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, alternateGroupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if alternateGroupType.subclass:
            return alternateGroupType.subclass(*args_, **kwargs_)
        else:
            return alternateGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='alternateGroupType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('alternateGroupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alternateGroupType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='alternateGroupType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='alternateGroupType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='alternateGroupType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class alternateGroupType


class enumeratedValueType(GeneratedsSuper):
    """Usage for the enumeration. 'read' for a software read access.
    'write' for a software write access. 'read-write' for a software
    read or write access."""
    member_data_items_ = [
        MemberSpec_('usage', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('value', 'stringExpression', 0, 0, {'type': 'unsignedBitVectorExpression', 'name': 'value'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, usage='read-write', id=None, name=None, displayName=None, description=None, value=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.usage = _cast(None, usage)
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.value = value
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, enumeratedValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if enumeratedValueType.subclass:
            return enumeratedValueType.subclass(*args_, **kwargs_)
        else:
            return enumeratedValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_usage(self): return self.usage
    def set_usage(self, usage): self.usage = usage
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.value is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='enumeratedValueType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('enumeratedValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='enumeratedValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='enumeratedValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='enumeratedValueType'):
        if self.usage != "read-write" and 'usage' not in already_processed:
            already_processed.add('usage')
            outfile.write(' usage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usage), input_name='usage')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='enumeratedValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('usage', node)
        if value is not None and 'usage' not in already_processed:
            already_processed.add('usage')
            self.usage = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, stringExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class enumeratedValueType


class modifiedWriteValueType54(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('modify', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['modifiedWriteValueType', 'xs:Name'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, modify=None, valueOf_=None):
        self.original_tagname_ = None
        self.modify = _cast(None, modify)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, modifiedWriteValueType54)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if modifiedWriteValueType54.subclass:
            return modifiedWriteValueType54.subclass(*args_, **kwargs_)
        else:
            return modifiedWriteValueType54(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_modify(self): return self.modify
    def set_modify(self, modify): self.modify = modify
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='modifiedWriteValueType54', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('modifiedWriteValueType54')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='modifiedWriteValueType54')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='modifiedWriteValueType54', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='modifiedWriteValueType54'):
        if self.modify is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            outfile.write(' modify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modify), input_name='modify')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='modifiedWriteValueType54', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modify', node)
        if value is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            self.modify = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class modifiedWriteValueType54


class readActionType55(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('modify', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['readActionType', 'xs:Name'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, modify=None, valueOf_=None):
        self.original_tagname_ = None
        self.modify = _cast(None, modify)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, readActionType55)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if readActionType55.subclass:
            return readActionType55.subclass(*args_, **kwargs_)
        else:
            return readActionType55(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_modify(self): return self.modify
    def set_modify(self, modify): self.modify = modify
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='readActionType55', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('readActionType55')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='readActionType55')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='readActionType55', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='readActionType55'):
        if self.modify is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            outfile.write(' modify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modify), input_name='modify')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='readActionType55', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modify', node)
        if value is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            self.modify = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class readActionType55


class testableType(GeneratedsSuper):
    """Constraint for an automated register test routine. 'unconstrained'
    (default) means may read and write all legal values. 'restore'
    means may read and write legal values but the value must be
    restored to the initially read value before accessing another
    register. 'writeAsRead' has limitations on testability where
    only the value read before a write may be written to the field.
    'readOnly' has limitations on testability where values may only
    be read from the field."""
    member_data_items_ = [
        MemberSpec_('testConstraint', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:boolean', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, testConstraint='unconstrained', valueOf_=None):
        self.original_tagname_ = None
        self.testConstraint = _cast(None, testConstraint)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, testableType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if testableType.subclass:
            return testableType.subclass(*args_, **kwargs_)
        else:
            return testableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_testConstraint(self): return self.testConstraint
    def set_testConstraint(self, testConstraint): self.testConstraint = testConstraint
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='testableType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('testableType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='testableType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='testableType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='testableType'):
        if self.testConstraint != "unconstrained" and 'testConstraint' not in already_processed:
            already_processed.add('testConstraint')
            outfile.write(' testConstraint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.testConstraint), input_name='testConstraint')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='testableType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('testConstraint', node)
        if value is not None and 'testConstraint' not in already_processed:
            already_processed.add('testConstraint')
            self.testConstraint = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class testableType


class accessHandlesType56(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'indexedAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType56)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType56.subclass:
            return accessHandlesType56.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType56(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType56', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType56')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType56')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType56', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType56'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType56', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType56


class modifiedWriteValueType58(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('modify', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['modifiedWriteValueType', 'xs:Name'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, modify=None, valueOf_=None):
        self.original_tagname_ = None
        self.modify = _cast(None, modify)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, modifiedWriteValueType58)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if modifiedWriteValueType58.subclass:
            return modifiedWriteValueType58.subclass(*args_, **kwargs_)
        else:
            return modifiedWriteValueType58(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_modify(self): return self.modify
    def set_modify(self, modify): self.modify = modify
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='modifiedWriteValueType58', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('modifiedWriteValueType58')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='modifiedWriteValueType58')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='modifiedWriteValueType58', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='modifiedWriteValueType58'):
        if self.modify is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            outfile.write(' modify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modify), input_name='modify')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='modifiedWriteValueType58', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modify', node)
        if value is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            self.modify = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class modifiedWriteValueType58


class readActionType59(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('modify', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['readActionType', 'xs:Name'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, modify=None, valueOf_=None):
        self.original_tagname_ = None
        self.modify = _cast(None, modify)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, readActionType59)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if readActionType59.subclass:
            return readActionType59.subclass(*args_, **kwargs_)
        else:
            return readActionType59(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_modify(self): return self.modify
    def set_modify(self, modify): self.modify = modify
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='readActionType59', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('readActionType59')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='readActionType59')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='readActionType59', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='readActionType59'):
        if self.modify is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            outfile.write(' modify=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.modify), input_name='modify')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='readActionType59', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modify', node)
        if value is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            self.modify = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class readActionType59


class testableType60(GeneratedsSuper):
    """Constraint for an automated register test routine. 'unconstrained'
    (default) means may read and write all legal values. 'restore'
    means may read and write legal values but the value must be
    restored to the initially read value before accessing another
    register. 'writeAsRead' has limitations on testability where
    only the value read before a write may be written to the field.
    'readOnly' has limitations on testability where values may only
    be read from the field."""
    member_data_items_ = [
        MemberSpec_('testConstraint', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'xs:boolean', 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, testConstraint='unconstrained', valueOf_=None):
        self.original_tagname_ = None
        self.testConstraint = _cast(None, testConstraint)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, testableType60)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if testableType60.subclass:
            return testableType60.subclass(*args_, **kwargs_)
        else:
            return testableType60(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_testConstraint(self): return self.testConstraint
    def set_testConstraint(self, testConstraint): self.testConstraint = testConstraint
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='testableType60', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('testableType60')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='testableType60')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='testableType60', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='testableType60'):
        if self.testConstraint != "unconstrained" and 'testConstraint' not in already_processed:
            already_processed.add('testConstraint')
            outfile.write(' testConstraint=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.testConstraint), input_name='testConstraint')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='testableType60', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('testConstraint', node)
        if value is not None and 'testConstraint' not in already_processed:
            already_processed.add('testConstraint')
            self.testConstraint = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class testableType60


class registerType61(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType62', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType62', 'name': 'accessHandles'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('dim', 'dimType63', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'dim', 'type': 'dimType63'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'type': 'unsignedLongintExpression', 'name': 'addressOffset'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'typeIdentifier'}, None),
        MemberSpec_('size', 'unsignedPositiveIntExpression', 0, 0, {'type': 'unsignedPositiveIntExpression', 'name': 'size'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('field', 'fieldType', 1, 0, {'minOccurs': '1', 'type': 'fieldType', 'name': 'field', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('alternateRegisters', 'alternateRegisters', 0, 1, {'minOccurs': '0', 'type': 'alternateRegisters', 'ref': 'alternateRegisters', 'name': 'alternateRegisters'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, dim=None, addressOffset=None, typeIdentifier=None, size=None, volatile=None, access=None, field=None, alternateRegisters=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.isPresent = isPresent
        if dim is None:
            self.dim = []
        else:
            self.dim = dim
        self.addressOffset = addressOffset
        self.typeIdentifier = typeIdentifier
        self.size = size
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        if field is None:
            self.field = []
        else:
            self.field = field
        self.alternateRegisters = alternateRegisters
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, registerType61)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if registerType61.subclass:
            return registerType61.subclass(*args_, **kwargs_)
        else:
            return registerType61(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_dim(self): return self.dim
    def set_dim(self, dim): self.dim = dim
    def add_dim(self, value): self.dim.append(value)
    def insert_dim_at(self, index, value): self.dim.insert(index, value)
    def replace_dim_at(self, index, value): self.dim[index] = value
    def get_addressOffset(self): return self.addressOffset
    def set_addressOffset(self, addressOffset): self.addressOffset = addressOffset
    def get_typeIdentifier(self): return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier): self.typeIdentifier = typeIdentifier
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def add_field(self, value): self.field.append(value)
    def insert_field_at(self, index, value): self.field.insert(index, value)
    def replace_field_at(self, index, value): self.field[index] = value
    def get_alternateRegisters(self): return self.alternateRegisters
    def set_alternateRegisters(self, alternateRegisters): self.alternateRegisters = alternateRegisters
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.dim or
            self.addressOffset is not None or
            self.typeIdentifier is not None or
            self.size is not None or
            self.volatile is not None or
            self.access is not None or
            self.field or
            self.alternateRegisters is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='registerType61', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('registerType61')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='registerType61')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='registerType61', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='registerType61'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='registerType61', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for dim_ in self.dim:
            dim_.export(outfile, level, namespace_, name_='dim', pretty_print=pretty_print)
        if self.addressOffset is not None:
            self.addressOffset.export(outfile, level, namespace_, name_='addressOffset', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:typeIdentifier>%s</ipxact:typeIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), eol_))
        if self.size is not None:
            self.size.export(outfile, level, namespace_, name_='size', pretty_print=pretty_print)
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        for field_ in self.field:
            field_.export(outfile, level, namespace_, name_='field', pretty_print=pretty_print)
        if self.alternateRegisters is not None:
            self.alternateRegisters.export(outfile, level, namespace_='ipxact:', name_='alternateRegisters', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType62.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'dim':
            obj_ = dimType63.factory()
            obj_.build(child_)
            self.dim.append(obj_)
            obj_.original_tagname_ = 'dim'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'typeIdentifier':
            typeIdentifier_ = child_.text
            typeIdentifier_ = self.gds_validate_string(typeIdentifier_, node, 'typeIdentifier')
            self.typeIdentifier = typeIdentifier_
        elif nodeName_ == 'size':
            obj_ = unsignedPositiveIntExpression.factory()
            obj_.build(child_)
            self.size = obj_
            obj_.original_tagname_ = 'size'
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'field':
            obj_ = fieldType.factory()
            obj_.build(child_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        elif nodeName_ == 'alternateRegisters':
            obj_ = alternateRegisters.factory()
            obj_.build(child_)
            self.alternateRegisters = obj_
            obj_.original_tagname_ = 'alternateRegisters'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class registerType61


class accessHandlesType62(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'indexedAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType62)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType62.subclass:
            return accessHandlesType62.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType62(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType62', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType62')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType62')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType62', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType62'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType62', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType62


class registerType64(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('name', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('accessHandles', 'accessHandlesType65', 0, 1, {'minOccurs': '0', 'type': 'accessHandlesType65', 'name': 'accessHandles'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('dim', 'dimType66', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'dim', 'type': 'dimType66'}, None),
        MemberSpec_('addressOffset', 'unsignedLongintExpression', 0, 0, {'type': 'unsignedLongintExpression', 'name': 'addressOffset'}, None),
        MemberSpec_('typeIdentifier', 'xs:Name', 0, 1, {'minOccurs': '0', 'type': 'xs:Name', 'name': 'typeIdentifier'}, None),
        MemberSpec_('size', 'unsignedPositiveIntExpression', 0, 0, {'type': 'unsignedPositiveIntExpression', 'name': 'size'}, None),
        MemberSpec_('volatile', 'xs:boolean', 0, 1, {'minOccurs': '0', 'type': 'xs:boolean', 'ref': 'volatile', 'name': 'volatile'}, None),
        MemberSpec_('access', ['accessType', 'xs:token'], 0, 1, {'minOccurs': '0', 'type': 'xs:token', 'ref': 'access', 'name': 'access'}, None),
        MemberSpec_('field', 'fieldType', 1, 0, {'minOccurs': '1', 'type': 'fieldType', 'name': 'field', 'maxOccurs': 'unbounded'}, None),
        MemberSpec_('alternateRegisters', 'alternateRegisters', 0, 1, {'minOccurs': '0', 'type': 'alternateRegisters', 'ref': 'alternateRegisters', 'name': 'alternateRegisters'}, None),
        MemberSpec_('parameters', 'parameters', 0, 1, {'minOccurs': '0', 'type': 'parameters', 'ref': 'parameters', 'name': 'parameters'}, None),
        MemberSpec_('vendorExtensions', 'vendorExtensions', 0, 1, {'minOccurs': '0', 'type': 'vendorExtensions', 'ref': 'vendorExtensions', 'name': 'vendorExtensions'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, displayName=None, description=None, accessHandles=None, isPresent=None, dim=None, addressOffset=None, typeIdentifier=None, size=None, volatile=None, access=None, field=None, alternateRegisters=None, parameters=None, vendorExtensions=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.name = name
        self.displayName = displayName
        self.description = description
        self.accessHandles = accessHandles
        self.isPresent = isPresent
        if dim is None:
            self.dim = []
        else:
            self.dim = dim
        self.addressOffset = addressOffset
        self.typeIdentifier = typeIdentifier
        self.size = size
        self.volatile = volatile
        self.access = access
        self.validate_accessType(self.access)
        if field is None:
            self.field = []
        else:
            self.field = field
        self.alternateRegisters = alternateRegisters
        self.parameters = parameters
        self.vendorExtensions = vendorExtensions
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, registerType64)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if registerType64.subclass:
            return registerType64.subclass(*args_, **kwargs_)
        else:
            return registerType64(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_accessHandles(self): return self.accessHandles
    def set_accessHandles(self, accessHandles): self.accessHandles = accessHandles
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_dim(self): return self.dim
    def set_dim(self, dim): self.dim = dim
    def add_dim(self, value): self.dim.append(value)
    def insert_dim_at(self, index, value): self.dim.insert(index, value)
    def replace_dim_at(self, index, value): self.dim[index] = value
    def get_addressOffset(self): return self.addressOffset
    def set_addressOffset(self, addressOffset): self.addressOffset = addressOffset
    def get_typeIdentifier(self): return self.typeIdentifier
    def set_typeIdentifier(self, typeIdentifier): self.typeIdentifier = typeIdentifier
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_volatile(self): return self.volatile
    def set_volatile(self, volatile): self.volatile = volatile
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def add_field(self, value): self.field.append(value)
    def insert_field_at(self, index, value): self.field.insert(index, value)
    def replace_field_at(self, index, value): self.field[index] = value
    def get_alternateRegisters(self): return self.alternateRegisters
    def set_alternateRegisters(self, alternateRegisters): self.alternateRegisters = alternateRegisters
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_vendorExtensions(self): return self.vendorExtensions
    def set_vendorExtensions(self, vendorExtensions): self.vendorExtensions = vendorExtensions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_accessType(self, value):
        # Validate type accessType, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['read-only', 'write-only', 'read-write', 'writeOnce', 'read-writeOnce']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on accessType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.accessHandles is not None or
            self.isPresent is not None or
            self.dim or
            self.addressOffset is not None or
            self.typeIdentifier is not None or
            self.size is not None or
            self.volatile is not None or
            self.access is not None or
            self.field or
            self.alternateRegisters is not None or
            self.parameters is not None or
            self.vendorExtensions is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='registerType64', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('registerType64')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='registerType64')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='registerType64', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='registerType64'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='registerType64', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.accessHandles is not None:
            self.accessHandles.export(outfile, level, namespace_, name_='accessHandles', pretty_print=pretty_print)
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for dim_ in self.dim:
            dim_.export(outfile, level, namespace_, name_='dim', pretty_print=pretty_print)
        if self.addressOffset is not None:
            self.addressOffset.export(outfile, level, namespace_, name_='addressOffset', pretty_print=pretty_print)
        if self.typeIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:typeIdentifier>%s</ipxact:typeIdentifier>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.typeIdentifier), input_name='typeIdentifier')), eol_))
        if self.size is not None:
            self.size.export(outfile, level, namespace_, name_='size', pretty_print=pretty_print)
        if self.volatile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:volatile>%s</ipxact:volatile>%s' % (self.gds_format_boolean(self.volatile, input_name='volatile'), eol_))
        if self.access is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:access>%s</ipxact:access>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.access), input_name='access')), eol_))
        for field_ in self.field:
            field_.export(outfile, level, namespace_, name_='field', pretty_print=pretty_print)
        if self.alternateRegisters is not None:
            self.alternateRegisters.export(outfile, level, namespace_='ipxact:', name_='alternateRegisters', pretty_print=pretty_print)
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_='ipxact:', name_='parameters', pretty_print=pretty_print)
        if self.vendorExtensions is not None:
            self.vendorExtensions.export(outfile, level, namespace_='ipxact:', name_='vendorExtensions', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'accessHandles':
            obj_ = accessHandlesType65.factory()
            obj_.build(child_)
            self.accessHandles = obj_
            obj_.original_tagname_ = 'accessHandles'
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'dim':
            obj_ = dimType66.factory()
            obj_.build(child_)
            self.dim.append(obj_)
            obj_.original_tagname_ = 'dim'
        elif nodeName_ == 'addressOffset':
            class_obj_ = self.get_class_obj_(child_, unsignedLongintExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.addressOffset = obj_
            obj_.original_tagname_ = 'addressOffset'
        elif nodeName_ == 'typeIdentifier':
            typeIdentifier_ = child_.text
            typeIdentifier_ = self.gds_validate_string(typeIdentifier_, node, 'typeIdentifier')
            self.typeIdentifier = typeIdentifier_
        elif nodeName_ == 'size':
            obj_ = unsignedPositiveIntExpression.factory()
            obj_.build(child_)
            self.size = obj_
            obj_.original_tagname_ = 'size'
        elif nodeName_ == 'volatile':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'volatile')
            self.volatile = ival_
        elif nodeName_ == 'access':
            access_ = child_.text
            if access_:
                access_ = re_.sub(String_cleanup_pat_, " ", access_).strip()
            else:
                access_ = ""
            access_ = self.gds_validate_string(access_, node, 'access')
            self.access = access_
            # validate type accessType
            self.validate_accessType(self.access)
        elif nodeName_ == 'field':
            obj_ = fieldType.factory()
            obj_.build(child_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
        elif nodeName_ == 'alternateRegisters':
            obj_ = alternateRegisters.factory()
            obj_.build(child_)
            self.alternateRegisters = obj_
            obj_.original_tagname_ = 'alternateRegisters'
        elif nodeName_ == 'parameters':
            obj_ = parameters.factory()
            obj_.build(child_)
            self.parameters = obj_
            obj_.original_tagname_ = 'parameters'
        elif nodeName_ == 'vendorExtensions':
            obj_ = vendorExtensions.factory()
            obj_.build(child_)
            self.vendorExtensions = obj_
            obj_.original_tagname_ = 'vendorExtensions'
# end class registerType64


class accessHandlesType65(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('accessHandle', 'indexedAccessHandle', 1, 0, {'minOccurs': '1', 'type': 'indexedAccessHandle', 'name': 'accessHandle', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, accessHandle=None):
        self.original_tagname_ = None
        if accessHandle is None:
            self.accessHandle = []
        else:
            self.accessHandle = accessHandle
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, accessHandlesType65)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if accessHandlesType65.subclass:
            return accessHandlesType65.subclass(*args_, **kwargs_)
        else:
            return accessHandlesType65(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessHandle(self): return self.accessHandle
    def set_accessHandle(self, accessHandle): self.accessHandle = accessHandle
    def add_accessHandle(self, value): self.accessHandle.append(value)
    def insert_accessHandle_at(self, index, value): self.accessHandle.insert(index, value)
    def replace_accessHandle_at(self, index, value): self.accessHandle[index] = value
    def hasContent_(self):
        if (
            self.accessHandle
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType65', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('accessHandlesType65')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessHandlesType65')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='accessHandlesType65', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='accessHandlesType65'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='accessHandlesType65', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for accessHandle_ in self.accessHandle:
            accessHandle_.export(outfile, level, namespace_, name_='accessHandle', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessHandle':
            obj_ = indexedAccessHandle.factory()
            obj_.build(child_)
            self.accessHandle.append(obj_)
            obj_.original_tagname_ = 'accessHandle'
# end class accessHandlesType65


class moduleParametersType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('moduleParameter', 'moduleParameterType', 1, 0, {'type': 'moduleParameterType', 'name': 'moduleParameter', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, moduleParameter=None):
        self.original_tagname_ = None
        if moduleParameter is None:
            self.moduleParameter = []
        else:
            self.moduleParameter = moduleParameter
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, moduleParametersType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if moduleParametersType.subclass:
            return moduleParametersType.subclass(*args_, **kwargs_)
        else:
            return moduleParametersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_moduleParameter(self): return self.moduleParameter
    def set_moduleParameter(self, moduleParameter): self.moduleParameter = moduleParameter
    def add_moduleParameter(self, value): self.moduleParameter.append(value)
    def insert_moduleParameter_at(self, index, value): self.moduleParameter.insert(index, value)
    def replace_moduleParameter_at(self, index, value): self.moduleParameter[index] = value
    def hasContent_(self):
        if (
            self.moduleParameter
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='moduleParametersType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('moduleParametersType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='moduleParametersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='moduleParametersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='moduleParametersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='moduleParametersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for moduleParameter_ in self.moduleParameter:
            moduleParameter_.export(outfile, level, namespace_, name_='moduleParameter', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'moduleParameter':
            obj_ = moduleParameterType.factory()
            obj_.build(child_)
            self.moduleParameter.append(obj_)
            obj_.original_tagname_ = 'moduleParameter'
# end class moduleParametersType


class whiteboxElementRefsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('whiteboxElementRef', 'whiteboxElementRefType', 1, 1, {'minOccurs': '0', 'type': 'whiteboxElementRefType', 'name': 'whiteboxElementRef', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, whiteboxElementRef=None):
        self.original_tagname_ = None
        if whiteboxElementRef is None:
            self.whiteboxElementRef = []
        else:
            self.whiteboxElementRef = whiteboxElementRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, whiteboxElementRefsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if whiteboxElementRefsType.subclass:
            return whiteboxElementRefsType.subclass(*args_, **kwargs_)
        else:
            return whiteboxElementRefsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_whiteboxElementRef(self): return self.whiteboxElementRef
    def set_whiteboxElementRef(self, whiteboxElementRef): self.whiteboxElementRef = whiteboxElementRef
    def add_whiteboxElementRef(self, value): self.whiteboxElementRef.append(value)
    def insert_whiteboxElementRef_at(self, index, value): self.whiteboxElementRef.insert(index, value)
    def replace_whiteboxElementRef_at(self, index, value): self.whiteboxElementRef[index] = value
    def hasContent_(self):
        if (
            self.whiteboxElementRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='whiteboxElementRefsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('whiteboxElementRefsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='whiteboxElementRefsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='whiteboxElementRefsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='whiteboxElementRefsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='whiteboxElementRefsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for whiteboxElementRef_ in self.whiteboxElementRef:
            whiteboxElementRef_.export(outfile, level, namespace_, name_='whiteboxElementRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'whiteboxElementRef':
            obj_ = whiteboxElementRefType.factory()
            obj_.build(child_)
            self.whiteboxElementRef.append(obj_)
            obj_.original_tagname_ = 'whiteboxElementRef'
# end class whiteboxElementRefsType


class viewsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('view', 'viewType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'view', 'type': 'viewType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, view=None):
        self.original_tagname_ = None
        if view is None:
            self.view = []
        else:
            self.view = view
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewsType.subclass:
            return viewsType.subclass(*args_, **kwargs_)
        else:
            return viewsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_view(self): return self.view
    def set_view(self, view): self.view = view
    def add_view(self, value): self.view.append(value)
    def insert_view_at(self, index, value): self.view.insert(index, value)
    def replace_view_at(self, index, value): self.view[index] = value
    def hasContent_(self):
        if (
            self.view
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for view_ in self.view:
            view_.export(outfile, level, namespace_, name_='view', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'view':
            obj_ = viewType.factory()
            obj_.build(child_)
            self.view.append(obj_)
            obj_.original_tagname_ = 'view'
# end class viewsType


class viewType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('envIdentifier', 'envIdentifierType67', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'envIdentifier', 'type': 'envIdentifierType67'}, None),
        MemberSpec_('componentInstantiationRef', 'xs:NMTOKEN', 0, 1, {'minOccurs': '0', 'type': 'xs:NMTOKEN', 'name': 'componentInstantiationRef'}, None),
        MemberSpec_('designInstantiationRef', 'xs:NMTOKEN', 0, 1, {'minOccurs': '0', 'type': 'xs:NMTOKEN', 'name': 'designInstantiationRef'}, None),
        MemberSpec_('designConfigurationInstantiationRef', 'xs:NMTOKEN', 0, 1, {'minOccurs': '0', 'type': 'xs:NMTOKEN', 'name': 'designConfigurationInstantiationRef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, isPresent=None, envIdentifier=None, componentInstantiationRef=None, designInstantiationRef=None, designConfigurationInstantiationRef=None):
        self.original_tagname_ = None
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        if envIdentifier is None:
            self.envIdentifier = []
        else:
            self.envIdentifier = envIdentifier
        self.componentInstantiationRef = componentInstantiationRef
        self.designInstantiationRef = designInstantiationRef
        self.designConfigurationInstantiationRef = designConfigurationInstantiationRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewType.subclass:
            return viewType.subclass(*args_, **kwargs_)
        else:
            return viewType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_envIdentifier(self): return self.envIdentifier
    def set_envIdentifier(self, envIdentifier): self.envIdentifier = envIdentifier
    def add_envIdentifier(self, value): self.envIdentifier.append(value)
    def insert_envIdentifier_at(self, index, value): self.envIdentifier.insert(index, value)
    def replace_envIdentifier_at(self, index, value): self.envIdentifier[index] = value
    def get_componentInstantiationRef(self): return self.componentInstantiationRef
    def set_componentInstantiationRef(self, componentInstantiationRef): self.componentInstantiationRef = componentInstantiationRef
    def get_designInstantiationRef(self): return self.designInstantiationRef
    def set_designInstantiationRef(self, designInstantiationRef): self.designInstantiationRef = designInstantiationRef
    def get_designConfigurationInstantiationRef(self): return self.designConfigurationInstantiationRef
    def set_designConfigurationInstantiationRef(self, designConfigurationInstantiationRef): self.designConfigurationInstantiationRef = designConfigurationInstantiationRef
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.envIdentifier or
            self.componentInstantiationRef is not None or
            self.designInstantiationRef is not None or
            self.designConfigurationInstantiationRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for envIdentifier_ in self.envIdentifier:
            envIdentifier_.export(outfile, level, namespace_, name_='envIdentifier', pretty_print=pretty_print)
        if self.componentInstantiationRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:componentInstantiationRef>%s</ipxact:componentInstantiationRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.componentInstantiationRef), input_name='componentInstantiationRef')), eol_))
        if self.designInstantiationRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:designInstantiationRef>%s</ipxact:designInstantiationRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.designInstantiationRef), input_name='designInstantiationRef')), eol_))
        if self.designConfigurationInstantiationRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:designConfigurationInstantiationRef>%s</ipxact:designConfigurationInstantiationRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.designConfigurationInstantiationRef), input_name='designConfigurationInstantiationRef')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'envIdentifier':
            obj_ = envIdentifierType67.factory()
            obj_.build(child_)
            self.envIdentifier.append(obj_)
            obj_.original_tagname_ = 'envIdentifier'
        elif nodeName_ == 'componentInstantiationRef':
            componentInstantiationRef_ = child_.text
            componentInstantiationRef_ = self.gds_validate_string(componentInstantiationRef_, node, 'componentInstantiationRef')
            self.componentInstantiationRef = componentInstantiationRef_
        elif nodeName_ == 'designInstantiationRef':
            designInstantiationRef_ = child_.text
            designInstantiationRef_ = self.gds_validate_string(designInstantiationRef_, node, 'designInstantiationRef')
            self.designInstantiationRef = designInstantiationRef_
        elif nodeName_ == 'designConfigurationInstantiationRef':
            designConfigurationInstantiationRef_ = child_.text
            designConfigurationInstantiationRef_ = self.gds_validate_string(designConfigurationInstantiationRef_, node, 'designConfigurationInstantiationRef')
            self.designConfigurationInstantiationRef = designConfigurationInstantiationRef_
# end class viewType


class envIdentifierType67(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['envIdentifierType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, envIdentifierType67)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if envIdentifierType67.subclass:
            return envIdentifierType67.subclass(*args_, **kwargs_)
        else:
            return envIdentifierType67(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='envIdentifierType67', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('envIdentifierType67')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='envIdentifierType67')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='envIdentifierType67', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='envIdentifierType67'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='envIdentifierType67', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class envIdentifierType67


class instantiationsType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('componentInstantiation', 'componentInstantiationType', 1, 0, {'type': 'componentInstantiationType', 'name': 'componentInstantiation', 'maxOccurs': 'unbounded'}, 35),
        MemberSpec_('designInstantiation', 'designInstantiationType', 1, 0, {'type': 'designInstantiationType', 'name': 'designInstantiation', 'maxOccurs': 'unbounded'}, 35),
        MemberSpec_('designConfigurationInstantiation', 'designConfigurationInstantiationType', 1, 0, {'type': 'designConfigurationInstantiationType', 'name': 'designConfigurationInstantiation', 'maxOccurs': 'unbounded'}, 35),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentInstantiation=None, designInstantiation=None, designConfigurationInstantiation=None):
        self.original_tagname_ = None
        if componentInstantiation is None:
            self.componentInstantiation = []
        else:
            self.componentInstantiation = componentInstantiation
        if designInstantiation is None:
            self.designInstantiation = []
        else:
            self.designInstantiation = designInstantiation
        if designConfigurationInstantiation is None:
            self.designConfigurationInstantiation = []
        else:
            self.designConfigurationInstantiation = designConfigurationInstantiation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instantiationsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instantiationsType.subclass:
            return instantiationsType.subclass(*args_, **kwargs_)
        else:
            return instantiationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentInstantiation(self): return self.componentInstantiation
    def set_componentInstantiation(self, componentInstantiation): self.componentInstantiation = componentInstantiation
    def add_componentInstantiation(self, value): self.componentInstantiation.append(value)
    def insert_componentInstantiation_at(self, index, value): self.componentInstantiation.insert(index, value)
    def replace_componentInstantiation_at(self, index, value): self.componentInstantiation[index] = value
    def get_designInstantiation(self): return self.designInstantiation
    def set_designInstantiation(self, designInstantiation): self.designInstantiation = designInstantiation
    def add_designInstantiation(self, value): self.designInstantiation.append(value)
    def insert_designInstantiation_at(self, index, value): self.designInstantiation.insert(index, value)
    def replace_designInstantiation_at(self, index, value): self.designInstantiation[index] = value
    def get_designConfigurationInstantiation(self): return self.designConfigurationInstantiation
    def set_designConfigurationInstantiation(self, designConfigurationInstantiation): self.designConfigurationInstantiation = designConfigurationInstantiation
    def add_designConfigurationInstantiation(self, value): self.designConfigurationInstantiation.append(value)
    def insert_designConfigurationInstantiation_at(self, index, value): self.designConfigurationInstantiation.insert(index, value)
    def replace_designConfigurationInstantiation_at(self, index, value): self.designConfigurationInstantiation[index] = value
    def hasContent_(self):
        if (
            self.componentInstantiation or
            self.designInstantiation or
            self.designConfigurationInstantiation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='instantiationsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instantiationsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='instantiationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='instantiationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='instantiationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='instantiationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for componentInstantiation_ in self.componentInstantiation:
            componentInstantiation_.export(outfile, level, namespace_, name_='componentInstantiation', pretty_print=pretty_print)
        for designInstantiation_ in self.designInstantiation:
            designInstantiation_.export(outfile, level, namespace_, name_='designInstantiation', pretty_print=pretty_print)
        for designConfigurationInstantiation_ in self.designConfigurationInstantiation:
            designConfigurationInstantiation_.export(outfile, level, namespace_, name_='designConfigurationInstantiation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'componentInstantiation':
            obj_ = componentInstantiationType.factory()
            obj_.build(child_)
            self.componentInstantiation.append(obj_)
            obj_.original_tagname_ = 'componentInstantiation'
        elif nodeName_ == 'designInstantiation':
            obj_ = designInstantiationType.factory()
            obj_.build(child_)
            self.designInstantiation.append(obj_)
            obj_.original_tagname_ = 'designInstantiation'
        elif nodeName_ == 'designConfigurationInstantiation':
            obj_ = designConfigurationInstantiationType.factory()
            obj_.build(child_)
            self.designConfigurationInstantiation.append(obj_)
            obj_.original_tagname_ = 'designConfigurationInstantiation'
# end class instantiationsType


class portsType68(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('port', 'portType', 1, 0, {'maxOccurs': 'unbounded', 'ref': 'port', 'name': 'port', 'type': 'portType34'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, port=None):
        self.original_tagname_ = None
        if port is None:
            self.port = []
        else:
            self.port = port
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portsType68)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portsType68.subclass:
            return portsType68.subclass(*args_, **kwargs_)
        else:
            return portsType68(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def add_port(self, value): self.port.append(value)
    def insert_port_at(self, index, value): self.port.insert(index, value)
    def replace_port_at(self, index, value): self.port[index] = value
    def hasContent_(self):
        if (
            self.port
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='portsType68', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portsType68')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portsType68')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='portsType68', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='portsType68'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='portsType68', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for port_ in self.port:
            port_.export(outfile, level, namespace_='ipxact:', name_='port', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port':
            obj_ = Port.factory()
            obj_.build(child_)
            self.port.append(obj_)
            obj_.original_tagname_ = 'port'
# end class portsType68


class viewsType69(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('view', 'viewType70', 1, 0, {'maxOccurs': 'unbounded', 'name': 'view', 'type': 'viewType70'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, view=None):
        self.original_tagname_ = None
        if view is None:
            self.view = []
        else:
            self.view = view
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewsType69)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewsType69.subclass:
            return viewsType69.subclass(*args_, **kwargs_)
        else:
            return viewsType69(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_view(self): return self.view
    def set_view(self, view): self.view = view
    def add_view(self, value): self.view.append(value)
    def insert_view_at(self, index, value): self.view.insert(index, value)
    def replace_view_at(self, index, value): self.view[index] = value
    def hasContent_(self):
        if (
            self.view
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewsType69', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewsType69')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewsType69')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewsType69', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewsType69'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewsType69', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for view_ in self.view:
            view_.export(outfile, level, namespace_, name_='view', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'view':
            obj_ = viewType70.factory()
            obj_.build(child_)
            self.view.append(obj_)
            obj_.original_tagname_ = 'view'
# end class viewsType69


class viewType70(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('name', 'xs:NMTOKEN', 0, 0, {'type': 'xs:NMTOKEN', 'name': 'name'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('envIdentifier', 'envIdentifierType71', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'envIdentifier', 'type': 'envIdentifierType71'}, None),
        MemberSpec_('componentInstantiationRef', 'xs:NMTOKEN', 0, 1, {'minOccurs': '0', 'type': 'xs:NMTOKEN', 'name': 'componentInstantiationRef'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, name=None, displayName=None, description=None, isPresent=None, envIdentifier=None, componentInstantiationRef=None):
        self.original_tagname_ = None
        self.name = name
        self.displayName = displayName
        self.description = description
        self.isPresent = isPresent
        if envIdentifier is None:
            self.envIdentifier = []
        else:
            self.envIdentifier = envIdentifier
        self.componentInstantiationRef = componentInstantiationRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewType70)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewType70.subclass:
            return viewType70.subclass(*args_, **kwargs_)
        else:
            return viewType70(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_envIdentifier(self): return self.envIdentifier
    def set_envIdentifier(self, envIdentifier): self.envIdentifier = envIdentifier
    def add_envIdentifier(self, value): self.envIdentifier.append(value)
    def insert_envIdentifier_at(self, index, value): self.envIdentifier.insert(index, value)
    def replace_envIdentifier_at(self, index, value): self.envIdentifier[index] = value
    def get_componentInstantiationRef(self): return self.componentInstantiationRef
    def set_componentInstantiationRef(self, componentInstantiationRef): self.componentInstantiationRef = componentInstantiationRef
    def hasContent_(self):
        if (
            self.name is not None or
            self.displayName is not None or
            self.description is not None or
            self.isPresent is not None or
            self.envIdentifier or
            self.componentInstantiationRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewType70', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewType70')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewType70')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewType70', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewType70'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewType70', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:name>%s</ipxact:name>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.name), input_name='name')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for envIdentifier_ in self.envIdentifier:
            envIdentifier_.export(outfile, level, namespace_, name_='envIdentifier', pretty_print=pretty_print)
        if self.componentInstantiationRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:componentInstantiationRef>%s</ipxact:componentInstantiationRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.componentInstantiationRef), input_name='componentInstantiationRef')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'envIdentifier':
            obj_ = envIdentifierType71.factory()
            obj_.build(child_)
            self.envIdentifier.append(obj_)
            obj_.original_tagname_ = 'envIdentifier'
        elif nodeName_ == 'componentInstantiationRef':
            componentInstantiationRef_ = child_.text
            componentInstantiationRef_ = self.gds_validate_string(componentInstantiationRef_, node, 'componentInstantiationRef')
            self.componentInstantiationRef = componentInstantiationRef_
# end class viewType70


class envIdentifierType71(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['envIdentifierType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, envIdentifierType71)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if envIdentifierType71.subclass:
            return envIdentifierType71.subclass(*args_, **kwargs_)
        else:
            return envIdentifierType71(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='envIdentifierType71', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('envIdentifierType71')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='envIdentifierType71')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='envIdentifierType71', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='envIdentifierType71'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='envIdentifierType71', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class envIdentifierType71


class instantiationsType72(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('componentInstantiation', 'componentInstantiationType', 1, 0, {'type': 'componentInstantiationType', 'name': 'componentInstantiation', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentInstantiation=None):
        self.original_tagname_ = None
        if componentInstantiation is None:
            self.componentInstantiation = []
        else:
            self.componentInstantiation = componentInstantiation
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instantiationsType72)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instantiationsType72.subclass:
            return instantiationsType72.subclass(*args_, **kwargs_)
        else:
            return instantiationsType72(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_componentInstantiation(self): return self.componentInstantiation
    def set_componentInstantiation(self, componentInstantiation): self.componentInstantiation = componentInstantiation
    def add_componentInstantiation(self, value): self.componentInstantiation.append(value)
    def insert_componentInstantiation_at(self, index, value): self.componentInstantiation.insert(index, value)
    def replace_componentInstantiation_at(self, index, value): self.componentInstantiation[index] = value
    def hasContent_(self):
        if (
            self.componentInstantiation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='instantiationsType72', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instantiationsType72')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='instantiationsType72')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='instantiationsType72', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='instantiationsType72'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='instantiationsType72', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for componentInstantiation_ in self.componentInstantiation:
            componentInstantiation_.export(outfile, level, namespace_, name_='componentInstantiation', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'componentInstantiation':
            obj_ = componentInstantiationType.factory()
            obj_.build(child_)
            self.componentInstantiation.append(obj_)
            obj_.original_tagname_ = 'componentInstantiation'
# end class instantiationsType72


class portsType73(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('port', 'portType', 1, 1, {'minOccurs': '0', 'type': 'abstractorPortType', 'name': 'port', 'maxOccurs': 'unbounded'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, port=None):
        self.original_tagname_ = None
        if port is None:
            self.port = []
        else:
            self.port = port
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, portsType73)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if portsType73.subclass:
            return portsType73.subclass(*args_, **kwargs_)
        else:
            return portsType73(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def add_port(self, value): self.port.append(value)
    def insert_port_at(self, index, value): self.port.insert(index, value)
    def replace_port_at(self, index, value): self.port[index] = value
    def hasContent_(self):
        if (
            self.port
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='portsType73', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('portsType73')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='portsType73')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='portsType73', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='portsType73'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='portsType73', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for port_ in self.port:
            port_.export(outfile, level, namespace_, name_='port', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port':
            obj_ = Port.factory()
            obj_.build(child_)
            self.port.append(obj_)
            obj_.original_tagname_ = 'port'
# end class portsType73


class interconnectionConfigurationType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('interconnectionRef', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'interconnectionRef'}, None),
        MemberSpec_('abstractorInstances', 'abstractorInstancesType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'abstractorInstances', 'type': 'abstractorInstancesType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, isPresent=None, interconnectionRef=None, abstractorInstances=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.isPresent = isPresent
        self.interconnectionRef = interconnectionRef
        if abstractorInstances is None:
            self.abstractorInstances = []
        else:
            self.abstractorInstances = abstractorInstances
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interconnectionConfigurationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interconnectionConfigurationType.subclass:
            return interconnectionConfigurationType.subclass(*args_, **kwargs_)
        else:
            return interconnectionConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_interconnectionRef(self): return self.interconnectionRef
    def set_interconnectionRef(self, interconnectionRef): self.interconnectionRef = interconnectionRef
    def get_abstractorInstances(self): return self.abstractorInstances
    def set_abstractorInstances(self, abstractorInstances): self.abstractorInstances = abstractorInstances
    def add_abstractorInstances(self, value): self.abstractorInstances.append(value)
    def insert_abstractorInstances_at(self, index, value): self.abstractorInstances.insert(index, value)
    def replace_abstractorInstances_at(self, index, value): self.abstractorInstances[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.isPresent is not None or
            self.interconnectionRef is not None or
            self.abstractorInstances
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='interconnectionConfigurationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('interconnectionConfigurationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interconnectionConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='interconnectionConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='interconnectionConfigurationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='interconnectionConfigurationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.interconnectionRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:interconnectionRef>%s</ipxact:interconnectionRef>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.interconnectionRef), input_name='interconnectionRef')), eol_))
        for abstractorInstances_ in self.abstractorInstances:
            abstractorInstances_.export(outfile, level, namespace_, name_='abstractorInstances', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'interconnectionRef':
            interconnectionRef_ = child_.text
            interconnectionRef_ = self.gds_validate_string(interconnectionRef_, node, 'interconnectionRef')
            self.interconnectionRef = interconnectionRef_
        elif nodeName_ == 'abstractorInstances':
            obj_ = abstractorInstancesType.factory()
            obj_.build(child_)
            self.abstractorInstances.append(obj_)
            obj_.original_tagname_ = 'abstractorInstances'
# end class interconnectionConfigurationType


class abstractorInstancesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('interfaceRef', 'interfaceRefType', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'interfaceRef', 'type': 'interfaceRefType'}, None),
        MemberSpec_('abstractorInstance', 'abstractorInstanceType', 1, 0, {'maxOccurs': 'unbounded', 'name': 'abstractorInstance', 'type': 'abstractorInstanceType'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, isPresent=None, interfaceRef=None, abstractorInstance=None):
        self.original_tagname_ = None
        self.isPresent = isPresent
        if interfaceRef is None:
            self.interfaceRef = []
        else:
            self.interfaceRef = interfaceRef
        if abstractorInstance is None:
            self.abstractorInstance = []
        else:
            self.abstractorInstance = abstractorInstance
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorInstancesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorInstancesType.subclass:
            return abstractorInstancesType.subclass(*args_, **kwargs_)
        else:
            return abstractorInstancesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_interfaceRef(self): return self.interfaceRef
    def set_interfaceRef(self, interfaceRef): self.interfaceRef = interfaceRef
    def add_interfaceRef(self, value): self.interfaceRef.append(value)
    def insert_interfaceRef_at(self, index, value): self.interfaceRef.insert(index, value)
    def replace_interfaceRef_at(self, index, value): self.interfaceRef[index] = value
    def get_abstractorInstance(self): return self.abstractorInstance
    def set_abstractorInstance(self, abstractorInstance): self.abstractorInstance = abstractorInstance
    def add_abstractorInstance(self, value): self.abstractorInstance.append(value)
    def insert_abstractorInstance_at(self, index, value): self.abstractorInstance.insert(index, value)
    def replace_abstractorInstance_at(self, index, value): self.abstractorInstance[index] = value
    def hasContent_(self):
        if (
            self.isPresent is not None or
            self.interfaceRef or
            self.abstractorInstance
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractorInstancesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorInstancesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractorInstancesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractorInstancesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractorInstancesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractorInstancesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        for interfaceRef_ in self.interfaceRef:
            interfaceRef_.export(outfile, level, namespace_, name_='interfaceRef', pretty_print=pretty_print)
        for abstractorInstance_ in self.abstractorInstance:
            abstractorInstance_.export(outfile, level, namespace_, name_='abstractorInstance', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'interfaceRef':
            obj_ = interfaceRefType.factory()
            obj_.build(child_)
            self.interfaceRef.append(obj_)
            obj_.original_tagname_ = 'interfaceRef'
        elif nodeName_ == 'abstractorInstance':
            obj_ = abstractorInstanceType.factory()
            obj_.build(child_)
            self.abstractorInstance.append(obj_)
            obj_.original_tagname_ = 'abstractorInstance'
# end class abstractorInstancesType


class interfaceRefType(GeneratedsSuper):
    """Reference to a component instance nane.Reference to a component bus
    interface name."""
    member_data_items_ = [
        MemberSpec_('componentRef', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('busRef', 'xs:Name', 0, 0, {'use': 'required'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, componentRef=None, busRef=None, isPresent=None):
        self.original_tagname_ = None
        self.componentRef = _cast(None, componentRef)
        self.busRef = _cast(None, busRef)
        self.isPresent = isPresent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, interfaceRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if interfaceRefType.subclass:
            return interfaceRefType.subclass(*args_, **kwargs_)
        else:
            return interfaceRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_componentRef(self): return self.componentRef
    def set_componentRef(self, componentRef): self.componentRef = componentRef
    def get_busRef(self): return self.busRef
    def set_busRef(self, busRef): self.busRef = busRef
    def hasContent_(self):
        if (
            self.isPresent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='interfaceRefType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('interfaceRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interfaceRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='interfaceRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='interfaceRefType'):
        if self.componentRef is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            outfile.write(' componentRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.componentRef), input_name='componentRef')), ))
        if self.busRef is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            outfile.write(' busRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.busRef), input_name='busRef')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='interfaceRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('componentRef', node)
        if value is not None and 'componentRef' not in already_processed:
            already_processed.add('componentRef')
            self.componentRef = value
        value = find_attr_value_('busRef', node)
        if value is not None and 'busRef' not in already_processed:
            already_processed.add('busRef')
            self.busRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
# end class interfaceRefType


class abstractorInstanceType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('instanceName', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'instanceName'}, None),
        MemberSpec_('displayName', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'displayName', 'name': 'displayName'}, None),
        MemberSpec_('description', 'xs:string', 0, 1, {'minOccurs': '0', 'type': 'xs:string', 'ref': 'description', 'name': 'description'}, None),
        MemberSpec_('abstractorRef', 'configurableLibraryRefType', 0, 0, {'type': 'configurableLibraryRefType', 'name': 'abstractorRef'}, None),
        MemberSpec_('viewName', 'xs:Name', 0, 0, {'type': 'xs:Name', 'name': 'viewName'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, instanceName=None, displayName=None, description=None, abstractorRef=None, viewName=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.instanceName = instanceName
        self.displayName = displayName
        self.description = description
        self.abstractorRef = abstractorRef
        self.viewName = viewName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorInstanceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorInstanceType.subclass:
            return abstractorInstanceType.subclass(*args_, **kwargs_)
        else:
            return abstractorInstanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instanceName(self): return self.instanceName
    def set_instanceName(self, instanceName): self.instanceName = instanceName
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_abstractorRef(self): return self.abstractorRef
    def set_abstractorRef(self, abstractorRef): self.abstractorRef = abstractorRef
    def get_viewName(self): return self.viewName
    def set_viewName(self, viewName): self.viewName = viewName
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.instanceName is not None or
            self.displayName is not None or
            self.description is not None or
            self.abstractorRef is not None or
            self.viewName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractorInstanceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorInstanceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractorInstanceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractorInstanceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractorInstanceType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractorInstanceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.instanceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:instanceName>%s</ipxact:instanceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.instanceName), input_name='instanceName')), eol_))
        if self.displayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:displayName>%s</ipxact:displayName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.displayName), input_name='displayName')), eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:description>%s</ipxact:description>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), eol_))
        if self.abstractorRef is not None:
            self.abstractorRef.export(outfile, level, namespace_, name_='abstractorRef', pretty_print=pretty_print)
        if self.viewName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:viewName>%s</ipxact:viewName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.viewName), input_name='viewName')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instanceName':
            instanceName_ = child_.text
            instanceName_ = self.gds_validate_string(instanceName_, node, 'instanceName')
            self.instanceName = instanceName_
        elif nodeName_ == 'displayName':
            displayName_ = child_.text
            displayName_ = self.gds_validate_string(displayName_, node, 'displayName')
            self.displayName = displayName_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'abstractorRef':
            obj_ = ConfigurableLibraryRef.factory()
            obj_.build(child_)
            self.abstractorRef = obj_
            obj_.original_tagname_ = 'abstractorRef'
        elif nodeName_ == 'viewName':
            viewName_ = child_.text
            viewName_ = self.gds_validate_string(viewName_, node, 'viewName')
            self.viewName = viewName_
# end class abstractorInstanceType


class viewConfigurationType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('instanceName', 'xs:Name', 0, 0, {'type': 'xs:Name', 'ref': 'instanceName', 'name': 'instanceName'}, None),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'unsignedBitExpression', 'ref': 'isPresent', 'name': 'isPresent'}, None),
        MemberSpec_('view', 'viewType74', 0, 0, {'type': 'viewType74', 'name': 'view'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, id=None, instanceName=None, isPresent=None, view=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.instanceName = instanceName
        self.isPresent = isPresent
        self.view = view
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewConfigurationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewConfigurationType.subclass:
            return viewConfigurationType.subclass(*args_, **kwargs_)
        else:
            return viewConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instanceName(self): return self.instanceName
    def set_instanceName(self, instanceName): self.instanceName = instanceName
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_view(self): return self.view
    def set_view(self, view): self.view = view
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.instanceName is not None or
            self.isPresent is not None or
            self.view is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewConfigurationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewConfigurationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewConfigurationType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewConfigurationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.instanceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<ipxact:instanceName>%s</ipxact:instanceName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(self.instanceName), input_name='instanceName')), eol_))
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
        if self.view is not None:
            self.view.export(outfile, level, namespace_, name_='view', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'instanceName':
            instanceName_ = child_.text
            instanceName_ = self.gds_validate_string(instanceName_, node, 'instanceName')
            self.instanceName = instanceName_
        elif nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        elif nodeName_ == 'view':
            obj_ = viewType74.factory()
            obj_.build(child_)
            self.view = obj_
            obj_.original_tagname_ = 'view'
# end class viewConfigurationType


class viewType74(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('viewRef', 'xs:NMTOKEN', 0, 0, {'use': 'required'}),
        MemberSpec_('configurableElementValues', 'configurableElementValues', 0, 1, {'minOccurs': '0', 'type': 'configurableElementValues', 'ref': 'configurableElementValues', 'name': 'configurableElementValues'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, viewRef=None, configurableElementValues=None):
        self.original_tagname_ = None
        self.viewRef = _cast(None, viewRef)
        self.configurableElementValues = configurableElementValues
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, viewType74)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if viewType74.subclass:
            return viewType74.subclass(*args_, **kwargs_)
        else:
            return viewType74(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_configurableElementValues(self): return self.configurableElementValues
    def set_configurableElementValues(self, configurableElementValues): self.configurableElementValues = configurableElementValues
    def get_viewRef(self): return self.viewRef
    def set_viewRef(self, viewRef): self.viewRef = viewRef
    def hasContent_(self):
        if (
            self.configurableElementValues is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='viewType74', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('viewType74')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='viewType74')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='viewType74', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='viewType74'):
        if self.viewRef is not None and 'viewRef' not in already_processed:
            already_processed.add('viewRef')
            outfile.write(' viewRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.viewRef), input_name='viewRef')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='viewType74', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.configurableElementValues is not None:
            self.configurableElementValues.export(outfile, level, namespace_='ipxact:', name_='configurableElementValues', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('viewRef', node)
        if value is not None and 'viewRef' not in already_processed:
            already_processed.add('viewRef')
            self.viewRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'configurableElementValues':
            obj_ = configurableElementValues.factory()
            obj_.build(child_)
            self.configurableElementValues = obj_
            obj_.original_tagname_ = 'configurableElementValues'
# end class viewType74


class abstractorModeType75(GeneratedsSuper):
    """Define the system group if the mode is set to system"""
    member_data_items_ = [
        MemberSpec_('group', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', ['abstractorModeType', 'xs:string'], 0),
    ]
    subclass = None
    superclass = None
    def __init__(self, group=None, valueOf_=None):
        self.original_tagname_ = None
        self.group = _cast(None, group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorModeType75)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorModeType75.subclass:
            return abstractorModeType75.subclass(*args_, **kwargs_)
        else:
            return abstractorModeType75(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractorModeType75', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorModeType75')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractorModeType75')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractorModeType75', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractorModeType75'):
        if self.group is not None and 'group' not in already_processed:
            already_processed.add('group')
            outfile.write(' group=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.group), input_name='group')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractorModeType75', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('group', node)
        if value is not None and 'group' not in already_processed:
            already_processed.add('group')
            self.group = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class abstractorModeType75


class abstractorInterfacesType(GeneratedsSuper):
    member_data_items_ = [
        MemberSpec_('abstractorInterface', 'abstractorBusInterfaceType', 1, 0, {'minOccurs': '2', 'type': 'abstractorBusInterfaceType', 'name': 'abstractorInterface', 'maxOccurs': '2'}, None),
    ]
    subclass = None
    superclass = None
    def __init__(self, abstractorInterface=None):
        self.original_tagname_ = None
        if abstractorInterface is None:
            self.abstractorInterface = []
        else:
            self.abstractorInterface = abstractorInterface
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, abstractorInterfacesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if abstractorInterfacesType.subclass:
            return abstractorInterfacesType.subclass(*args_, **kwargs_)
        else:
            return abstractorInterfacesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_abstractorInterface(self): return self.abstractorInterface
    def set_abstractorInterface(self, abstractorInterface): self.abstractorInterface = abstractorInterface
    def add_abstractorInterface(self, value): self.abstractorInterface.append(value)
    def insert_abstractorInterface_at(self, index, value): self.abstractorInterface.insert(index, value)
    def replace_abstractorInterface_at(self, index, value): self.abstractorInterface[index] = value
    def hasContent_(self):
        if (
            self.abstractorInterface
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='abstractorInterfacesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('abstractorInterfacesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstractorInterfacesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='abstractorInterfacesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='abstractorInterfacesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='abstractorInterfacesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for abstractorInterface_ in self.abstractorInterface:
            abstractorInterface_.export(outfile, level, namespace_, name_='abstractorInterface', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'abstractorInterface':
            obj_ = abstractorBusInterfaceType.factory()
            obj_.build(child_)
            self.abstractorInterface.append(obj_)
            obj_.original_tagname_ = 'abstractorInterface'
# end class abstractorInterfacesType


class instanceGeneratorType(generatorType):
    """The scope attribute applies to component generators and specifies
    whether the generator should be run for each instance of the
    entity (or module) or just once for all instances of the entity."""
    member_data_items_ = [
        MemberSpec_('scope', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('group', 'xs:Name', 1, 1, {'minOccurs': '0', 'maxOccurs': 'unbounded', 'name': 'group', 'type': 'groupType17'}, None),
    ]
    subclass = None
    superclass = generatorType
    def __init__(self, hidden=False, id=None, name=None, displayName=None, description=None, phase=None, parameters=None, apiType=None, transportMethods=None, generatorExe=None, vendorExtensions=None, scope='instance', group=None):
        self.original_tagname_ = None
        super(instanceGeneratorType, self).__init__(hidden, id, name, displayName, description, phase, parameters, apiType, transportMethods, generatorExe, vendorExtensions, )
        self.scope = _cast(None, scope)
        if group is None:
            self.group = []
        else:
            self.group = group
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, instanceGeneratorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if instanceGeneratorType.subclass:
            return instanceGeneratorType.subclass(*args_, **kwargs_)
        else:
            return instanceGeneratorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def add_group(self, value): self.group.append(value)
    def insert_group_at(self, index, value): self.group.insert(index, value)
    def replace_group_at(self, index, value): self.group[index] = value
    def get_scope(self): return self.scope
    def set_scope(self, scope): self.scope = scope
    def hasContent_(self):
        if (
            self.group or
            super(instanceGeneratorType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='instanceGeneratorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('instanceGeneratorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='instanceGeneratorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='instanceGeneratorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='instanceGeneratorType'):
        super(instanceGeneratorType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='instanceGeneratorType')
        if self.scope != "instance" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.scope), input_name='scope')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='instanceGeneratorType', fromsubclass_=False, pretty_print=True):
        super(instanceGeneratorType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for group_ in self.group:
            group_.export(outfile, level, namespace_, name_='group', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
        super(instanceGeneratorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            obj_ = xs_Name.factory()
            obj_.build(child_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
        super(instanceGeneratorType, self).buildChildren(child_, node, nodeName_, True)
# end class instanceGeneratorType


class generator(generatorType):
    """Specifies a set of generators."""
    member_data_items_ = [
    ]
    subclass = None
    superclass = generatorType
    def __init__(self, hidden=False, id=None, name=None, displayName=None, description=None, phase=None, parameters=None, apiType=None, transportMethods=None, generatorExe=None, vendorExtensions=None):
        self.original_tagname_ = None
        super(generator, self).__init__(hidden, id, name, displayName, description, phase, parameters, apiType, transportMethods, generatorExe, vendorExtensions, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, generator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if generator.subclass:
            return generator.subclass(*args_, **kwargs_)
        else:
            return generator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(generator, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='generator', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('generator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='generator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='generator', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='generator'):
        super(generator, self).exportAttributes(outfile, level, already_processed, namespace_, name_='generator')
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='generator', fromsubclass_=False, pretty_print=True):
        super(generator, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(generator, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(generator, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class generator


class dependency(ipxactURI):
    """Specifies a location on which files or fileSets may be dependent.
    Typically, this would be a directory that would contain included
    files."""
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'ipxactURI', 0),
    ]
    subclass = None
    superclass = ipxactURI
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        super(dependency, self).__init__(valueOf_, )
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dependency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dependency.subclass:
            return dependency.subclass(*args_, **kwargs_)
        else:
            return dependency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dependency, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='dependency', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dependency')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dependency')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='dependency', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='dependency'):
        super(dependency, self).exportAttributes(outfile, level, already_processed, namespace_, name_='dependency')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='dependency', fromsubclass_=False, pretty_print=True):
        super(dependency, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dependency, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dependency


class clockDriver(clockDriverType):
    """Describes a driven clock port. Indicates the name of the cllock. If
    not specified the name is assumed to be the name of the
    containing port."""
    member_data_items_ = [
        MemberSpec_('clockName', 'xs:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = clockDriverType
    def __init__(self, id=None, clockPeriod=None, clockPulseOffset=None, clockPulseValue=None, clockPulseDuration=None, clockName=None):
        self.original_tagname_ = None
        super(clockDriver, self).__init__(id, clockPeriod, clockPulseOffset, clockPulseValue, clockPulseDuration, )
        self.clockName = _cast(None, clockName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clockDriver)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clockDriver.subclass:
            return clockDriver.subclass(*args_, **kwargs_)
        else:
            return clockDriver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clockName(self): return self.clockName
    def set_clockName(self, clockName): self.clockName = clockName
    def hasContent_(self):
        if (
            super(clockDriver, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='clockDriver', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clockDriver')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='clockDriver')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='clockDriver', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='clockDriver'):
        super(clockDriver, self).exportAttributes(outfile, level, already_processed, namespace_, name_='clockDriver')
        if self.clockName is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            outfile.write(' clockName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.clockName), input_name='clockName')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='clockDriver', fromsubclass_=False, pretty_print=True):
        super(clockDriver, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('clockName', node)
        if value is not None and 'clockName' not in already_processed:
            already_processed.add('clockName')
            self.clockName = value
        super(clockDriver, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(clockDriver, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class clockDriver


class moduleParameterType(parameterType):
    """Name value pair with data type information.The data type of the
    argument as pertains to the language. Example: "int", "double",
    "char *".Indicates the type of the module parameter. Legal
    values are defined in the attribute enumeration list. Default
    value is 'nontyped'."""
    member_data_items_ = [
        MemberSpec_('dataType', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('usageType', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('isPresent', 'unsignedBitExpression', 0, 1, {'minOccurs': '0', 'type': 'isPresent', 'ref': 'isPresent', 'name': 'isPresent'}, None),
    ]
    subclass = None
    superclass = parameterType
    def __init__(self, parameterId=None, prompt=None, choiceRef=None, order=None, configGroups=None, minimum=None, maximum=None, type_='string', sign=None, prefix=None, unit=None, name=None, displayName=None, description=None, Vectors=None, arrays=None, value=None, vendorExtensions=None, resolve='immediate', dataType=None, usageType='nontyped', isPresent=None):
        self.original_tagname_ = None
        super(moduleParameterType, self).__init__(parameterId, prompt, choiceRef, order, configGroups, minimum, maximum, type_, sign, prefix, unit, name, displayName, description, Vectors, arrays, value, vendorExtensions, resolve, )
        self.dataType = _cast(None, dataType)
        self.usageType = _cast(None, usageType)
        self.isPresent = isPresent
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, moduleParameterType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if moduleParameterType.subclass:
            return moduleParameterType.subclass(*args_, **kwargs_)
        else:
            return moduleParameterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isPresent(self): return self.isPresent
    def set_isPresent(self, isPresent): self.isPresent = isPresent
    def get_dataType(self): return self.dataType
    def set_dataType(self, dataType): self.dataType = dataType
    def get_usageType(self): return self.usageType
    def set_usageType(self, usageType): self.usageType = usageType
    def hasContent_(self):
        if (
            self.isPresent is not None or
            super(moduleParameterType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='moduleParameterType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('moduleParameterType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='moduleParameterType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='moduleParameterType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='moduleParameterType'):
        super(moduleParameterType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='moduleParameterType')
        if self.dataType is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            outfile.write(' dataType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dataType), input_name='dataType')), ))
        if self.usageType != "nontyped" and 'usageType' not in already_processed:
            already_processed.add('usageType')
            outfile.write(' usageType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.usageType), input_name='usageType')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='moduleParameterType', fromsubclass_=False, pretty_print=True):
        super(moduleParameterType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isPresent is not None:
            self.isPresent.export(outfile, level, namespace_='ipxact:', name_='isPresent', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataType', node)
        if value is not None and 'dataType' not in already_processed:
            already_processed.add('dataType')
            self.dataType = value
        value = find_attr_value_('usageType', node)
        if value is not None and 'usageType' not in already_processed:
            already_processed.add('usageType')
            self.usageType = value
        super(moduleParameterType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isPresent':
            class_obj_ = self.get_class_obj_(child_, unsignedBitExpression)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.isPresent = obj_
            obj_.original_tagname_ = 'isPresent'
        super(moduleParameterType, self).buildChildren(child_, node, nodeName_, True)
# end class moduleParameterType


class hierInterface(interfaceType):
    """Hierarchical reference to an interfaceA decending hierarchical
    (slash separated - example x/y/z) path to the component instance
    containing the specified component instance in componentRef. If
    not specified the componentRef instance shall exist in the
    current design."""
    member_data_items_ = [
        MemberSpec_('path', 'ipxact:instancePath', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = interfaceType
    def __init__(self, componentRef=None, busRef=None, id=None, path=None):
        self.original_tagname_ = None
        super(hierInterface, self).__init__(componentRef, busRef, id, )
        self.path = _cast(None, path)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, hierInterface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if hierInterface.subclass:
            return hierInterface.subclass(*args_, **kwargs_)
        else:
            return hierInterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def hasContent_(self):
        if (
            super(hierInterface, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='hierInterface', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('hierInterface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hierInterface')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='hierInterface', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='hierInterface'):
        super(hierInterface, self).exportAttributes(outfile, level, already_processed, namespace_, name_='hierInterface')
        if self.path is not None and 'path' not in already_processed:
            already_processed.add('path')
            outfile.write(' path=%s' % (quote_attrib(self.path), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='hierInterface', fromsubclass_=False, pretty_print=True):
        super(hierInterface, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('path', node)
        if value is not None and 'path' not in already_processed:
            already_processed.add('path')
            self.path = value
        super(hierInterface, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(hierInterface, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class hierInterface


class unsignedBitVectorExpression(complexBaseExpression):
    """Represents a bit-string. It supports an expression value."""
    member_data_items_ = [
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(unsignedBitVectorExpression, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedBitVectorExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedBitVectorExpression.subclass:
            return unsignedBitVectorExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedBitVectorExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedBitVectorExpression, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='unsignedBitVectorExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedBitVectorExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedBitVectorExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='unsignedBitVectorExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='unsignedBitVectorExpression'):
        super(unsignedBitVectorExpression, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedBitVectorExpression')
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='unsignedBitVectorExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedBitVectorExpression, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(unsignedBitVectorExpression, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class unsignedBitVectorExpression


class unsignedBitExpression(complexBaseExpression):
    """Represents a single-bit/bool. It supports an expression value."""
    member_data_items_ = [
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(unsignedBitExpression, self).__init__(valueOf_, extensiontype_, )
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedBitExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedBitExpression.subclass:
            return unsignedBitExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedBitExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedBitExpression, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='unsignedBitExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedBitExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedBitExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='unsignedBitExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='unsignedBitExpression'):
        super(unsignedBitExpression, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedBitExpression')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='unsignedBitExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedBitExpression, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(unsignedBitExpression, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class unsignedBitExpression


class stringURIExpression(complexBaseExpression):
    """IP-XACT URI, like a standard xs:anyURI except that it can contain
    environment variables in the ${ } form, to be replaced by their
    value to provide the underlying URI"""
    member_data_items_ = [
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(stringURIExpression, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stringURIExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stringURIExpression.subclass:
            return stringURIExpression.subclass(*args_, **kwargs_)
        else:
            return stringURIExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(stringURIExpression, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='stringURIExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stringURIExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stringURIExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='stringURIExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='stringURIExpression'):
        super(stringURIExpression, self).exportAttributes(outfile, level, already_processed, namespace_, name_='stringURIExpression')
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='stringURIExpression', fromsubclass_=False, pretty_print=True):
        super(stringURIExpression, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(stringURIExpression, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stringURIExpression


class stringExpression(complexBaseExpression):
    """Represents a string. It supports an expression value."""
    member_data_items_ = [
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(stringExpression, self).__init__(valueOf_, extensiontype_, )
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, stringExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if stringExpression.subclass:
            return stringExpression.subclass(*args_, **kwargs_)
        else:
            return stringExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(stringExpression, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='stringExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('stringExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stringExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='stringExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='stringExpression'):
        super(stringExpression, self).exportAttributes(outfile, level, already_processed, namespace_, name_='stringExpression')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='stringExpression', fromsubclass_=False, pretty_print=True):
        super(stringExpression, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(stringExpression, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stringExpression


class realExpression(complexBaseExpression):
    """A real which supports an expression value.For elements which can be
    specified using expression which are supposed to be resolved to
    a real value, this indicates the minimum value allowed.For
    elements which can be specified using expression which are
    supposed to be resolved to a real value, this indicates the
    maximum value allowed."""
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('maximum', 'xs:double', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(realExpression, self).__init__(valueOf_, extensiontype_, )
        self.minimum = _cast(float, minimum)
        self.maximum = _cast(float, maximum)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, realExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if realExpression.subclass:
            return realExpression.subclass(*args_, **kwargs_)
        else:
            return realExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(realExpression, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='realExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('realExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='realExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='realExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='realExpression'):
        super(realExpression, self).exportAttributes(outfile, level, already_processed, namespace_, name_='realExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_double(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_double(self.maximum, input_name='maximum'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='realExpression', fromsubclass_=False, pretty_print=True):
        super(realExpression, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            try:
                self.minimum = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimum): %s' % exp)
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            try:
                self.maximum = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maximum): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(realExpression, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class realExpression


class signedIntExpression(complexBaseExpression):
    """A signed int which supports an expression value.For elements which
    can be specified using expression which are supposed to be
    resolved to a long value, this indicates the minimum value
    allowed.For elements which can be specified using expression
    which are supposed to be resolved to a long value, this
    indicates the maximum value allowed."""
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None):
        self.original_tagname_ = None
        super(signedIntExpression, self).__init__(valueOf_, )
        self.minimum = _cast(int, minimum)
        self.maximum = _cast(int, maximum)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signedIntExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signedIntExpression.subclass:
            return signedIntExpression.subclass(*args_, **kwargs_)
        else:
            return signedIntExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(signedIntExpression, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='signedIntExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('signedIntExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='signedIntExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='signedIntExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='signedIntExpression'):
        super(signedIntExpression, self).exportAttributes(outfile, level, already_processed, namespace_, name_='signedIntExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='signedIntExpression', fromsubclass_=False, pretty_print=True):
        super(signedIntExpression, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            try:
                self.minimum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            try:
                self.maximum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(signedIntExpression, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class signedIntExpression


class unsignedPositiveIntExpression(complexBaseExpression):
    """An positive unsigned int which supports an expression value.For
    elements which can be specified using expression which are
    supposed to be resolved to an unsiged int value, this indicates
    the minimum value allowed.For elements which can be specified
    using expression which are supposed to be resolved to a unsigned
    int value, this indicates the maximum value allowed."""
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None):
        self.original_tagname_ = None
        super(unsignedPositiveIntExpression, self).__init__(valueOf_, )
        self.minimum = _cast(int, minimum)
        self.maximum = _cast(int, maximum)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedPositiveIntExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedPositiveIntExpression.subclass:
            return unsignedPositiveIntExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedPositiveIntExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedPositiveIntExpression, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='unsignedPositiveIntExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedPositiveIntExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedPositiveIntExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='unsignedPositiveIntExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='unsignedPositiveIntExpression'):
        super(unsignedPositiveIntExpression, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedPositiveIntExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='unsignedPositiveIntExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedPositiveIntExpression, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            try:
                self.minimum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            try:
                self.maximum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(unsignedPositiveIntExpression, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def parse_uint(self):
        import re
        expr = self.valueOf_
        base = 10

        horrible_regex_hack = re.compile(r"\('h([0-9A-Fa-f]+)\) / \$pow\(2,(\d+)\) % \$pow\(2,(\d+)\)")
        horrible_regex_match = horrible_regex_hack.match(expr)

        if len(expr) > 2 and expr[0:2] == '0x':
            # handle non-standard SystemVerilog (but commonly-used) syntax
            expr = expr[2:]
            base = 16
        #Super-dirty hack to handle a common pattern used by XSLT upgrade transforms
        elif horrible_regex_match:
            _g = horrible_regex_match.groups()
            expr = str(int(int(_g[0], 16) / 2**int(_g[1]) % 2**int(_g[2])))
            
        elif "'" in expr:
            sep = expr.find("'")
            # ignore any bit size specified before ' because size is handled by other IP-XACT properties
            if expr[sep+1] in ["h", "H"]:
                base = 16
            elif expr[sep+1] in ["d", "D"]:
                base = 10
            elif expr[sep+1] in ["o", "O"]:
                base = 8
            elif expr[sep+1] in ["b", "B"]:
                base = 2
            else:
                raise ValueError("Could not convert expression to an integer: {}".format(self.valueOf_))
            expr = expr[sep+2:]

        return int(expr.replace('_', ''), base)
# end class unsignedPositiveIntExpression


class unsignedIntExpression(complexBaseExpression):
    """An unsigned int which supports an expression value.For elements
    which can be specified using expression which are supposed to be
    resolved to an unsiged int value, this indicates the minimum
    value allowed.For elements which can be specified using
    expression which are supposed to be resolved to a unsigned int
    value, this indicates the maximum value allowed."""
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None):
        self.original_tagname_ = None
        super(unsignedIntExpression, self).__init__(valueOf_, )
        self.minimum = _cast(int, minimum)
        self.maximum = _cast(int, maximum)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedIntExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedIntExpression.subclass:
            return unsignedIntExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedIntExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedIntExpression, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='unsignedIntExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedIntExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedIntExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='unsignedIntExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='unsignedIntExpression'):
        super(unsignedIntExpression, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedIntExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='unsignedIntExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedIntExpression, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            try:
                self.minimum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            try:
                self.maximum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(unsignedIntExpression, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def parse_uint(self):
        import re
        expr = self.valueOf_
        base = 10

        horrible_regex_hack = re.compile(r"\('h([0-9A-Fa-f]+)\) / \$pow\(2,(\d+)\) % \$pow\(2,(\d+)\)")
        horrible_regex_match = horrible_regex_hack.match(expr)

        if len(expr) > 2 and expr[0:2] == '0x':
            # handle non-standard SystemVerilog (but commonly-used) syntax
            expr = expr[2:]
            base = 16
        #Super-dirty hack to handle a common pattern used by XSLT upgrade transforms
        elif horrible_regex_match:
            _g = horrible_regex_match.groups()
            expr = str(int(int(_g[0], 16) / 2**int(_g[1]) % 2**int(_g[2])))
            
        elif "'" in expr:
            sep = expr.find("'")
            # ignore any bit size specified before ' because size is handled by other IP-XACT properties
            if expr[sep+1] in ["h", "H"]:
                base = 16
            elif expr[sep+1] in ["d", "D"]:
                base = 10
            elif expr[sep+1] in ["o", "O"]:
                base = 8
            elif expr[sep+1] in ["b", "B"]:
                base = 2
            else:
                raise ValueError("Could not convert expression to an integer: {}".format(self.valueOf_))
            expr = expr[sep+2:]

        return int(expr.replace('_', ''), base)
# end class unsignedIntExpression


class signedLongintExpression(complexBaseExpression):
    """An unsigned longint which supports an expression value.For elements
    which can be specified using expression which are supposed to be
    resolved to a signed longint value, this indicates the minimum
    value allowed.For elements which can be specified using
    expression which are supposed to be resolved to a signed longint
    value, this indicates the maximum value allowed."""
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None):
        self.original_tagname_ = None
        super(signedLongintExpression, self).__init__(valueOf_, )
        self.minimum = _cast(int, minimum)
        self.maximum = _cast(int, maximum)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, signedLongintExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if signedLongintExpression.subclass:
            return signedLongintExpression.subclass(*args_, **kwargs_)
        else:
            return signedLongintExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(signedLongintExpression, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='signedLongintExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('signedLongintExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='signedLongintExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='signedLongintExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='signedLongintExpression'):
        super(signedLongintExpression, self).exportAttributes(outfile, level, already_processed, namespace_, name_='signedLongintExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='signedLongintExpression', fromsubclass_=False, pretty_print=True):
        super(signedLongintExpression, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            try:
                self.minimum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            try:
                self.maximum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(signedLongintExpression, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class signedLongintExpression


class unsignedPositiveLongintExpression(complexBaseExpression):
    """A positive unsigned longint which supports an expression value.For
    elements which can be specified using expression which are
    supposed to be resolved to a positive unsigned longint value,
    this indicates the minimum value allowed.For elements which can
    be specified using expression which are supposed to be resolved
    to a positive unsigned longint value, this indicates the maximum
    value allowed."""
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None):
        self.original_tagname_ = None
        super(unsignedPositiveLongintExpression, self).__init__(valueOf_, )
        self.minimum = _cast(int, minimum)
        self.maximum = _cast(int, maximum)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedPositiveLongintExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedPositiveLongintExpression.subclass:
            return unsignedPositiveLongintExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedPositiveLongintExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedPositiveLongintExpression, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='unsignedPositiveLongintExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedPositiveLongintExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedPositiveLongintExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='unsignedPositiveLongintExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='unsignedPositiveLongintExpression'):
        super(unsignedPositiveLongintExpression, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedPositiveLongintExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='unsignedPositiveLongintExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedPositiveLongintExpression, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            try:
                self.minimum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            try:
                self.maximum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(unsignedPositiveLongintExpression, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class unsignedPositiveLongintExpression


class unsignedLongintExpression(complexBaseExpression):
    """An unsigned longint which supports an expression value.For elements
    which can be specified using expression which are supposed to be
    resolved to a unsigend longint value, this indicates the minimum
    value allowed.For elements which can be specified using
    expression which are supposed to be resolved to an unsigend
    longint value, this indicates the maximum value allowed."""
    member_data_items_ = [
        MemberSpec_('minimum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('maximum', 'xs:int', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'complexBaseExpression', 0),
    ]
    subclass = None
    superclass = complexBaseExpression
    def __init__(self, minimum=None, maximum=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(unsignedLongintExpression, self).__init__(valueOf_, extensiontype_, )
        self.minimum = _cast(int, minimum)
        self.maximum = _cast(int, maximum)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, unsignedLongintExpression)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if unsignedLongintExpression.subclass:
            return unsignedLongintExpression.subclass(*args_, **kwargs_)
        else:
            return unsignedLongintExpression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimum(self): return self.minimum
    def set_minimum(self, minimum): self.minimum = minimum
    def get_maximum(self): return self.maximum
    def set_maximum(self, maximum): self.maximum = maximum
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(unsignedLongintExpression, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='unsignedLongintExpression', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('unsignedLongintExpression')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedLongintExpression')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='unsignedLongintExpression', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='unsignedLongintExpression'):
        super(unsignedLongintExpression, self).exportAttributes(outfile, level, already_processed, namespace_, name_='unsignedLongintExpression')
        if self.minimum is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            outfile.write(' minimum="%s"' % self.gds_format_integer(self.minimum, input_name='minimum'))
        if self.maximum is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            outfile.write(' maximum="%s"' % self.gds_format_integer(self.maximum, input_name='maximum'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='unsignedLongintExpression', fromsubclass_=False, pretty_print=True):
        super(unsignedLongintExpression, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimum', node)
        if value is not None and 'minimum' not in already_processed:
            already_processed.add('minimum')
            try:
                self.minimum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maximum', node)
        if value is not None and 'maximum' not in already_processed:
            already_processed.add('maximum')
            try:
                self.maximum = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(unsignedLongintExpression, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
    def parse_uint(self):
        import re
        expr = self.valueOf_
        base = 10

        horrible_regex_hack = re.compile(r"\('h([0-9A-Fa-f]+)\) / \$pow\(2,(\d+)\) % \$pow\(2,(\d+)\)")
        horrible_regex_match = horrible_regex_hack.match(expr)

        if len(expr) > 2 and expr[0:2] == '0x':
            # handle non-standard SystemVerilog (but commonly-used) syntax
            expr = expr[2:]
            base = 16
        #Super-dirty hack to handle a common pattern used by XSLT upgrade transforms
        elif horrible_regex_match:
            _g = horrible_regex_match.groups()
            expr = str(int(int(_g[0], 16) / 2**int(_g[1]) % 2**int(_g[2])))
            
        elif "'" in expr:
            sep = expr.find("'")
            # ignore any bit size specified before ' because size is handled by other IP-XACT properties
            if expr[sep+1] in ["h", "H"]:
                base = 16
            elif expr[sep+1] in ["d", "D"]:
                base = 10
            elif expr[sep+1] in ["o", "O"]:
                base = 8
            elif expr[sep+1] in ["b", "B"]:
                base = 2
            else:
                raise ValueError("Could not convert expression to an integer: {}".format(self.valueOf_))
            expr = expr[sep+2:]

        return int(expr.replace('_', ''), base)
# end class unsignedLongintExpression


class dimType66(unsignedLongintExpression):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        super(dimType66, self).__init__(minimum, maximum, valueOf_, )
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dimType66)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dimType66.subclass:
            return dimType66.subclass(*args_, **kwargs_)
        else:
            return dimType66(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dimType66, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='dimType66', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dimType66')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dimType66')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='dimType66', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='dimType66'):
        super(dimType66, self).exportAttributes(outfile, level, already_processed, namespace_, name_='dimType66')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='dimType66', fromsubclass_=False, pretty_print=True):
        super(dimType66, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dimType66, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dimType66


class dimType63(unsignedLongintExpression):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        super(dimType63, self).__init__(minimum, maximum, valueOf_, )
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dimType63)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dimType63.subclass:
            return dimType63.subclass(*args_, **kwargs_)
        else:
            return dimType63(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dimType63, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='dimType63', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dimType63')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dimType63')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='dimType63', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='dimType63'):
        super(dimType63, self).exportAttributes(outfile, level, already_processed, namespace_, name_='dimType63')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='dimType63', fromsubclass_=False, pretty_print=True):
        super(dimType63, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dimType63, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dimType63


class dimType57(unsignedLongintExpression):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        super(dimType57, self).__init__(minimum, maximum, valueOf_, )
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dimType57)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dimType57.subclass:
            return dimType57.subclass(*args_, **kwargs_)
        else:
            return dimType57(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dimType57, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='dimType57', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dimType57')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dimType57')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='dimType57', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='dimType57'):
        super(dimType57, self).exportAttributes(outfile, level, already_processed, namespace_, name_='dimType57')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='dimType57', fromsubclass_=False, pretty_print=True):
        super(dimType57, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dimType57, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dimType57


class dimType52(unsignedLongintExpression):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        super(dimType52, self).__init__(minimum, maximum, valueOf_, )
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dimType52)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dimType52.subclass:
            return dimType52.subclass(*args_, **kwargs_)
        else:
            return dimType52(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dimType52, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='dimType52', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dimType52')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dimType52')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='dimType52', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='dimType52'):
        super(dimType52, self).exportAttributes(outfile, level, already_processed, namespace_, name_='dimType52')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='dimType52', fromsubclass_=False, pretty_print=True):
        super(dimType52, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dimType52, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dimType52


class dimType(unsignedLongintExpression):
    member_data_items_ = [
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        super(dimType, self).__init__(minimum, maximum, valueOf_, )
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dimType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dimType.subclass:
            return dimType.subclass(*args_, **kwargs_)
        else:
            return dimType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(dimType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='dimType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dimType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dimType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='dimType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='dimType'):
        super(dimType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='dimType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='dimType', fromsubclass_=False, pretty_print=True):
        super(dimType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(dimType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dimType


class remapAddressType27(unsignedLongintExpression):
    """Name of the state in which this remapped address range is valid"""
    member_data_items_ = [
        MemberSpec_('state', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, state=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        super(remapAddressType27, self).__init__(minimum, maximum, valueOf_, )
        self.state = _cast(None, state)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapAddressType27)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapAddressType27.subclass:
            return remapAddressType27.subclass(*args_, **kwargs_)
        else:
            return remapAddressType27(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(remapAddressType27, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='remapAddressType27', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapAddressType27')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='remapAddressType27')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='remapAddressType27', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='remapAddressType27'):
        super(remapAddressType27, self).exportAttributes(outfile, level, already_processed, namespace_, name_='remapAddressType27')
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='remapAddressType27', fromsubclass_=False, pretty_print=True):
        super(remapAddressType27, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(remapAddressType27, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class remapAddressType27


class remapAddressType(unsignedLongintExpression):
    """Name of the state in which this remapped address range is valid"""
    member_data_items_ = [
        MemberSpec_('state', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'unsignedLongintExpression', 0),
    ]
    subclass = None
    superclass = unsignedLongintExpression
    def __init__(self, minimum=None, maximum=None, state=None, id=None, valueOf_=None):
        self.original_tagname_ = None
        super(remapAddressType, self).__init__(minimum, maximum, valueOf_, )
        self.state = _cast(None, state)
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, remapAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if remapAddressType.subclass:
            return remapAddressType.subclass(*args_, **kwargs_)
        else:
            return remapAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(remapAddressType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='remapAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('remapAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='remapAddressType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='remapAddressType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='remapAddressType'):
        super(remapAddressType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='remapAddressType')
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.state), input_name='state')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='remapAddressType', fromsubclass_=False, pretty_print=True):
        super(remapAddressType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            self.state = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(remapAddressType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class remapAddressType


class flagsType(stringExpression):
    """ "true" indicates that the flags shall be appended to any existing
    flags, "false"indicates these flags will replace any existing
    default flags. """
    member_data_items_ = [
        MemberSpec_('append', 'xs:boolean', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'stringExpression', 0),
    ]
    subclass = None
    superclass = stringExpression
    def __init__(self, append=None, valueOf_=None):
        self.original_tagname_ = None
        super(flagsType, self).__init__(valueOf_, )
        self.append = _cast(bool, append)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, flagsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if flagsType.subclass:
            return flagsType.subclass(*args_, **kwargs_)
        else:
            return flagsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_append(self): return self.append
    def set_append(self, append): self.append = append
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(flagsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='flagsType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('flagsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='flagsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='flagsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='flagsType'):
        super(flagsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='flagsType')
        if self.append is not None and 'append' not in already_processed:
            already_processed.add('append')
            outfile.write(' append="%s"' % self.gds_format_boolean(self.append, input_name='append'))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='flagsType', fromsubclass_=False, pretty_print=True):
        super(flagsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('append', node)
        if value is not None and 'append' not in already_processed:
            already_processed.add('append')
            if value in ('true', '1'):
                self.append = True
            elif value in ('false', '0'):
                self.append = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(flagsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class flagsType


class clockPulseDurationType(realExpression):
    member_data_items_ = [
        MemberSpec_('units', 'ipxact:delayValueUnitType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'realExpression', 0),
    ]
    subclass = None
    superclass = realExpression
    def __init__(self, minimum=None, maximum=None, units='ns', valueOf_=None):
        self.original_tagname_ = None
        super(clockPulseDurationType, self).__init__(minimum, maximum, valueOf_, )
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clockPulseDurationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clockPulseDurationType.subclass:
            return clockPulseDurationType.subclass(*args_, **kwargs_)
        else:
            return clockPulseDurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(clockPulseDurationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='clockPulseDurationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clockPulseDurationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='clockPulseDurationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='clockPulseDurationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='clockPulseDurationType'):
        super(clockPulseDurationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='clockPulseDurationType')
        if self.units != "ns" and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='clockPulseDurationType', fromsubclass_=False, pretty_print=True):
        super(clockPulseDurationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
        super(clockPulseDurationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class clockPulseDurationType


class clockPulseOffsetType(realExpression):
    member_data_items_ = [
        MemberSpec_('units', 'ipxact:delayValueUnitType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'realExpression', 0),
    ]
    subclass = None
    superclass = realExpression
    def __init__(self, minimum=None, maximum=None, units='ns', valueOf_=None):
        self.original_tagname_ = None
        super(clockPulseOffsetType, self).__init__(minimum, maximum, valueOf_, )
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clockPulseOffsetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clockPulseOffsetType.subclass:
            return clockPulseOffsetType.subclass(*args_, **kwargs_)
        else:
            return clockPulseOffsetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(clockPulseOffsetType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='clockPulseOffsetType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clockPulseOffsetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='clockPulseOffsetType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='clockPulseOffsetType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='clockPulseOffsetType'):
        super(clockPulseOffsetType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='clockPulseOffsetType')
        if self.units != "ns" and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='clockPulseOffsetType', fromsubclass_=False, pretty_print=True):
        super(clockPulseOffsetType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
        super(clockPulseOffsetType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class clockPulseOffsetType


class clockPeriodType(realExpression):
    member_data_items_ = [
        MemberSpec_('units', 'ipxact:delayValueUnitType', 0, 1, {'use': 'optional'}),
        MemberSpec_('valueOf_', 'realExpression', 0),
    ]
    subclass = None
    superclass = realExpression
    def __init__(self, minimum=None, maximum=None, units='ns', valueOf_=None):
        self.original_tagname_ = None
        super(clockPeriodType, self).__init__(minimum, maximum, valueOf_, )
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, clockPeriodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if clockPeriodType.subclass:
            return clockPeriodType.subclass(*args_, **kwargs_)
        else:
            return clockPeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(clockPeriodType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='clockPeriodType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('clockPeriodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='clockPeriodType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='clockPeriodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='clockPeriodType'):
        super(clockPeriodType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='clockPeriodType')
        if self.units != "ns" and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='clockPeriodType', fromsubclass_=False, pretty_print=True):
        super(clockPeriodType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
        super(clockPeriodType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class clockPeriodType


class isResetType(unsignedBitExpression):
    """If this evaluates to true, it indicates this port triggers the reset
    of registers and fields, if not present its value is assumed to
    be false. The resetTypeRef attribute indicates the triggered
    reset event.Reference to a user defined resetType. Assumed to be
    HARD if not present."""
    member_data_items_ = [
        MemberSpec_('resetTypeRef', 'xs:Name', 0, 1, {'use': 'optional'}),
        MemberSpec_('id', 'xs:string', 0, 1, {'use': 'optional'}),
    ]
    subclass = None
    superclass = unsignedBitExpression
    def __init__(self, resetTypeRef=None, id=None):
        self.original_tagname_ = None
        super(isResetType, self).__init__()
        self.resetTypeRef = _cast(None, resetTypeRef)
        self.id = _cast(None, id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, isResetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if isResetType.subclass:
            return isResetType.subclass(*args_, **kwargs_)
        else:
            return isResetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resetTypeRef(self): return self.resetTypeRef
    def set_resetTypeRef(self, resetTypeRef): self.resetTypeRef = resetTypeRef
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            super(isResetType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='ipxact:', name_='isResetType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('isResetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='isResetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='ipxact:', name_='isResetType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='ipxact:', name_='isResetType'):
        super(isResetType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='isResetType')
        if self.resetTypeRef is not None and 'resetTypeRef' not in already_processed:
            already_processed.add('resetTypeRef')
            outfile.write(' resetTypeRef=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.resetTypeRef), input_name='resetTypeRef')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespace_='ipxact:', name_='isResetType', fromsubclass_=False, pretty_print=True):
        super(isResetType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resetTypeRef', node)
        if value is not None and 'resetTypeRef' not in already_processed:
            already_processed.add('resetTypeRef')
            self.resetTypeRef = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(isResetType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(isResetType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class isResetType


GDSClassesMapping = {
    'BusInterface': BusInterface,
    'abstractor': abstractorType,
    'abstractorGenerator': instanceGeneratorType,
    'activeCondition': unsignedBitExpression,
    'addressBlock': addressBlockType,
    'addressRange': unsignedPositiveLongintExpression,
    'addressSpaceRef': addrSpaceRefType,
    'addressUnitBits': unsignedPositiveLongintExpression,
    'arrays': configurableArrays,
    'bank': addressBankType,
    'baseAddress': unsignedLongintExpression,
    'bitsInLau': unsignedPositiveLongintExpression,
    'busWidth': unsignedIntExpression,
    'component': Component,
    'componentGenerator': instanceGeneratorType,
    'defaultValue': unsignedBitVectorExpression,
    'driver': driverType,
    'fileSet': fileSetType,
    'indirectInterface': indirectInterfaceType,
    'isPresent': unsignedBitExpression,
    'left': unsignedIntExpression,
    'memoryMapRef': memoryMapRefType,
    'model': Model,
    'parameter': parameterType,
    'phase': realExpression,
    'port': Port,
    'right': unsignedIntExpression,
    'typeParameter': moduleParameterType,
    'value': stringExpression,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'busDefinition'
        rootClass = busDefinition
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'busDefinition'
        rootClass = busDefinition
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'busDefinition'
        rootClass = busDefinition
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:ipxact="http://www.accellera.org/XMLSchema/IPXACT/1685-2014"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'busDefinition'
        rootClass = busDefinition
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from ipxact import *\n\n')
        sys.stdout.write('import ipxact as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AbstractionType",
    "AbstractionTypes",
    "BusInterface",
    "BusInterfaces",
    "Component",
    "ConfigurableLibraryRef",
    "LibraryRef",
    "LogicalPort",
    "Master",
    "Model",
    "PartSelect",
    "PhysicalPort",
    "Port",
    "PortMap",
    "PortMaps",
    "PortWire",
    "Ports",
    "Range",
    "Slave",
    "Vector",
    "Vectors",
    "abstractionDefPortConstraintsType",
    "abstractionDefinition",
    "abstractorBusInterfaceType",
    "abstractorGenerators",
    "abstractorInstanceType",
    "abstractorInstancesType",
    "abstractorInterfacesType",
    "abstractorModeType75",
    "abstractorModelType",
    "abstractorPortType",
    "abstractorPortWireType",
    "abstractorType",
    "accessHandlesType",
    "accessHandlesType42",
    "accessHandlesType43",
    "accessHandlesType44",
    "accessHandlesType45",
    "accessHandlesType46",
    "accessHandlesType47",
    "accessHandlesType48",
    "accessHandlesType49",
    "accessHandlesType51",
    "accessHandlesType53",
    "accessHandlesType56",
    "accessHandlesType62",
    "accessHandlesType65",
    "activeInterface",
    "adHocConnection",
    "adHocConnections",
    "addrSpaceRefType",
    "addressBankType",
    "addressBlockType",
    "addressSpaceRefType",
    "addressSpaceRefType21",
    "addressSpaceType",
    "addressSpaces",
    "alternateGroupType",
    "alternateGroupsType",
    "alternateRegisterType",
    "alternateRegisters",
    "apiTypeType",
    "argumentType",
    "arrayType",
    "assertion",
    "assertions",
    "bankedBankType",
    "bankedBlockType",
    "bankedSubspaceType",
    "baseAddressesType",
    "baseAddressesType26",
    "buildCommandType",
    "busDefinition",
    "busInterfaceRefType",
    "catalog",
    "cellFunctionType",
    "cellSpecification",
    "chainGroupType",
    "channelType",
    "channels",
    "choiceType",
    "choices",
    "clockDriver",
    "clockDriverType",
    "clockPeriodType",
    "clockPulseDurationType",
    "clockPulseOffsetType",
    "complexBaseExpression",
    "complexBitSteeringExpression",
    "complexTiedValueType",
    "componentGenerators",
    "componentInstance",
    "componentInstances",
    "componentInstantiationType",
    "configurableArrays",
    "configurableElementValue",
    "configurableElementValues",
    "connectionType",
    "constraintSet",
    "constraintSetRef",
    "constraintSets",
    "cpuType",
    "cpusType",
    "dependency",
    "design",
    "designConfiguration",
    "designConfigurationInstantiationType",
    "designInstantiationType",
    "dimType",
    "dimType52",
    "dimType57",
    "dimType63",
    "dimType66",
    "driveConstraint",
    "driverType",
    "drivers",
    "enumeratedValueType",
    "enumeratedValues",
    "enumerationType",
    "envIdentifierType67",
    "envIdentifierType71",
    "excludePortType",
    "excludePortsType",
    "executableImage",
    "exportedNameType",
    "extensionType",
    "externalPortReference",
    "fieldType",
    "file",
    "fileBuilderType",
    "fileBuilderType16",
    "fileSetRef",
    "fileSetRefGroupType",
    "fileSetRefGroupType19",
    "fileSetRefGroupType23",
    "fileSetType",
    "fileSets",
    "fileType",
    "flagsType",
    "functionType",
    "generator",
    "generatorChain",
    "generatorChainSelectorType",
    "generatorRef",
    "generatorSelectorType",
    "generatorType",
    "groupSelector",
    "groupType",
    "groupType17",
    "hierInterface",
    "hierInterfaceType",
    "imageTypeType",
    "indexedAccessHandle",
    "indicesType",
    "indicesType2",
    "indicesType5",
    "indirectInterfaceType",
    "indirectInterfaces",
    "instanceGeneratorType",
    "instantiationsType",
    "instantiationsType72",
    "interconnection",
    "interconnectionConfigurationType",
    "interconnections",
    "interfaceRefType",
    "interfaceType",
    "internalPortReferenceType",
    "ipxactFileType",
    "ipxactFilesType",
    "ipxactURI",
    "isIncludeFileType",
    "isResetType",
    "kind",
    "languageToolsType",
    "languageType",
    "leafAccessHandle",
    "linkerCommandFile",
    "loadConstraint",
    "localAddressBankType",
    "localBankedBankType",
    "localMemoryMapType",
    "logicalNameType",
    "masterType20",
    "memoryMapRefType",
    "memoryMapType",
    "memoryMaps",
    "memoryRemapType",
    "mirroredMasterType",
    "mirroredMasterType28",
    "mirroredSlaveType",
    "mirroredSlaveType25",
    "mirroredSystemType",
    "mirroredSystemType29",
    "mirroredSystemType32",
    "modifiedWriteValueType54",
    "modifiedWriteValueType58",
    "moduleParameterType",
    "moduleParametersType",
    "monitorInterconnection",
    "monitorInterfaceType",
    "monitorInterfaceType1",
    "monitorType",
    "monitorType30",
    "nameType",
    "nameValuePairType",
    "nonIndexedLeafAccessHandle",
    "onMasterType",
    "onMasterType38",
    "onSlaveType",
    "onSlaveType40",
    "onSystemType",
    "onSystemType36",
    "otherClockDriver",
    "otherClocks",
    "parameterBaseType",
    "parameterType",
    "parameters",
    "pathSegmentType",
    "pathSegmentsType",
    "pathSegmentsType7",
    "pathSegmentsType8",
    "payload",
    "portAccessType",
    "portReferencesType",
    "portTransactionalType",
    "portType34",
    "portsType68",
    "portsType73",
    "protocol",
    "protocolTypeType9",
    "qualifierType",
    "qualifierType35",
    "readActionType55",
    "readActionType59",
    "realExpression",
    "registerFile",
    "registerType",
    "registerType50",
    "registerType61",
    "registerType64",
    "remapAddressType",
    "remapAddressType27",
    "remapPortType",
    "remapPortsType",
    "remapStateType",
    "remapStates",
    "requiresDriver",
    "reset",
    "resetTypeType",
    "resetTypesType",
    "resetsType",
    "segmentType",
    "segmentsType",
    "serviceTypeDef",
    "serviceTypeDefs",
    "signedIntExpression",
    "signedLongintExpression",
    "simpleAccessHandle",
    "singleShotDriver",
    "slaveType22",
    "sliceType",
    "slicesType",
    "sourceFileType",
    "stringExpression",
    "stringURIExpression",
    "subspaceRefType",
    "systemGroupNameType",
    "systemGroupNamesType",
    "systemType",
    "systemType24",
    "systemType31",
    "testableType",
    "testableType60",
    "timingConstraint",
    "transTypeDef",
    "transTypeDefs",
    "transactionalType",
    "transparentBridge",
    "transportMethodType18",
    "transportMethodsType",
    "typeDefinitionType",
    "typeDefinitionType12",
    "typeDefinitionType14",
    "typeNameType",
    "typeNameType11",
    "typeNameType13",
    "typeParameters",
    "unsignedBitExpression",
    "unsignedBitVectorExpression",
    "unsignedIntExpression",
    "unsignedLongintExpression",
    "unsignedPositiveIntExpression",
    "unsignedPositiveLongintExpression",
    "valueMaskConfigType",
    "vectorType",
    "vendorExtensions",
    "viewConfigurationType",
    "viewRef",
    "viewRefType",
    "viewRefType10",
    "viewRefType15",
    "viewRefType3",
    "viewRefType4",
    "viewRefType6",
    "viewType",
    "viewType70",
    "viewType74",
    "viewsType",
    "viewsType69",
    "whiteboxElementRefType",
    "whiteboxElementRefsType",
    "whiteboxElementType",
    "whiteboxElementsType",
    "wireType",
    "wireTypeDef",
    "wireTypeDefs",
    "writeValueConstraintType"
]
